/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Compositor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
/* harmony import */ var _RtcPeerConnectionFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(63);
/* harmony import */ var _RtcBufferFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/* harmony import */ var _Shell__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
/* harmony import */ var _Seat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(73);
/* harmony import */ var _DataDeviceManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(93);
/* harmony import */ var _Output__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(97);
/* harmony import */ var _Subcompositor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(99);
/* harmony import */ var _style_greenfield_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(105);
/* harmony import */ var _style_greenfield_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_style_greenfield_css__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _XdgWmBase__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(110);
/* harmony import */ var _desktopshell_DesktopUserShell__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(125);

















/**
 * @param {Session}session
 */
function setupGlobals (session) {
  const output = _Output__WEBPACK_IMPORTED_MODULE_9__["default"].create()
  const seat = _Seat__WEBPACK_IMPORTED_MODULE_7__["default"].create(session)
  const compositor = _Compositor__WEBPACK_IMPORTED_MODULE_1__["default"].create(session, seat)
  const dataDeviceManager = _DataDeviceManager__WEBPACK_IMPORTED_MODULE_8__["default"].create()
  const subcompositor = _Subcompositor__WEBPACK_IMPORTED_MODULE_10__["default"].create()

  const rtcPeerConnectionFactory = _RtcPeerConnectionFactory__WEBPACK_IMPORTED_MODULE_4__["default"].create()
  const rtcBufferFactory = _RtcBufferFactory__WEBPACK_IMPORTED_MODULE_5__["default"].create()

  const desktopUserShell = _desktopshell_DesktopUserShell__WEBPACK_IMPORTED_MODULE_13__["default"].create(session, seat)

  const shell = _Shell__WEBPACK_IMPORTED_MODULE_6__["default"].create(session, desktopUserShell)
  const xdgWmBase = _XdgWmBase__WEBPACK_IMPORTED_MODULE_12__["default"].create(session, desktopUserShell, seat)

  output.registerGlobal(session.display.registry)
  compositor.registerGlobal(session.display.registry)
  dataDeviceManager.registerGlobal(session.display.registry)
  seat.registerGlobal(session.display.registry)
  shell.registerGlobal(session.display.registry)
  subcompositor.registerGlobal(session.display.registry)

  rtcPeerConnectionFactory.registerGlobal(session.display.registry)
  rtcBufferFactory.registerGlobal(session.display.registry)

  xdgWmBase.registerGlobal(session.display.registry)
}

function main () {
  const compositorSessionId = uuidv4()
  const session = _Session__WEBPACK_IMPORTED_MODULE_0__["default"].create(compositorSessionId)
  setupGlobals(session)
}

/**
 * @param {*}module
 */
function loadNativeModule (module) {
  return new Promise((resolve) => {
    if (module.calledRun) {
      resolve()
    } else {
      module.onRuntimeInitialized = () => {
        resolve()
      }
    }
  })
}

/**
 * @return {string}
 */
function uuidv4 () {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  )
}

window.onload = async () => {
  // make sure all native modules are ready for use before we start our main flow
  await loadNativeModule(_lib_libpixman_1__WEBPACK_IMPORTED_MODULE_2__["default"])
  await loadNativeModule(_lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_3__["default"])
  await main()
}

// This adds a zero timeout 'run later' mechanism:
// https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Reasons_for_delays_longer_than_specified

// Only add setZeroTimeout to the window object, and hide everything
// else in a closure.
(function () {
  const timeouts = []
  const messageName = 'zero-timeout-message'

  // Like setTimeout, but only takes a function argument.  There's
  // no time argument (always zero) and no arguments (you have to
  // use a closure).
  function setZeroTimeout (fn) {
    timeouts.push(fn)
    window.postMessage(messageName, '*')
  }

  function handleMessage (event) {
    if (event.source === window && event.data === messageName) {
      event.stopPropagation()
      if (timeouts.length > 0) {
        const fn = timeouts.shift()
        fn()
      }
    }
  }

  window.addEventListener('message', handleMessage, true)

  // Add the one thing we want added to the window object.
  window.setZeroTimeout = setZeroTimeout
})()


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Session; });
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__);
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrSessionRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrSessionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrClientSessionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _ClientSession__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);










/**
 * Listens for client announcements from the server.
 * @implements {GrSessionRequests}
 */
class Session extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrSessionRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   * @param {string} compositorSessionId unique random compositor session id
   * @returns {Session}
   */
  static create (compositorSessionId) {
    false && console.log('Starting new compositor session.')
    const display = new westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__["Display"]()
    const websocketProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws'
    const url = `${websocketProtocol}://${window.location.host}/${compositorSessionId}`
    const session = new Session(url, display, compositorSessionId)

    session._createWebSocket(url)
    session._setupPrimaryConnection()

    display.registry.createGlobal(this, !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrSessionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).name, 1, (client, id, version) => {
      session.bindClient(client, id, version)
    })

    return session
  }

  /**
   * Use Session.create(..) instead
   * @param {string}url
   * @param {Display}display
   * @param {string}compositorSessionId
   * @private
   */
  constructor (url, display, compositorSessionId) {
    super()
    /**
     * @type {string}
     */
    this.url = url
    /**
     * @type {Display}
     */
    this.display = display
    /**
     * @type {string}
     */
    this.compositorSessionId = compositorSessionId
    /**
     * @type {{}}
     * @private
     */
    this._clients = {}
    /**
     * @type {WebSocket}
     * @private
     */
    this._ws = null
    /**
     * @type {Array<GrSessionResource>}
     */
    this.resources = []
    /**
     * @type {Array<ArrayBuffer>}
     * @private
     */
    this._wireMessages = []
  }

  /**
   * @param {string} url
   * @private
   */
  _createWebSocket (url) {
    const ws = new WebSocket(url)
    ws.binaryType = 'arraybuffer'
    ws.onerror = (event) => {
      console.error(`Session web socket is in error.`)
      if (ws.readyState === WebSocket.CONNECTING) {
        false && console.log('Fatal error while connecting websocket.')
        // TODO signal user a fatal error has accurred. Implement some kind of retry mechanism?
      }
    }
    ws.onopen = () => {
      false && console.log('Session web socket is open.')
    }
    ws.onmessage = async (event) => {
      try {
        this._wireMessages.push(/** @types {ArrayBuffer} */event.data)

        if (this._wireMessages.length === 1) {
          while (this._wireMessages.length) {
            this.flush()
            const wireMessage = this._wireMessages[0]
            const sessionId = new DataView(wireMessage).getUint32(0, true)
            const arrayBuffer = wireMessage.slice(4, wireMessage.byteLength)

            const client = this._clients[sessionId]
            await client.message(arrayBuffer)
            this._wireMessages.shift()
            this.flush()
          }
        }
      } catch (error) {
        console.error(`Session web socket failed to handle incoming message. \n${error.stack}`)
        this._ws.close(4007, 'Session web socket received an illegal message')
      }
    }
    ws.onclose = (event) => {
      false && console.log(`Web socket closed. ${event.code}:${event.reason}`)
    }
    this._ws = ws

    window.onbeforeunload = (e) => {
      const dialogText = 'dummytext'
      e.returnValue = dialogText
      return dialogText
    }
  }

  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  bindClient (client, id, version) {
    const grSessionResource = new !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrSessionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(client, id, version)
    grSessionResource.implementation = this
    this.resources.push(grSessionResource)
  }

  _setupPrimaryConnection () {
    return this._setupConnection(0)
  }

  /**
   * @param {!number}connectionId
   * @return {!Client}
   * @private
   */
  _setupConnection (connectionId) {
    const client = this.display.createClient()
    this._clients[connectionId] = client
    this._setupClientConnection(client, connectionId)
    return client
  }

  /**
   * @param {!Client}client
   * @param {!number}clientSessionId
   * @private
   */
  _setupClientConnection (client, clientSessionId) {
    client.onFlush = (arrayBuffer) => {
      try {
        const b = new Uint8Array(arrayBuffer.byteLength + 4)
        new DataView(b.buffer).setUint32(0, clientSessionId, true)
        b.set(new Uint8Array(arrayBuffer), 4)
        this._ws.send(b.buffer)
      } catch (error) {
        console.error(error.stack)
        this._ws.close(4002, 'Session web socket is in error.')
      }
    }
  }

  /**
   *
   * @param {!GrSessionResource} resource
   * @param {!number}id client session resource id
   * @param {!number}connectionId
   * @since 1
   *
   */
  client (resource, id, connectionId) {
    false && console.log('New client connected.')
    const clientConnection = this._setupConnection(connectionId)
    const grClientSessionResource = new !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrClientSessionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(resource.client, id, resource.version)
    grClientSessionResource.implementation = _ClientSession__WEBPACK_IMPORTED_MODULE_2__["default"].create(clientConnection)
  }

  flush () {
    this.display.flushClients()
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/**
 * @type {{namespace: Object, Client: Client, Display: Display, Fixed: Fixed, Global: Global, CompositorEndpoint: CompositorEndpoint}}
 */
module.exports = {
  Client: __webpack_require__(4),
  Display: __webpack_require__(11),
  Fixed: __webpack_require__(8),
  Global: __webpack_require__(15),
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const DisplayResource = __webpack_require__(5)
const DisplayRequests = __webpack_require__(9)
const SyncCallbackResource = __webpack_require__(10)
const Fixed = __webpack_require__(8)

/**
 * Represents a client connection.
 * @implements DisplayRequests
 */
class Client extends DisplayRequests {
  /**
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @param {number}consumption
   * @private
   */
  static _checkMessageSize (wireMsg, consumption) {
    if (wireMsg.consumed + consumption > wireMsg.size) {
      throw new Error(`Request too short.`)
    } else {
      wireMsg.consumed += consumption
    }
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @returns {number}
   */
  u (wireMsg) { // unsigned integer {number}
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)

    const arg = new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += argSize

    return arg
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @returns {number}
   */
  i (wireMsg) { // integer {number}
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)

    const arg = new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += argSize
    return arg
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @returns {number}
   */
  f (wireMsg) { // float {number}
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)
    const arg = new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += argSize
    return new Fixed(arg >> 0)
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @param {Boolean} optional
   * @returns {Resource}
   */
  o (wireMsg, optional) {
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)
    const arg = new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += argSize
    if (optional && arg === 0) {
      return null
    } else {
      return this._resources[arg]
    }
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @returns {number}
   */
  n (wireMsg) {
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)
    const arg = new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += argSize
    return arg
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @param {Boolean} optional
   * @returns {String}
   */
  s (wireMsg, optional) { // {String}
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)
    const stringSize = new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += 4
    if (optional && stringSize === 0) {
      return null
    } else {
      const alignedSize = ((stringSize + 3) & ~3)
      Client._checkMessageSize(wireMsg, alignedSize)
      const byteArray = new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset, stringSize)
      wireMsg.bufferOffset += alignedSize
      return String.fromCharCode.apply(null, byteArray)
    }
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @param {Boolean} optional
   * @returns {ArrayBuffer}
   */
  a (wireMsg, optional) {
    const argSize = 4
    Client._checkMessageSize(wireMsg, argSize)
    const arraySize = new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0]
    wireMsg.bufferOffset += 4
    if (optional && arraySize === 0) {
      return null
    } else {
      const alignedSize = ((arraySize + 3) & ~3)
      Client._checkMessageSize(wireMsg, alignedSize)
      const arg = wireMsg.buffer.slice(wireMsg.bufferOffset, wireMsg.bufferOffset + arraySize)
      wireMsg.bufferOffset += alignedSize
      return arg
    }
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} wireMsg
   * @returns {number}
   */
  h (wireMsg) { // file descriptor {number}
    if (wireMsg.fds.length) {
      return wireMsg.fds.shift()
    } else {
      throw new Error('File descriptor expected.')
    }
  }

  /**
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number, consumed: number, size: number}} message
   * @param {string} argsSignature
   * @returns {Array<*>}
   */
  unmarshallArgs (message, argsSignature) {
    const argsSigLength = argsSignature.length
    const args = []
    let optional = false
    for (let i = 0; i < argsSigLength; i++) {
      let signature = argsSignature[i]
      optional = signature === '?'

      if (optional) {
        signature = argsSignature[++i]
      }

      args.push(this[signature](message, optional))
    }
    return args
  }

  /**
   * This doesn't actually send the message, but queues it so it can be send on flush.
   * @param {{buffer: ArrayBuffer, fds: Array<number>}}wireMsg a single wire message event.
   */
  onSend (wireMsg) {
    if (!this._display) {
      // client destroyed
      return
    }
    this._outMessages.push(wireMsg)
  }

  /**
   * Empty the queue of wire messages and send them to the other end.
   */
  flush () {
    if (!this._display) {
      // client destroyed
      return
    }

    if (this._outMessages.length === 0) {
      return
    }
    // const totalBufferLength = this._outMessages.reduce((previous, current) => {
    //   return previous + current.buffer.byteLength
    // }, 0)
    // let offset = 0
    // const wireMessages = new Uint8Array(new ArrayBuffer(totalBufferLength))
    //
    // this._outMessages.forEach((wireMessage) => {
    //   wireMessages.set(new Uint8Array(wireMessage.buffer), offset)
    //   offset += wireMessage.buffer.byteLength
    // })

    this.onFlush(this._outMessages)
    this._outMessages = []
  }

  /**
   * Callback when this connection wishes to send data to the other end. This callback can be used to send the given
   * array buffers using any transport mechanism.
   * @param {Array<{buffer: ArrayBuffer, fds: Array<number>}>}wireMessages
   */
  onFlush (wireMessages) {}

  /**
   * Handle a received message from a client.
   * @param {{buffer: ArrayBuffer, fds: Array<number>}} incomingWireMessages
   * @return {Promise<void>}
   * @throws Error If an illegal client request is received ie. bad length or missing file descriptor.
   */
  async message (incomingWireMessages) {
    if (!this._display) {
      // client destroyed
      return
    }

    incomingWireMessages.bufferOffset = 0

    this._inMessages.push(incomingWireMessages)
    if (this._inMessages.length > 1) {
      // more than one message in queue means the message loop is in await, don't concurrently process the new
      // message, instead return early and let the resume-from-await pick up the newly queued message.
      return
    }

    while (this._inMessages.length) {
      const wireMessages = this._inMessages[0]
      while (wireMessages.bufferOffset < wireMessages.buffer.byteLength) {
        const id = new Uint32Array(wireMessages.buffer, wireMessages.bufferOffset)[0]
        const bufu16 = new Uint16Array(wireMessages.buffer, wireMessages.bufferOffset + 4)
        wireMessages.size = bufu16[1]
        if (wireMessages.size > wireMessages.buffer.byteLength) {
          throw new Error('Request buffer too small')
        }

        const opcode = bufu16[0]
        const resource = this._resources[id]
        if (resource) {
          wireMessages.bufferOffset += 8
          wireMessages.consumed = 8
          await resource[opcode](wireMessages)
          if (!this._display) {
            // client destroyed
            return
          }
        }
      }
      this._inMessages.shift()
    }
  }

  close () {
    if (!this._display) {
      // client destroyed
      return
    }

    Object.values(this._resources).forEach((resource) => {
      resource.destroy()
    })

    this._outMessages = null
    this._inMessages = null
    this.displayResource = null
    this._resources = null
    this._display = null
    this._destroyedResolver()
  }

  /**
   *
   * @returns {Promise<void>}
   */
  onClose () {
    return this._destroyPromise
  }

  /**
   *
   * @param {Resource} resource
   */
  registerResource (resource) {
    if (!this._display) {
      // client destroyed
      return
    }
    this._resources[resource.id] = resource
  }

  /**
   *
   * @param {Resource} resource
   */
  unregisterResource (resource) {
    if (!this._display) {
      // client destroyed
      return
    }
    delete this._resources[resource.id]
    this.displayResource.deleteId(resource.id)
  }

  /**
   *
   * @param {number} id
   * @param {number} opcode
   * @param {number} size
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}>} argsArray
   * @private
   */
  __marshallMsg (id, opcode, size, argsArray) {
    /**
     * @type {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}}
     */
    const wireMsg = {
      buffer: new ArrayBuffer(size),
      fds: [],
      bufferOffset: 0
    }

    // write actual wire message
    const bufu32 = new Uint32Array(wireMsg.buffer)
    const bufu16 = new Uint16Array(wireMsg.buffer)
    bufu32[0] = id
    bufu16[2] = opcode
    bufu16[3] = size
    wireMsg.bufferOffset = 8

    argsArray.forEach((arg) => {
      arg._marshallArg(wireMsg) // write actual argument value to buffer
    })

    this.onSend(wireMsg)
  }

  /**
   * @param {number} id
   * @param {number} opcode
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}>} argsArray
   * @return {number}
   */
  marshallConstructor (id, opcode, argsArray) {
    // get next server id
    const objectId = this._display.nextId
    this._display.nextId++

    // determine required wire message length
    let size = 4 + 2 + 2 // id+size+opcode
    argsArray.forEach(function (arg) {
      if (arg.type === 'n') {
        arg.value = objectId
      }

      size += arg.size // add size of the actual argument values
    })

    this.__marshallMsg(id, opcode, size, argsArray)

    return objectId
  }

  /**
   *
   * @param {number} id
   * @param {number} opcode
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}>} argsArray
   */
  marshall (id, opcode, argsArray) {
    // determine required wire message length
    let size = 4 + 2 + 2  // id+size+opcode
    argsArray.forEach(function (arg) {
      size += arg.size // add size of the actual argument values
    })

    this.__marshallMsg(id, opcode, size, argsArray)
  }

  /**
   * @param {DisplayResource}resource
   * @param {number}id
   * @override
   */
  sync (resource, id) {
    const syncCallbackResource = new SyncCallbackResource(resource.client, id, 1)
    syncCallbackResource.done(++this._syncEventSerial)
    syncCallbackResource.destroy()
  }

  /**
   * @param {DisplayResource}resource
   * @param {number}id
   * @override
   */
  getRegistry (resource, id) {
    this._display.registry.publishGlobals(this._display.registry.createRegistryResource(this, id))
  }

  /**
   *
   * @param {Display} display
   */
  constructor (display) {
    super()
    /**
     * @type {Object.<number, Resource>}
     * @private
     */
    this._resources = {}
    /**
     * @type {Display}
     * @private
     */
    this._display = display
    /**
     * @type {number}
     * @private
     */
    this._syncEventSerial = 0
    /**
     * @type {function():void}
     * @private
     */
    this._destroyedResolver = null
    /**
     * @type {Promise<void>}
     * @private
     */
    this._destroyPromise = new Promise((resolve) => {
      this._destroyedResolver = resolve
    })
    /**
     * @type {DisplayResource}
     */
    this.displayResource = new DisplayResource(this, 1, 0)
    this.displayResource.implementation = this
    /**
     * @type {Array<{buffer: ArrayBuffer, fds: Array<number>}>}
     * @private
     */
    this._outMessages = []
    /**
     * @type {Array<{buffer: ArrayBuffer, fds: Array<number>}>}
     * @private
     */
    this._inMessages = []
  }
}

module.exports = Client

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const Resource = __webpack_require__(6)
const {uint, object, string} = __webpack_require__(7)

class DisplayResource extends Resource {
  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  constructor (client, id, version) {
    super(client, id, version)
    /**
     * @type {DisplayRequests}
     */
    this.implementation = null
  }

  /**
   * opcode 0 -> sync
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} message
   */
  async [0] (message) {
    const args = this.client.unmarshallArgs(message, 'n')
    await this.implementation.sync(this, ...args)
  }

  /**
   * opcode 1 -> getRegistry
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} message
   */
  async [1] (message) {
    const args = this.client.unmarshallArgs(message, 'n')
    await this.implementation.getRegistry(this, ...args)
  }

  /**
   *  The error event is sent out when a fatal (non-recoverable)
   *  error has occurred.  The object_id argument is the object
   *  where the error occurred, most often in response to a request
   *  to that object.  The code identifies the error and is defined
   *  by the object interface.  As such, each interface defines its
   *  own set of error codes.  The message is a brief description
   *  of the error, for (debugging) convenience.
   *
   * @param {Resource}errorObject object where the error occurred
   * @param {number}code error code
   * @param {string}message error description
   */
  error (errorObject, code, message) {
    this.client.marshall(this.id, 0, [object(errorObject), uint(code), string(message)])
    this.client.flush()
    this.client.close()
  }

  /**
   *  This event is used internally by the object ID management
   *  logic.  When a client deletes an object, the server will send
   *  this event to acknowledge that it has seen the delete request.
   *  When the client receives this event, it will know that it can
   *  safely reuse the object ID.
   *
   * @param {number}id deleted object ID
   */
  deleteId (id) {
    this.client.marshall(this.id, 1, [uint(id)])
  }
}

module.exports = DisplayResource

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const {string} = __webpack_require__(7)

class Resource {
  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  constructor (client, id, version) {
    /**
     * @type {Client}
     */
    this.client = client
    /**
     * @type {number}
     */
    this.id = id
    /**
     * @type {number}
     */
    this.version = version
    /**
     * Arbitrary data that can be attached to the resource.
     * @type {{}}
     */
    this.userData = {}
    /**
     * @type {Promise<void>}
     * @private
     */
    this._destroyPromise = new Promise((resolve) => {
      this._destroyResolver = resolve
    })
    /**
     * @type {Array<function(Resource):void>}
     * @private
     */
    this._destroyListeners = []
    this._destroyPromise.then(() => {
      this._destroyListeners.forEach((destroyListener) => destroyListener(this))
    })

    this.client.registerResource(this)
  }

  /**
   *
   * @param {number} code
   * @param {string} msg
   */
  postError (code, msg) {
    this.client.displayResource.error(this, code, msg)
  }

  destroy () {
    this._destroyResolver(this)
    this.client.unregisterResource(this)
  }

  /**
   * @param {function(Resource):void}destroyListener
   */
  addDestroyListener (destroyListener) {
    this._destroyListeners.push(destroyListener)
  }

  /**
   * @param {function(Resource):void}destroyListener
   */
  removeDestroyListener (destroyListener) {
    this._destroyListeners = this._destroyListeners.filter((item) => { return item !== destroyListener })
  }

  /**
   * @return {Promise<void>}
   */
  onDestroy () {
    return this._destroyPromise
  }
}

module.exports = Resource

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const Fixed = __webpack_require__(8)

class WireFormat {

  /**
   * @param {number} arg
   * @returns {{value: number, type: 'u', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   */
  static uint (arg) {
    return {
      value: arg,
      type: 'u',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'u', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static uintOptional (arg) {
    return {
      value: arg,
      type: 'u',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'h', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static fileDescriptor (arg) {
    return {
      value: arg,
      type: 'h',
      size: 0, // file descriptors are not added to the message size because they are not part of the unix socket message buffer.
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        wireMsg.fds.push(this.value)
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'h', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static fileDescriptorOptional (arg) {
    return {
      value: arg,
      type: 'h',
      size: 0, // file descriptors are not added to the message size because they are not part of the unix socket message buffer.
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        wireMsg.fds.push(this.value)
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'i', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static int (arg) {
    return {
      value: arg,
      type: 'i',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'i', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static intOptional (arg) {
    return {
      value: arg,
      type: 'i',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Fixed} arg
   * @returns {{value: Fixed, type: 'f', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   */
  static fixed (arg) {
    return {
      value: arg,
      type: 'f',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value._raw
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Fixed} arg
   * @returns {{value: Fixed, type: 'f', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   */
  static fixedOptional (arg) {
    return {
      value: arg,
      type: 'f',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value._raw)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Resource} arg
   * @returns {{value: Resource, type: 'o', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static object (arg) {
    return {
      value: arg,
      type: 'o',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.id
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Resource} arg
   * @returns {{value: Resource, type: 'o', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static objectOptional (arg) {
    return {
      value: arg,
      type: 'o',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value.id)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   * @returns {{value: number, type: 'n', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   */
  static newObject () {
    return {
      value: 0, // id filled in by _marshallConstructor
      type: 'n',
      size: 4,
      optional: false,
      /**
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {string} arg
   * @returns {{value: string, type: 's', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static string (arg) {
    return {
      value: arg,
      type: 's',
      size: 4 + (function () {
        // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
        return (arg.length + 3) & ~3
      })(),
      optional: false,
      /**
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.length

        const strLen = this.value.length
        const buf8 = new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, strLen)
        for (let i = 0; i < strLen; i++) {
          buf8[i] = this.value[i].codePointAt(0)
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {String} arg
   * @returns {{value: *, type: 's', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static stringOptional (arg) {
    return {
      value: arg,
      type: 's',
      size: 4 + (function () {
        if (arg === null) {
          return 0
        } else {
          // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
          return (arg.length + 3) & ~3
        }
      })(),
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        if (this.value === null) {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = 0
        } else {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.length

          const strLen = this.value.length
          const buf8 = new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, strLen)
          for (let i = 0; i < strLen; i++) {
            buf8[i] = this.value[i].codePointAt(0)
          }
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {TypedArray} arg
   * @returns {{value: *, type: 'a', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static array (arg) {
    return {
      value: arg,
      type: 'a',
      size: 4 + (function () {
        // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
        return (arg.byteLength + 3) & ~3
      })(),
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.byteLength

        const byteLength = this.value.byteLength
        new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, byteLength).set(new Uint8Array(this.value.buffer, 0, byteLength))

        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {TypedArray} arg
   * @returns {{value: *, type: 'a', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}):void}}
   *
   */
  static arrayOptional (arg) {
    return {
      value: arg,
      type: 'a',
      size: 4 + (function () {
        if (arg === null) {
          return 0
        } else {
          // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
          return (arg.byteLength + 3) & ~3
        }
      })(),
      optional: true,
      _marshallArg: function (wireMsg) {
        if (this.value === null) {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = 0
        } else {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.byteLength

          const byteLength = this.value.byteLength
          new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, byteLength).set(new Uint8Array(this.value.buffer, 0, byteLength))
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }
}

module.exports = WireFormat

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



class Fixed {
  /**
   * @param {number}number
   * @return {Fixed}
   */
  static parse (number) {
    return new Fixed((number * 256.0) >> 0)
  }

  /**
   * Represent fixed as a signed 24-bit integer.
   *
   * @returns {number}
   */
  asInt () {
    return ((this._raw / 256.0) >> 0)
  }

  /**
   * Represent fixed as a signed 24-bit number with an 8-bit fractional part.
   *
   * @returns {number}
   */
  asDouble () {
    return this._raw / 256.0
  }

  /**
   * use parseFixed instead
   * @param {number}raw
   */
  constructor (raw) {
    this._raw = raw
  }
}

module.exports = Fixed

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/**
 * @interface
 */
class DisplayRequests {
  /**
   * @param {DisplayResource}resource
   * @param {number}id
   */
  sync (resource, id) {}
  /**
   * @param {DisplayResource}resource
   * @param {number}id
   */
  getRegistry (resource, id) {}
}

module.exports = DisplayRequests

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const Resource = __webpack_require__(6)
const {uint} = __webpack_require__(7)

class SyncCallbackResource extends Resource {
  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  constructor (client, id, version) {
    super(client, id, version)
  }

  /**
   *
   * Notify the client when the related request is done.
   *
   *
   * @param {number} callbackData request-specific data for the callback
   *
   * @since 1
   *
   */
  done (callbackData) {
    this.client.marshall(this.id, 0, [uint(callbackData)])
  }
}

module.exports = SyncCallbackResource


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const Client = __webpack_require__(4)
const Registry = __webpack_require__(12)

class Display {
  constructor () {
    /**
     * @type {Registry}
     */
    this.registry = new Registry()
    /**
     * @type {Array<Client>}
     */
    this.clients = []
    /*
     * IDs allocated by the client are in the range [1, 0xfeffffff] while IDs allocated by the server are
     * in the range [0xff000000, 0xffffffff]. The 0 ID is reserved to represent a null or non-existent object
     */
    /**
     * @type {number}
     */
    this.nextId = 0xff000000
  }

  /**
   * Next server side object id.
   * @return {number}
   */
  getNextObjectId () {
    return ++this.nextId
  }

  /**
   *
   * Invoked when a client binds to this global. Subclasses implement this method so they can instantiate a
   * corresponding wfs.Resource subtype.
   * @return {Client}
   */
  createClient () {
    const client = new Client(this)
    client.onClose().then(() => {
      const idx = this.clients.indexOf(client)
      if (idx > -1) {
        this.clients.splice(idx, 1)
      }
    })
    this.clients.push(client)
    return client
  }

  flushClients () {
    this.clients.forEach(client => {
      client.flush()
    })
  }
}

module.exports = Display

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const RegistryResource = __webpack_require__(13)
const RegistryRequests = __webpack_require__(14)
const Global = __webpack_require__(15)

/**
 * @implements {RegistryRequests}
 */
class Registry extends RegistryRequests {
  constructor () {
    super()
    /**
     * @type {Array<RegistryResource>}
     * @private
     */
    this._registryResources = []
    /**
     * @type {Object.<number,Global>}
     * @private
     */
    this._globals = {}
    /**
     * @type {number}
     * @private
     */
    this._nextGlobalName = 0
  }

  /**
   * Register a global to make it available to clients.
   *
   * @param {Object} implementation
   * @param {string}interface_
   * @param {number}version
   * @param {function(Client,number,number):void}bindCallback callback with Client, id, version arguments
   * @return {Global}
   */
  createGlobal (implementation, interface_, version, bindCallback) {
    const name = ++this._nextGlobalName
    const global = new Global(this, implementation, interface_, version, name, bindCallback)
    this._globals[name] = global
    this._registryResources.forEach(registryResource => registryResource.global(global.name, global.interface_, global.version))
    return global
  }

  /**
   * Unregister a global and revoke it from clients.
   *
   * @param {Global} global
   */
  destroyGlobal (global) {
    if (this._globals[global.name]) {
      delete this._globals[global.name]
      this._registryResources.forEach(registryResource => registryResource.globalRemove(global.name))
    }
  }

  /**
   * @param {RegistryResource} registryResource
   */
  publishGlobals (registryResource) {
    Object.entries(this._globals).forEach((global, name) => registryResource.global(name, global.interface_, global.version))
  }

  /**
   *
   * @param {Client} client
   * @param {number} id
   */
  createRegistryResource (client, id) {
    const registryResource = new RegistryResource(client, id, 1)
    registryResource.implementation = this
    this._registryResources.push(registryResource)
    return registryResource
  }

  /**
   * Binds a new, client-created object to the server using the
   * specified name as the identifier.
   * @param {Client}client
   * @param {RegistryResource}resource
   * @param {number}name unique numeric name of the object
   * @param {string}interface_
   * @param {number}version
   * @param {number}id bounded object
   * @override
   */
  bind (client, resource, name, interface_, version, id) {
    this._globals[name].bindClient(client, id, version)
  }
}

module.exports = Registry

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



const Resource = __webpack_require__(6)
const {uint, string} = __webpack_require__(7)

class RegistryResource extends Resource {
  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  constructor (client, id, version) {
    super(client, id, version)
    /**
     * @type {RegistryRequests}
     */
    this.implementation = null
  }

  /**
   * @param {number} name
   * @param {string} interface_
   * @param {number} version
   */
  global (name, interface_, version) {
    this.client.marshall(this.id, 0, [uint(name), string(interface_), uint(version)])
  }

  /**
   * Notify the client that the global with the given name id is removed.
   * @param {number} name
   */
  globalRemove (name) {
    this.client.marshall(this.id, 1, [uint(name)])
  }

  /**
   * opcode 1 -> bind
   *
   * @param {{buffer: ArrayBuffer, fds: Array<number>, bufferOffset: number}} message
   */
  async [0] (message) {
    const args = this.client.unmarshallArgs(message, 'usun')
    await this.implementation.bind(this.client, this, ...args)
  }
}

module.exports = RegistryResource


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/**
 * @interface
 */
class RegistryRequests {
  /**
   *  Binds a new, client-created object to the server using the
   * specified name as the identifier.
   * @param {Client}client
   * @param {RegistryResource}resource
   * @param {number}name unique numeric name of the object
   * @param {string}interface_
   * @param {number}version
   * @param {number}id bounded object
   */
  bind (client, resource, name, interface_, version, id) {}
}

module.exports = RegistryRequests


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



class Global {
  /**
   * Use Registry.createGlobal(..) instead.
   * @param {Registry}registry
   * @param {Object}implementation
   * @param {string} interface_
   * @param {number} version
   * @param {number}name
   * @param {function(Client,number,number):void}bindCallback
   */
  constructor (registry, implementation, interface_, version, name, bindCallback) {
    /**
     * @type {Registry}
     */
    this.registry = registry
    /**
     * @type {Object}
     */
    this.implementation = implementation
    /**
     * @type {function(Client, number, number): void}
     * @private
     */
    this._bindCallback = bindCallback
    /**
     * @type {string}
     */
    this.interface_ = interface_
    /**
     * @type {number}
     */
    this.version = version
    /**
     * @type {number}
     */
    this.name = name
  }

  /**
   *
   * Invoked when a client binds to this global. Subclasses implement this method so they can instantiate a
   * corresponding Resource subtype.
   *
   * @param {Client} client
   * @param {number} id
   * @param {number} version
   */
  bindClient (client, id, version) {
    this._bindCallback(client, id, version)
  }

  destroy () {
    if (this.registry) {
      this.registry.destroyGlobal(this)
      this.registry = null
    }
  }
}

module.exports = Global

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClientSession; });


class ClientSession {
  /**
   * @param {!Client}clientConnection
   * @return {ClientSession}
   */
  static create (clientConnection) {
    return new ClientSession(clientConnection)
  }

  /**
   * @param {!Client}clientConnection
   */
  constructor (clientConnection) {
    /**
     * @type {!Client}
     * @const
     * @private
     */
    this._clientConnection = clientConnection
  }

  /**
   * @param {GrClientSessionResource}resource
   */
  destroy (resource) {
    this._clientConnection.close()
    resource.destroy()
  }
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Compositor; });
/* harmony import */ var _protocol_WlCompositorRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var _protocol_WlCompositorRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlCompositorRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlCompositorResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _protocol_WlCompositorResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlCompositorResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_WlRegionResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _protocol_WlRegionResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlRegionResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36);











/**
 *
 *            A compositor.  This object is a singleton global.  The
 *            compositor is in charge of combining the contents of multiple
 *            surfaces into one displayable output.
 * @implements WlCompositorRequests
 */
class Compositor extends _protocol_WlCompositorRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {!Session} session
   * @param {!Seat} seat
   * @returns {!Compositor}
   */
  static create (session, seat) {
    const glCanvasRenderer = _render_Renderer__WEBPACK_IMPORTED_MODULE_6__["default"].create()
    return new Compositor(session, glCanvasRenderer, seat)
  }

  /**
   * Use Compositor.create(server) instead.
   * @param {!Session} session
   * @param {!Renderer} renderer
   * @param {!Seat} seat
   * @private
   */
  constructor (session, renderer, seat) {
    super()
    /**
     * @type {!Session}
     * @const
     * @private
     */
    this._session = session
    /**
     * @type {!Renderer}
     * @const
     * @private
     */
    this._renderer = renderer
    /**
     * @type {!Seat}
     * @const
     * @private
     */
    this._seat = seat
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlCompositorResource__WEBPACK_IMPORTED_MODULE_1___default.a.name, 4, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const wlCompositorResource = new _protocol_WlCompositorResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    wlCompositorResource.implementation = this
  }

  /**
   *
   * Ask the compositor to create a new surface.
   *
   *
   * @param {!WlCompositorResource} resource
   * @param {!number} id
   *
   * @since 1
   * @override
   */
  createSurface (resource, id) {
    const wlSurfaceResource = new _protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    _Surface__WEBPACK_IMPORTED_MODULE_4__["default"].create(wlSurfaceResource, this._renderer, this._seat, this._session)
  }

  /**
   *
   * Ask the compositor to create a new region.
   *
   *
   * @param {!WlCompositorResource} resource
   * @param {!number} id
   *
   * @since 1
   *
   */
  createRegion (resource, id) {
    const wlRegionResource = new _protocol_WlRegionResource__WEBPACK_IMPORTED_MODULE_3___default.a(resource.client, id, resource.version)
    _Region__WEBPACK_IMPORTED_MODULE_5__["default"].create(wlRegionResource)
  }
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlCompositorRequests {

	/**
	 *
	 *	Ask the compositor to create a new surface.
	 *      
	 *
	 * @param {WlCompositorResource} resource 
	 * @param {number} id the new surface 
	 *
	 * @since 1
	 *
	 */
	createSurface(resource, id) {}

	/**
	 *
	 *	Ask the compositor to create a new region.
	 *      
	 *
	 * @param {WlCompositorResource} resource 
	 * @param {number} id the new region 
	 *
	 * @since 1
	 *
	 */
	createRegion(resource, id) {}
}

module.exports = WlCompositorRequests


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A compositor.  This object is a singleton global.  The
 *      compositor is in charge of combining the contents of multiple
 *      surfaces into one displayable output.
 *    
 */
class WlCompositorResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlCompositorRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.createSurface(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.createRegion(this, ...args)
	}
}
WlCompositorResource.protocolName = 'wl_compositor'

module.exports = WlCompositorResource


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A surface is a rectangular area that is displayed on the screen.
 *      It has a location, size and pixel contents.
 *
 *      The size of a surface (and relative positions on it) is described
 *      in surface-local coordinates, which may differ from the buffer
 *      coordinates of the pixel content, in case a buffer_transform
 *      or a buffer_scale is used.
 *
 *      A surface without a "role" is fairly useless: a compositor does
 *      not know where, when or how to present it. The role is the
 *      purpose of a wl_surface. Examples of roles are a cursor for a
 *      pointer (as set by wl_pointer.set_cursor), a drag icon
 *      (wl_data_device.start_drag), a sub-surface
 *      (wl_subcompositor.get_subsurface), and a window as defined by a
 *      shell protocol (e.g. wl_shell.get_shell_surface).
 *
 *      A surface can have only one role at a time. Initially a
 *      wl_surface does not have a role. Once a wl_surface is given a
 *      role, it is set permanently for the whole lifetime of the
 *      wl_surface object. Giving the current role again is allowed,
 *      unless explicitly forbidden by the relevant interface
 *      specification.
 *
 *      Surface roles are given by requests in other interfaces such as
 *      wl_pointer.set_cursor. The request should explicitly mention
 *      that this request gives a role to a wl_surface. Often, this
 *      request also creates a new protocol object that represents the
 *      role and adds additional functionality to wl_surface. When a
 *      client wants to destroy a wl_surface, they must destroy this 'role
 *      object' before the wl_surface.
 *
 *      Destroying the role object does not remove the role from the
 *      wl_surface, but it may stop the wl_surface from "playing the role".
 *      For instance, if a wl_subsurface object is destroyed, the wl_surface
 *      it was created for will be unmapped and forget its position and
 *      z-order. It is allowed to create a wl_subsurface for the same
 *      wl_surface again, but it is not allowed to use the wl_surface as
 *      a cursor (cursor is a different role than sub-surface, and role
 *      switching is not allowed).
 *    
 */
class WlSurfaceResource extends Resource {

	/**
	 *
	 *	This is emitted whenever a surface's creation, movement, or resizing
	 *	results in some part of it being within the scanout region of an
	 *	output.
	 *
	 *	Note that a surface may be overlapping with zero or more outputs.
	 *      
	 *
	 * @param {*} output output entered by the surface 
	 *
	 * @since 1
	 *
	 */
	enter (output) {
		this.client.marshall(this.id, 0, [object(output)])
	}

	/**
	 *
	 *	This is emitted whenever a surface's creation, movement, or resizing
	 *	results in it no longer having any part of it within the scanout region
	 *	of an output.
	 *      
	 *
	 * @param {*} output output left by the surface 
	 *
	 * @since 1
	 *
	 */
	leave (output) {
		this.client.marshall(this.id, 1, [object(output)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlSurfaceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'?oii')
		await this.implementation.attach(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.damage(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.frame(this, ...args)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'?o')
		await this.implementation.setOpaqueRegion(this, ...args)
	}
	async [5] (message) {
		const args = this.client._unmarshallArgs(message,'?o')
		await this.implementation.setInputRegion(this, ...args)
	}
	async [6] (message) {
		await this.implementation.commit(this)
	}
	async [7] (message) {
		const args = this.client._unmarshallArgs(message,'i')
		await this.implementation.setBufferTransform(this, ...args)
	}
	async [8] (message) {
		const args = this.client._unmarshallArgs(message,'i')
		await this.implementation.setBufferScale(this, ...args)
	}
	async [9] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.damageBuffer(this, ...args)
	}
}
WlSurfaceResource.protocolName = 'wl_surface'

WlSurfaceResource.Error = {
  /**
   * buffer scale value is invalid
   */
  invalidScale: 0,
  /**
   * buffer transform value is invalid
   */
  invalidTransform: 1
}

module.exports = WlSurfaceResource


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A region object describes an area.
 *
 *      Region objects are used to describe the opaque and input
 *      regions of a surface.
 *    
 */
class WlRegionResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlRegionRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.add(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.subtract(this, ...args)
	}
}
WlRegionResource.protocolName = 'wl_region'

module.exports = WlRegionResource


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Surface; });
/* harmony import */ var _protocol_WlSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _protocol_WlSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlCallbackResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _protocol_WlCallbackResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlCallbackResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _Callback__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var _math_Mat4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(27);
/* harmony import */ var _math_Transformations__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(52);
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(31);
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(33);
/* harmony import */ var _SurfaceChild__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(53);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36);
/* harmony import */ var _RtcBufferFactory__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(54);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(29);


















/**
 * @type {{transformation: Mat4, inverseTransformation:Mat4}[]}
 */
const bufferTransformations = [
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["NORMAL"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["NORMAL"].invert()}, // 0
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_90"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_90"].invert()}, // 1
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_180"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_180"].invert()}, // 2
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_270"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["_270"].invert()}, // 3
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED"].invert()}, // 4
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_90"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_90"].invert()}, // 5
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_180"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_180"].invert()}, // 6
  {transformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_270"], inverseTransformation: _math_Transformations__WEBPACK_IMPORTED_MODULE_8__["FLIPPED_270"].invert()} // 7
]

/**
 *
 *            A surface is a rectangular area that is displayed on the screen.
 *            It has a location, size and pixel contents.
 *
 *            The size of a surface (and relative positions on it) is described
 *            in surface-local coordinates, which may differ from the buffer
 *            coordinates of the pixel content, in case a buffer_transform
 *            or a buffer_scale is used.
 *
 *            A surface without a "role" is fairly useless: a compositor does
 *            not know where, when or how to present it. The role is the
 *            purpose of a wl_surface. Examples of roles are a cursor for a
 *            pointer (as set by wl_pointer.set_cursor), a drag icon
 *            (wl_data_device.start_drag), a sub-surface
 *            (wl_subcompositor.get_subsurface), and a window as defined by a
 *            shell protocol (e.g. wl_shell.get_shell_surface).
 *
 *            A surface can have only one role at a time. Initially a
 *            wl_surface does not have a role. Once a wl_surface is given a
 *            role, it is set permanently for the whole lifetime of the
 *            wl_surface object. Giving the current role again is allowed,
 *            unless explicitly forbidden by the relevant interface
 *            specification.
 *
 *            Surface roles are given by requests in other interfaces such as
 *            wl_pointer.set_cursor. The request should explicitly mention
 *            that this request gives a role to a wl_surface. Often, this
 *            request also creates a new protocol object that represents the
 *            role and adds additional functionality to wl_surface. When a
 *            client wants to destroy a wl_surface, they must destroy this 'role
 *            object' before the wl_surface.
 *
 *            Destroying the role object does not remove the role from the
 *            wl_surface, but it may stop the wl_surface from "playing the role".
 *            For instance, if a wl_subsurface object is destroyed, the wl_surface
 *            it was created for will be unmapped and forget its position and
 *            z-order. It is allowed to create a wl_subsurface for the same
 *            wl_surface again, but it is not allowed to use the wl_surface as
 *            a cursor (cursor is a different role than sub-surface, and role
 *            switching is not allowed).
 * @implements WlSurfaceRequests
 */
class Surface extends _protocol_WlSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {!WlSurfaceResource} wlSurfaceResource
   * @param {!Renderer} renderer
   * @param {!Seat} seat
   * @param {!Session} session
   * @returns {!Surface}
   */
  static create (wlSurfaceResource, renderer, seat, session) {
    const bufferDamage = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()
    const opaquePixmanRegion = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()
    const inputPixmanRegion = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()
    const surfacePixmanRegion = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()

    _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initInfinite(bufferDamage)
    _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initInfinite(opaquePixmanRegion)
    _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initInfinite(inputPixmanRegion)

    const surface = new Surface(wlSurfaceResource, renderer, seat, session, bufferDamage, opaquePixmanRegion, inputPixmanRegion, surfacePixmanRegion)
    wlSurfaceResource.implementation = surface
    wlSurfaceResource.onDestroy().then(() => {
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(bufferDamage)
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(opaquePixmanRegion)
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(inputPixmanRegion)
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(surfacePixmanRegion)
      surface._handleDestruction()
    })

    return surface
  }

  /**
   * Use Surface.create(wlSurfaceResource) instead.
   * @private
   * @param {!WlSurfaceResource} wlSurfaceResource
   * @param {!Renderer} renderer
   * @param {!Seat} seat
   * @param {!Session} session
   * @param {!number} bufferDamage
   * @param {!number} opaquePixmanRegion
   * @param {!number} inputPixmanRegion
   * @param {!number} surfacePixmanRegion
   */
  constructor (wlSurfaceResource, renderer, seat, session, bufferDamage, opaquePixmanRegion, inputPixmanRegion, surfacePixmanRegion) {
    super()
    /**
     * @type {!WlSurfaceResource}
     * @const
     */
    this.resource = wlSurfaceResource
    /**
     * @type {boolean}
     */
    this.destroyed = false
    /**
     * @type {!Renderer}
     * @const
     */
    this.renderer = renderer
    /**
     * @type {?RenderState}
     */
    this.renderState = null
    /**
     * @type {!{bufferContents: {type: string, syncSerial: number, geo: Size, yuvContent: Uint8Array, yuvWidth: number, yuvHeight: number, alphaYuvContent: Uint8Array, alphaYuvWidth: number, alphaYuvHeight: number, pngImage: HTMLImageElement}|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Callback[], roleState: *}}
     */
    this.state = {
      /**
       * @type {{type: string, syncSerial: number, geo: Size, yuvContent: Uint8Array, yuvWidth: number, yuvHeight: number, alphaYuvContent: Uint8Array, alphaYuvWidth: number, alphaYuvHeight: number, pngImage: HTMLImageElement}|null}
       */
      bufferContents: null,
      /**
       * @type {Array<Rect>}
       */
      bufferDamageRects: [],
      /**
       * @type{number}
       */
      opaquePixmanRegion: opaquePixmanRegion,
      /**
       * @type{number}
       */
      inputPixmanRegion: inputPixmanRegion,
      /**
       * @type{number}
       */
      dx: 0,
      /**
       * @type{number}
       */
      dy: 0,
      /**
       * @type{number}
       */
      bufferTransform: 0,
      /**
       * @type{number}
       */
      bufferScale: 1,
      /**
       * @type {Callback[]}
       */
      frameCallbacks: [],
      /**
       * @type {*}
       */
      roleState: {}
    }
    /**
     * @type {?WlBufferResource}
     */
    this.pendingWlBuffer = null
    /**
     * @type {!function}
     */
    this.pendingBufferDestroyListener = () => {
      this.pendingWlBuffer = null
    }
    /**
     * @type {!Array<Rect>}
     * @private
     */
    this._pendingDamageRects = []
    /**
     * @type {!Array<Rect>}
     * @private
     */
    this._pendingBufferDamageRects = []
    /**
     * @type {!number}
     * @private
     */
    this._pendingOpaqueRegion = 0
    /**
     * @type {!number}
     * @private
     */
    this._pendingInputRegion = 0
    /**
     * @type {!number}
     * @private
     */
    this._pendingDx = 0
    /**
     * @type {!number}
     * @private
     */
    this._pendingDy = 0
    /**
     * @type {!number}
     * @private
     */
    this._pendingBufferTransform = 0
    /**
     * @type {!number}
     * @private
     */
    this._pendingBufferScale = 1
    /**
     * @type {!Array<View>}
     */
    this.views = []
    /**
     * @type {!Seat}
     * @const
     */
    this.seat = seat
    /**
     * @type {!Session}
     * @const
     */
    this.session = session
    /**
     * @type {!boolean}
     */
    this.hasKeyboardInput = true
    /**
     * @type {!boolean}
     */
    this.hasPointerInput = true
    /**
     * @type {!boolean}
     */
    this.hasTouchInput = true
    /**
     * @type {?SurfaceRole}
     */
    this.role = null
    /**
     * @type {!SurfaceChild}
     * @const
     */
    this.surfaceChildSelf = _SurfaceChild__WEBPACK_IMPORTED_MODULE_11__["default"].create(this)
    /**
     * All child surfaces + this surface. This allows for child surfaces to be displayed
     * below it's parent, as the order of this list determines the zOrder between parent & children.
     * @type {!Array<SurfaceChild>}
     */
    this._surfaceChildren = []
    /**
     * @type {!Array<SurfaceChild>}
     */
    this.subsurfaceChildren = [this.surfaceChildSelf]
    /**
     * @type {!Array<SurfaceChild>}
     */
    this.pendingSubsurfaceChildren = [this.surfaceChildSelf]
    /**
     * @type {!Array<Callback>}
     * @private
     */
    this._pendingFrameCallbacks = []

    // derived states below ->
    /**
     * buffer2surface
     * @type {!Mat4}
     */
    this.inverseBufferTransformation = _math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].IDENTITY()
    /**
     * surface2buffer
     * @type {!Mat4}
     */
    this.bufferTransformation = _math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].IDENTITY()
    /**
     * A pixman region in surface coordinates, representing the entire surface.
     * @type {!number}
     */
    this.pixmanRegion = surfacePixmanRegion
    /**
     * @type {!Size}
     */
    this.size = _Size__WEBPACK_IMPORTED_MODULE_9__["default"].create(0, 0)
    // <- derived states above

    this._count = 0
    this._total = 0
    this._start = 0
    this._bufferCompletionTotal = 0
    this._postRenderTotal = 0
    this._bufferSizeTotal = 0
  }

  /**
   * @return {Array<SurfaceChild>}
   */
  get children () {
    return this.subsurfaceChildren.concat(this._surfaceChildren)
  }

  /**
   * @param {Point}surfacePoint
   * @return boolean
   */
  isWithinInputRegion (surfacePoint) {
    const withinInput = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].contains(this.state.inputPixmanRegion, surfacePoint)
    const withinSurface = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].contains(this.pixmanRegion, surfacePoint)
    return withinSurface && withinInput
  }

  /**
   * @param {number}newBufferTransform
   * @param {Mat4}bufferTransformation
   * @private
   */
  _applyBufferTransformWithPositionCorrection (newBufferTransform, bufferTransformation) {
    switch (newBufferTransform) {
      case 3: // 270
      case 4: { // flipped
        this.bufferTransformation = bufferTransformation.timesMat4(_math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].translation(this.size.w, 0).invert())
        this.inverseBufferTransformation = this.bufferTransformation.invert()
        break
      }
      case 2: // 180
      case 5: { // 90 flipped
        this.bufferTransformation = bufferTransformation.timesMat4(_math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].translation(this.size.w, this.size.h).invert())
        this.inverseBufferTransformation = this.bufferTransformation.invert()
        break
      }
      case 1: // 90
      case 6: { // 180 flipped
        this.bufferTransformation = bufferTransformation.timesMat4(_math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].translation(0, this.size.h).invert())
        this.inverseBufferTransformation = this.bufferTransformation.invert()
        break
      }
      case 0: // normal
      case 7: { // 270 flipped
        this.bufferTransformation = bufferTransformation.timesMat4(_math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].translation(0, 0))
        this.inverseBufferTransformation = this.bufferTransformation.invert()
        break
      }
    }
  }

  /**
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _updateDerivedState (newState) {
    const oldBufferSize = this.state.bufferContents ? this.state.bufferContents.size : _Size__WEBPACK_IMPORTED_MODULE_9__["default"].create(0, 0)
    const newBufferSize = newState.bufferContents ? newState.bufferContents.size : _Size__WEBPACK_IMPORTED_MODULE_9__["default"].create(0, 0)

    if (newState.bufferScale !== this.state.bufferScale ||
      newState.bufferTransform !== this.state.bufferTransform ||
      oldBufferSize.w !== newBufferSize.w ||
      oldBufferSize.h !== newBufferSize.h) {
      const transformations = bufferTransformations[newState.bufferTransform]
      const bufferTransformation = newState.bufferScale === 1 ? transformations.transformation : transformations.transformation.timesMat4(_math_Mat4__WEBPACK_IMPORTED_MODULE_7__["default"].scalar(newState.bufferScale))
      const inverseBufferTransformation = newState.bufferScale === 1 ? transformations.inverseTransformation : bufferTransformation.invert()

      const surfacePoint = inverseBufferTransformation.timesPoint(_math_Point__WEBPACK_IMPORTED_MODULE_14__["default"].create(newBufferSize.w, newBufferSize.h))
      this.size = _Size__WEBPACK_IMPORTED_MODULE_9__["default"].create(Math.abs(surfacePoint.x), Math.abs(surfacePoint.y))
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].fini(this.pixmanRegion)
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initRect(this.pixmanRegion, _math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(0, 0, this.size.w, this.size.h))

      this._applyBufferTransformWithPositionCorrection(newState.bufferTransform, bufferTransformation)
    }
  }

  updateChildViewsZIndexes () {
    let parentPosition = this.children.indexOf(this.surfaceChildSelf)
    this.views.forEach(view => {
      const parentViewZIndex = view.zIndex
      // Children can be displayed below their parent, therefor we have to subtract the parent position from it's zIndex
      // to get the starting zIndexOffset
      const zIndexOffset = parentViewZIndex - parentPosition
      this._updateZIndex(view, zIndexOffset)
    })
  }

  /**
   * @param {View}parentView
   * @param {number}zIndexOffset
   * @return {number}
   * @private
   */
  _updateZIndex (parentView, zIndexOffset) {
    let newZIndex = 0
    let newZIndexOffset = zIndexOffset
    this.children.forEach((surfaceChild, index) => {
      newZIndex = newZIndexOffset + index
      if (surfaceChild.surface === this) {
        parentView.zIndex = newZIndex
      } else {
        const childView = surfaceChild.surface.views.find(view => {
          return view.parent === parentView
        })
        if (childView) {
          newZIndexOffset = surfaceChild.surface._updateZIndex(childView, newZIndex)
        }
      }
    })
    return newZIndex
  }

  /**
   * @param {View}view
   */
  onViewCreated (view) {}

  /**
   * @return {View}
   */
  createView () {
    const bufferSize = this.state.bufferContents ? this.state.bufferContents.size : _Size__WEBPACK_IMPORTED_MODULE_9__["default"].create(0, 0)
    const view = _View__WEBPACK_IMPORTED_MODULE_4__["default"].create(this, bufferSize.w, bufferSize.h)
    if (this.views.length === 0) {
      view.primary = true
    }
    this.views.push(view)

    view.onDestroy().then(() => {
      const idx = this.views.indexOf(view)
      if (idx > -1) {
        this.views.splice(idx, 1)
      }
    })

    this.children.forEach(surfaceChild => {
      this._ensureChildView(surfaceChild, view)
    })

    this.updateChildViewsZIndexes()
    this.onViewCreated(view)

    return view
  }

  /**
   * @param {SurfaceChild}surfaceChild
   * @param {View}view
   * @return {View|null}
   * @private
   */
  _ensureChildView (surfaceChild, view) {
    if (surfaceChild.surface === this) {
      return null
    }

    const childView = surfaceChild.surface.createView()
    const zIndexOrder = this.children.indexOf(surfaceChild)
    childView.zIndex = view.zIndex + zIndexOrder
    childView.parent = view

    return childView
  }

  /**
   * Returns all newly created child views
   * @param {SurfaceChild}surfaceChild
   * @return {Array<View>}
   */
  addSubsurface (surfaceChild) {
    const childViews = this._addChild(surfaceChild, this.subsurfaceChildren)
    this.pendingSubsurfaceChildren.push(surfaceChild)

    surfaceChild.surface.resource.onDestroy().then(() => {
      this.removeSubsurface(surfaceChild)
    })

    return childViews
  }

  /**
   * @param {SurfaceChild}surfaceChild
   */
  removeSubsurface (surfaceChild) {
    this._removeChild(surfaceChild, this.subsurfaceChildren)
    this._removeChild(surfaceChild, this.pendingSubsurfaceChildren)
  }

  /**
   * Returns all newly created child views
   * @param {SurfaceChild}surfaceChild
   * @return {Array<View>}
   */
  addChild (surfaceChild) {
    return this._addChild(surfaceChild, this._surfaceChildren)
  }

  /**
   * @param {SurfaceChild}surfaceChild
   */
  addToplevelChild (surfaceChild) {
    this._surfaceChildren.push(surfaceChild)

    const primaryChildView = surfaceChild.surface.views.find((view) => view.primary)
    const primaryView = this.views.find((view) => view.primary)

    const zIndexOrder = this.children.indexOf(surfaceChild)
    primaryChildView.zIndex = primaryView.zIndex + zIndexOrder
    primaryChildView.parent = primaryView

    surfaceChild.surface.resource.onDestroy().then(() => {
      this.removeChild(surfaceChild)
    })
    this.updateChildViewsZIndexes()
  }

  /**
   * @param {SurfaceChild}surfaceChild
   */
  removeChild (surfaceChild) {
    this._removeChild(surfaceChild, this._surfaceChildren)
  }

  /**
   * @param {SurfaceChild}surfaceChild
   * @param {SurfaceChild[]}siblings
   * @return {Array<View>}
   * @private
   */
  _addChild (surfaceChild, siblings) {
    siblings.push(surfaceChild)

    const childViews = []
    this.views.forEach((view) => {
      const childView = this._ensureChildView(surfaceChild, view)
      if (childView) {
        childViews.push(childView)
      }
    })
    surfaceChild.surface.resource.onDestroy().then(() => {
      this.removeChild(surfaceChild)
    })
    this.updateChildViewsZIndexes()
    return childViews
  }

  /**
   * @param {SurfaceChild}surfaceChild
   * @param {SurfaceChild[]}siblings
   * @private
   */
  _removeChild (surfaceChild, siblings) {
    const index = siblings.indexOf(surfaceChild)
    if (index > -1) {
      siblings.splice(index, 1)
      this.updateChildViewsZIndexes()
    }
  }

  /**
   *
   * Deletes the surface and invalidates its object ID.
   *
   *
   * @param {WlSurfaceResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    // this._handleDestruction()
    this.destroyed = true
    resource.destroy()
    if (this.renderState) {
      this.renderState.destroy()
      this.renderState = null
    }
  }

  /**
   * @private
   */
  _handleDestruction () {
    this.views.forEach(view => {
      delete view.surface
      view.destroy()
    })
  }

  /**
   *
   *                Set a buffer as the content of this surface.
   *
   *                The new size of the surface is calculated based on the buffer
   *                size transformed by the inverse bufferTransform and the
   *                inverse bufferScale. This means that the supplied buffer
   *                must be an integer multiple of the bufferScale.
   *
   *                The x and y arguments specify the location of the new pending
   *                buffer's upper left corner, relative to the current buffer's upper
   *                left corner, in surface local coordinates. In other words, the
   *                x and y, combined with the new surface size define in which
   *                directions the surface's size changes.
   *
   *                Surface contents are double-buffered state, see WlSurface.commit.
   *
   *                The initial surface contents are void; there is no content.
   *                WlSurface.attach assigns the given WlBuffer as the pending
   *                WlBuffer. WlSurface.commit makes the pending WlBuffer the new
   *                surface contents, and the size of the surface becomes the size
   *                calculated from the WlBuffer, as described above. After commit,
   *                there is no pending buffer until the next attach.
   *
   *                Committing a pending WlBuffer allows the compositor to read the
   *                pixels in the WlBuffer. The compositor may access the pixels at
   *                any time after the WlSurface.commit request. It may take some
   *                time for the contents to arrive at the compositor if they have
   *                not been transferred already. The compositor will continue using
   *                old surface content and state until the new content has arrived.
   *                See also WlBuffer.complete.
   *
   *                If it is possible to re-use a WlBuffer or update its
   *                contents, the respective buffer factory shall define how that
   *                works.
   *
   *                Destroying the WlBuffer after WlBuffer.complete does not change
   *                the surface contents. However, if the client destroys the
   *                WlBuffer before receiving the WlBuffer.complete event, the surface
   *                contents become undefined immediately.
   *
   *                If WlSurface.attach is sent with a NULL WlBuffer, the
   *                following WlSurface.commit will remove the surface content.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {WlBufferResource|null} buffer undefined
   * @param {number} x undefined
   * @param {number} y undefined
   *
   * @since 1
   * @override
   */
  attach (resource, buffer, x, y) {
    this._pendingDx = x
    this._pendingDy = y

    if (this.pendingWlBuffer) {
      this.pendingWlBuffer.removeDestroyListener(this.pendingBufferDestroyListener)
    }

    this.pendingWlBuffer = buffer
    // buffer can be null
    if (this.pendingWlBuffer) {
      this.pendingWlBuffer.addDestroyListener(this.pendingBufferDestroyListener)
    }
  }

  /**
   *
   *                This request is used to describe the regions where the pending
   *                buffer is different from the current surface contents, and where
   *                the surface therefore needs to be repainted. The compositor
   *                ignores the parts of the damage that fall outside of the surface.
   *
   *                Damage is double-buffered state, see WlSurface.commit.
   *
   *                The damage rectangle is specified in surface local coordinates.
   *
   *                The initial value for pending damage is empty: no damage.
   *                WlSurface.damage adds pending damage: the new pending damage
   *                is the union of old pending damage and the given rectangle.
   *
   *                WlSurface.commit assigns pending damage as the current damage,
   *                and clears pending damage. The server will clear the current
   *                damage as it repaints the surface.
   *
   *                Alternatively, damage can be posted with WlSurface.damageBuffer
   *                which uses buffer co-ordinates instead of surface co-ordinates,
   *                and is probably the preferred and intuitive way of doing this.
   *
   *                The factory behind the the WlBuffer might imply full surface
   *                damage, overriding this request. This is common when the factory
   *                uses a video encoder, where regions outside the original changes
   *                may improve in quality.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {number} x undefined
   * @param {number} y undefined
   * @param {number} width undefined
   * @param {number} height undefined
   *
   * @since 1
   * @override
   */
  damage (resource, x, y, width, height) {
    this._pendingDamageRects.push(_math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(x, y, x + width, y + height))
  }

  /**
   *
   *                Request a notification when it is a good time start drawing a new
   *                frame, by creating a frame callback. This is useful for throttling
   *                redrawing operations, and driving animations.
   *
   *                When a client is animating on a WlSurface, it can use the 'frame'
   *                request to get notified when it is a good time to draw and commit the
   *                next frame of animation. If the client commits an update earlier than
   *                that, it is likely that some updates will not make it to the display,
   *                and the client is wasting resources by drawing too often.
   *
   *                The frame request will take effect on the next WlSurface.commit.
   *                The notification will only be posted for one frame unless
   *                requested again. For a WlSurface, the notifications are posted in
   *                the order the frame requests were committed.
   *
   *                The server must send the notifications so that a client
   *                will not send excessive updates, while still allowing
   *                the highest possible update rate for clients that wait for the reply
   *                before drawing again. The server should give some time for the client
   *                to draw and commit after sending the frame callback events to let them
   *                hit the next output refresh.
   *
   *                A server should avoid signalling the frame callbacks if the
   *                surface is not visible in any way, e.g. the surface is off-screen,
   *                or completely obscured by other opaque surfaces.
   *
   *                The object returned by this request will be destroyed by the
   *                compositor after the callback is fired and as such the client must not
   *                attempt to use it after that point.
   *
   *                The callbackData passed in the callback is the current time, in
   *                milliseconds, with an undefined base.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {number} callback id
   *
   *
   * @since 1
   * @override
   */
  frame (resource, callback) {
    this._pendingFrameCallbacks.push(_Callback__WEBPACK_IMPORTED_MODULE_5__["default"].create(new _protocol_WlCallbackResource__WEBPACK_IMPORTED_MODULE_1___default.a(resource.client, callback, 1)))
  }

  /**
   *
   *                This request sets the region of the surface that contains
   *                opaque content.
   *
   *                The opaque region is an optimization hint for the compositor
   *                that lets it optimize out redrawing of content behind opaque
   *                regions.  Setting an opaque region is not required for correct
   *                behaviour, but marking transparent content as opaque will result
   *                in repaint artifacts.
   *
   *                The opaque region is specified in surface local coordinates.
   *
   *                The compositor ignores the parts of the opaque region that fall
   *                outside of the surface.
   *
   *                Opaque region is double-buffered state, see WlSurface.commit.
   *
   *                WlSurface.setOpaqueRegion changes the pending opaque region.
   *                WlSurface.commit copies the pending region to the current region.
   *                Otherwise, the pending and current regions are never changed.
   *
   *                The initial value for opaque region is empty. Setting the pending
   *                opaque region has copy semantics, and the WlRegion object can be
   *                destroyed immediately. A NULL WlRegion causes the pending opaque
   *                region to be set to empty.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {WlRegionResource|null} regionResource undefined
   *
   * @since 1
   * @override
   */
  setOpaqueRegion (resource, regionResource) {
    this._pendingOpaqueRegion = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()
    if (regionResource) {
      const region = /** @type Region */ regionResource.implementation
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].copyTo(this._pendingOpaqueRegion, region.pixmanRegion)
    } else {
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initInfinite(this._pendingOpaqueRegion)
    }
    // this._opaqueRegionChanged = true
  }

  /**
   *
   *                This request sets the region of the surface that can receive
   *                pointer and touch events.
   *
   *                Input events happening outside of this region will try the next
   *                surface in the server surface stack. The compositor ignores the
   *                parts of the input region that fall outside of the surface.
   *
   *                The input region is specified in surface local coordinates.
   *
   *                Input region is double-buffered state, see WlSurface.commit.
   *
   *                WlSurface.setInputRegion changes the pending input region.
   *                WlSurface.commit copies the pending region to the current region.
   *                Otherwise the pending and current regions are never changed,
   *                except cursor and icon surfaces are special cases, see
   *                WlPointer.setCursor and WlDataDevice.startDrag.
   *
   *                The initial value for input region is infinite. That means the
   *                whole surface will accept input. Setting the pending input region
   *                has copy semantics, and the WlRegion object can be destroyed
   *                immediately. A NULL WlRegion causes the input region to be set
   *                to infinite.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {WlRegionResource|null} regionResource undefined
   *
   * @since 1
   * @override
   */
  setInputRegion (resource, regionResource) {
    this._pendingInputRegion = _Region__WEBPACK_IMPORTED_MODULE_10__["default"].createPixmanRegion()
    if (regionResource) {
      const region = /** @type Region */(regionResource.implementation)
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].copyTo(this._pendingInputRegion, region.pixmanRegion)
    } else {
      // 'infinite' region
      _Region__WEBPACK_IMPORTED_MODULE_10__["default"].initInfinite(this._pendingInputRegion)
    }
  }

  /**
   * @param {Point}bufferPoint
   * @return {Point}
   */
  toSurfaceSpace (bufferPoint) {
    return this.inverseBufferTransformation.timesPoint(bufferPoint)
  }

  /**
   *
   *                Surface state (input, opaque, and damage regions, attached buffers,
   *                etc.) is double-buffered. Protocol requests modify the pending
   *                state, as opposed to current state in use by the compositor. Commit
   *                request atomically applies all pending state, replacing the current
   *                state. After commit, the new pending state is as documented for each
   *                related request.
   *
   *                On commit, a pending WlBuffer is applied first, all other state
   *                second. This means that all coordinates in double-buffered state are
   *                relative to the new WlBuffer coming into use, except for
   *                WlSurface.attach itself. If there is no pending WlBuffer, the
   *                coordinates are relative to the current surface contents.
   *
   *                All requests that need a commit to become effective are documented
   *                to affect double-buffered state.
   *
   *                Other interfaces may add further double-buffered surface state.
   *
   *
   * @param {WlSurfaceResource} resource
   *
   * @since 1
   * @override
   */
  async commit (resource) {
    this._start = Date.now()
    this._count++
    if (this.pendingWlBuffer) {
      this.pendingWlBuffer.removeDestroyListener(this.pendingBufferDestroyListener)
    }

    const pendingWlBuffer = this.pendingWlBuffer
    const newState = await this._captureState(pendingWlBuffer)
    if (this.destroyed) {
      return
    }

    if (this.role && typeof this.role.onCommit === 'function') {
      const animationFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_12__["default"].createRenderFrame()
      await this.role.onCommit(this, animationFrame, newState)
      if (newState.inputPixmanRegion) {
        _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(newState.inputPixmanRegion)
      }
      if (newState.opaquePixmanRegion) {
        _Region__WEBPACK_IMPORTED_MODULE_10__["default"].destroyPixmanRegion(newState.opaquePixmanRegion)
      }
    }
  }

  /**
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @param {boolean=}skipDraw
   */
  async render (renderFrame, newState, skipDraw) {
    if (skipDraw == null) {
      skipDraw = false
    }

    renderFrame.then((timestamp) => {
      this.state.frameCallbacks.forEach((frameCallback) => {
        frameCallback.done(timestamp & 0x7fffffff)
      })
      this.state.frameCallbacks = []
    })

    if (this.subsurfaceChildren.length > 1) {
      this.subsurfaceChildren = this.pendingSubsurfaceChildren.slice()
      this.updateChildViewsZIndexes()

      this.subsurfaceChildren.forEach((surfaceChild) => {
        const siblingSurface = surfaceChild.surface
        if (siblingSurface !== this) {
          const siblingSubsurface = /** @type Subsurface */ siblingSurface.role
          // cascade scene update to subsurface children
          if (siblingSubsurface.pendingPosition) {
            surfaceChild.position = siblingSubsurface.pendingPosition
            siblingSubsurface.pendingPosition = null
          }
          siblingSubsurface.onParentCommit(this, renderFrame)
        }
      })
    }

    if (!skipDraw) {
      await this.renderer.render(this, newState)
    }
    const postRenderStart = Date.now()

    const {w: oldWidth, h: oldHeight} = this.size
    this._updateDerivedState(newState)
    Surface.mergeState(this.state, newState)
    if (this.role && this.role.setRoleState) {
      this.role.setRoleState(newState.roleState)
    }

    if (newState.inputPixmanRegion || oldWidth !== this.size.w || oldHeight !== this.size.h) {
      this.views.forEach(view => {
        view.updateInputRegion()
      })
    }

    this.views.forEach(view => {
      view.swapBuffers(renderFrame)
    })

    const now = Date.now()
    this._postRenderTotal += (now - postRenderStart)
    this._total += (now - this._start)
    false && console.log('post-render avg', this._postRenderTotal / this._count)
    false && console.log('---> commit avg', this._total / this._count)
  }

  /**
   * This will invalidate the source state.
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}targetState
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}sourceState
   */
  static mergeState (targetState, sourceState) {
    targetState.dx = sourceState.dx
    targetState.dy = sourceState.dy

    _Region__WEBPACK_IMPORTED_MODULE_10__["default"].copyTo(targetState.inputPixmanRegion, sourceState.inputPixmanRegion)
    _Region__WEBPACK_IMPORTED_MODULE_10__["default"].copyTo(targetState.opaquePixmanRegion, sourceState.opaquePixmanRegion)
    targetState.bufferDamageRects = sourceState.bufferDamageRects.slice()

    targetState.bufferTransform = sourceState.bufferTransform
    targetState.bufferScale = sourceState.bufferScale

    targetState.bufferContents = sourceState.bufferContents
    targetState.frameCallbacks = targetState.frameCallbacks.concat(sourceState.frameCallbacks)
  }

  /**
   * @return {Promise<{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}>}
   * @private
   */
  async _captureState (pendingWlBuffer) {
    const self = this
    /**
     * @type {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}
     */
    const newState = {
      /**
       * @type {EncodedFrame|null}
       */
      bufferContents: null,
      /**
       * @type {Array<Rect>}
       */
      bufferDamageRects: [],
      /**
       * @type{number}
       */
      opaquePixmanRegion: self._pendingOpaqueRegion,
      /**
       * @type{number}
       */
      inputPixmanRegion: self._pendingInputRegion,
      /**
       * @type{number}
       */
      dx: self._pendingDx,
      /**
       * @type{number}
       */
      dy: self._pendingDy,
      /**
       * @type{number}
       */
      bufferTransform: self._pendingBufferTransform,
      /**
       * @type{number}
       */
      bufferScale: self._pendingBufferScale,
      /**
       * @type {Callback[]}
       */
      frameCallbacks: self._pendingFrameCallbacks,
      /**
       * @type {*}
       */
      roleState: {}
    }
    this._pendingFrameCallbacks = []

    this._pendingInputRegion = 0
    this._pendingOpaqueRegion = 0

    newState.bufferDamageRects = this._pendingDamageRects.map(rect => this.bufferTransformation.timesRect(rect)).concat(this._pendingBufferDamageRects)
    this._pendingDamageRects = []
    this._pendingBufferDamageRects = []

    if (this.role && this.role.captureRoleState) {
      newState.roleState = this.role.captureRoleState()
    }

    const bufferReceiveStart = Date.now()
    if (pendingWlBuffer) {
      const rtcDcBuffer = _RtcBufferFactory__WEBPACK_IMPORTED_MODULE_13__["default"].get(pendingWlBuffer)
      newState.bufferContents = await rtcDcBuffer.whenComplete()

      const bufferCompletion = Date.now() - bufferReceiveStart
      this._bufferCompletionTotal += bufferCompletion
      false && console.log(
        'buffer completion avg', this._bufferCompletionTotal / this._count,
        'current', bufferCompletion
      )
      let bufferSize = 0
      newState.bufferContents.fragments.forEach(fragment => {
        bufferSize += fragment.opaque.byteLength
        bufferSize += fragment.alpha.byteLength
      })
      this._bufferSizeTotal += bufferSize
      false && console.log(
        'buffer transfer avg (kb/s)', (this._bufferSizeTotal / 1024) / (this._bufferCompletionTotal / 1000),
        'current', (bufferSize / 1024) / (bufferCompletion / 1000)
      )
    } else {
      newState.bufferContents = null
    }

    return newState
  }

  /**
   *
   *                This request sets an optional transformation on how the compositor
   *                interprets the contents of the buffer attached to the surface. The
   *                accepted values for the transform parameter are the values for
   *                WlOutput.transform.
   *
   *                Buffer transform is double-buffered state, see WlSurface.commit.
   *
   *                A newly created surface has its buffer transformation set to normal.
   *
   *                WlSurface.setBufferTransform changes the pending buffer
   *                transformation. WlSurface.commit copies the pending buffer
   *                transformation to the current one. Otherwise, the pending and current
   *                values are never changed.
   *
   *                The purpose of this request is to allow clients to render content
   *                according to the output transform, thus permitting the compositor to
   *                use certain optimizations even if the display is rotated. Using
   *                hardware overlays and scanning out a client buffer for fullscreen
   *                surfaces are examples of such optimizations. Those optimizations are
   *                highly dependent on the compositor implementation, so the use of this
   *                request should be considered on a case-by-case basis.
   *
   *                Note that if the transform value includes 90 or 270 degree rotation,
   *                the width of the buffer will become the surface height and the height
   *                of the buffer will become the surface width.
   *
   *                If transform is not one of the values from the
   *                WlOutput.transform enum the invalidTransform protocol error
   *                is raised.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {number} transform undefined
   *
   * @since 2
   * @override
   */
  setBufferTransform (resource, transform) {
    if (Object.values(_protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_3___default.a.Transform).includes(transform)) {
      this._pendingBufferTransform = transform
    } else {
      resource.postError(_protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidTransform, 'Buffer transform value is invalid.')
      false && console.log('Protocol error. Buffer transform value is invalid.')
    }
  }

  /**
   *
   *                This request sets an optional scaling factor on how the compositor
   *                interprets the contents of the buffer attached to the window.
   *
   *                Buffer scale is double-buffered state, see WlSurface.commit.
   *
   *                A newly created surface has its buffer scale set to 1.
   *
   *                WlSurface.setBufferScale changes the pending buffer scale.
   *                WlSurface.commit copies the pending buffer scale to the current one.
   *                Otherwise, the pending and current values are never changed.
   *
   *                The purpose of this request is to allow clients to supply higher
   *                resolution buffer data for use on high resolution outputs. Its
   *                intended that you pick the same  buffer scale as the scale of the
   *                output that the surface is displayed on.This means the compositor
   *                can avoid scaling when rendering the surface on that output.
   *
   *                Note that if the scale is larger than 1, then you have to attach
   *                a buffer that is larger (by a factor of scale in each dimension)
   *                than the desired surface size.
   *
   *                If scale is not positive the invalidScale protocol error is
   *                raised.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {number} scale undefined
   *
   * @since 3
   * @override
   */
  setBufferScale (resource, scale) {
    if (scale < 1) {
      resource.postError(_protocol_WlSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidScale, 'Buffer scale value is invalid.')
      false && console.log('Protocol error. Buffer scale value is invalid.')
      return
    }
    this._pendingBufferScale = scale
  }

  /**
   *
   *                This request is used to describe the regions where the pending
   *                buffer is different from the current surface contents, and where
   *                the surface therefore needs to be repainted. The compositor
   *                ignores the parts of the damage that fall outside of the surface.
   *
   *                Damage is double-buffered state, see WlSurface.commit.
   *
   *                The damage rectangle is specified in buffer coordinates.
   *
   *                The initial value for pending damage is empty: no damage.
   *                WlSurface.damageBuffer adds pending damage: the new pending
   *                damage is the union of old pending damage and the given rectangle.
   *
   *                WlSurface.commit assigns pending damage as the current damage,
   *                and clears pending damage. The server will clear the current
   *                damage as it repaints the surface.
   *
   *                This request differs from WlSurface.damage in only one way - it
   *                takes damage in buffer co-ordinates instead of surface local
   *                co-ordinates. While this generally is more intuitive than surface
   *                co-ordinates, it is especially desirable when using wpViewport
   *                or when a drawing library (like EGL) is unaware of buffer scale
   *                and buffer transform.
   *
   *                Note: Because buffer transformation changes and damage requests may
   *                be interleaved in the protocol stream, It is impossible to determine
   *                the actual mapping between surface and buffer damage until
   *                WlSurface.commit time. Therefore, compositors wishing to take both
   *                kinds of damage into account will have to accumulate damage from the
   *                two requests separately and only transform from one to the other
   *                after receiving the WlSurface.commit.
   *
   *
   * @param {WlSurfaceResource} resource
   * @param {number} x undefined
   * @param {number} y undefined
   * @param {number} width undefined
   * @param {number} height undefined
   *
   * @since 4
   * @override
   */
  damageBuffer (resource, x, y, width, height) {
    this._pendingBufferDamageRects.push(_math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(x, y, x + width, y + height))
  }
}


/***/ }),
/* 23 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSurfaceRequests {

	/**
	 *
	 *	Deletes the surface and invalidates its object ID.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Set a buffer as the content of this surface.
	 *
	 *	The new size of the surface is calculated based on the buffer
	 *	size transformed by the inverse buffer_transform and the
	 *	inverse buffer_scale. This means that the supplied buffer
	 *	must be an integer multiple of the buffer_scale.
	 *
	 *	The x and y arguments specify the location of the new pending
	 *	buffer's upper left corner, relative to the current buffer's upper
	 *	left corner, in surface-local coordinates. In other words, the
	 *	x and y, combined with the new surface size define in which
	 *	directions the surface's size changes.
	 *
	 *	Surface contents are double-buffered state, see wl_surface.commit.
	 *
	 *	The initial surface contents are void; there is no content.
	 *	wl_surface.attach assigns the given wl_buffer as the pending
	 *	wl_buffer. wl_surface.commit makes the pending wl_buffer the new
	 *	surface contents, and the size of the surface becomes the size
	 *	calculated from the wl_buffer, as described above. After commit,
	 *	there is no pending buffer until the next attach.
	 *
	 *	Committing a pending wl_buffer allows the compositor to read the
	 *	pixels in the wl_buffer. The compositor may access the pixels at
	 *	any time after the wl_surface.commit request. When the compositor
	 *	will not access the pixels anymore, it will send the
	 *	wl_buffer.release event. Only after receiving wl_buffer.release,
	 *	the client may reuse the wl_buffer. A wl_buffer that has been
	 *	attached and then replaced by another attach instead of committed
	 *	will not receive a release event, and is not used by the
	 *	compositor.
	 *
	 *	Destroying the wl_buffer after wl_buffer.release does not change
	 *	the surface contents. However, if the client destroys the
	 *	wl_buffer before receiving the wl_buffer.release event, the surface
	 *	contents become undefined immediately.
	 *
	 *	If wl_surface.attach is sent with a NULL wl_buffer, the
	 *	following wl_surface.commit will remove the surface content.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {?*} buffer buffer of surface contents 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	attach(resource, buffer, x, y) {}

	/**
	 *
	 *	This request is used to describe the regions where the pending
	 *	buffer is different from the current surface contents, and where
	 *	the surface therefore needs to be repainted. The compositor
	 *	ignores the parts of the damage that fall outside of the surface.
	 *
	 *	Damage is double-buffered state, see wl_surface.commit.
	 *
	 *	The damage rectangle is specified in surface-local coordinates,
	 *	where x and y specify the upper left corner of the damage rectangle.
	 *
	 *	The initial value for pending damage is empty: no damage.
	 *	wl_surface.damage adds pending damage: the new pending damage
	 *	is the union of old pending damage and the given rectangle.
	 *
	 *	wl_surface.commit assigns pending damage as the current damage,
	 *	and clears pending damage. The server will clear the current
	 *	damage as it repaints the surface.
	 *
	 *	Alternatively, damage can be posted with wl_surface.damage_buffer
	 *	which uses buffer coordinates instead of surface coordinates,
	 *	and is probably the preferred and intuitive way of doing this.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} width width of damage rectangle 
	 * @param {number} height height of damage rectangle 
	 *
	 * @since 1
	 *
	 */
	damage(resource, x, y, width, height) {}

	/**
	 *
	 *	Request a notification when it is a good time to start drawing a new
	 *	frame, by creating a frame callback. This is useful for throttling
	 *	redrawing operations, and driving animations.
	 *
	 *	When a client is animating on a wl_surface, it can use the 'frame'
	 *	request to get notified when it is a good time to draw and commit the
	 *	next frame of animation. If the client commits an update earlier than
	 *	that, it is likely that some updates will not make it to the display,
	 *	and the client is wasting resources by drawing too often.
	 *
	 *	The frame request will take effect on the next wl_surface.commit.
	 *	The notification will only be posted for one frame unless
	 *	requested again. For a wl_surface, the notifications are posted in
	 *	the order the frame requests were committed.
	 *
	 *	The server must send the notifications so that a client
	 *	will not send excessive updates, while still allowing
	 *	the highest possible update rate for clients that wait for the reply
	 *	before drawing again. The server should give some time for the client
	 *	to draw and commit after sending the frame callback events to let it
	 *	hit the next output refresh.
	 *
	 *	A server should avoid signaling the frame callbacks if the
	 *	surface is not visible in any way, e.g. the surface is off-screen,
	 *	or completely obscured by other opaque surfaces.
	 *
	 *	The object returned by this request will be destroyed by the
	 *	compositor after the callback is fired and as such the client must not
	 *	attempt to use it after that point.
	 *
	 *	The callback_data passed in the callback is the current time, in
	 *	milliseconds, with an undefined base.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {number} callback callback object for the frame request 
	 *
	 * @since 1
	 *
	 */
	frame(resource, callback) {}

	/**
	 *
	 *	This request sets the region of the surface that contains
	 *	opaque content.
	 *
	 *	The opaque region is an optimization hint for the compositor
	 *	that lets it optimize the redrawing of content behind opaque
	 *	regions.  Setting an opaque region is not required for correct
	 *	behaviour, but marking transparent content as opaque will result
	 *	in repaint artifacts.
	 *
	 *	The opaque region is specified in surface-local coordinates.
	 *
	 *	The compositor ignores the parts of the opaque region that fall
	 *	outside of the surface.
	 *
	 *	Opaque region is double-buffered state, see wl_surface.commit.
	 *
	 *	wl_surface.set_opaque_region changes the pending opaque region.
	 *	wl_surface.commit copies the pending region to the current region.
	 *	Otherwise, the pending and current regions are never changed.
	 *
	 *	The initial value for an opaque region is empty. Setting the pending
	 *	opaque region has copy semantics, and the wl_region object can be
	 *	destroyed immediately. A NULL wl_region causes the pending opaque
	 *	region to be set to empty.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {?*} region opaque region of the surface 
	 *
	 * @since 1
	 *
	 */
	setOpaqueRegion(resource, region) {}

	/**
	 *
	 *	This request sets the region of the surface that can receive
	 *	pointer and touch events.
	 *
	 *	Input events happening outside of this region will try the next
	 *	surface in the server surface stack. The compositor ignores the
	 *	parts of the input region that fall outside of the surface.
	 *
	 *	The input region is specified in surface-local coordinates.
	 *
	 *	Input region is double-buffered state, see wl_surface.commit.
	 *
	 *	wl_surface.set_input_region changes the pending input region.
	 *	wl_surface.commit copies the pending region to the current region.
	 *	Otherwise the pending and current regions are never changed,
	 *	except cursor and icon surfaces are special cases, see
	 *	wl_pointer.set_cursor and wl_data_device.start_drag.
	 *
	 *	The initial value for an input region is infinite. That means the
	 *	whole surface will accept input. Setting the pending input region
	 *	has copy semantics, and the wl_region object can be destroyed
	 *	immediately. A NULL wl_region causes the input region to be set
	 *	to infinite.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {?*} region input region of the surface 
	 *
	 * @since 1
	 *
	 */
	setInputRegion(resource, region) {}

	/**
	 *
	 *	Surface state (input, opaque, and damage regions, attached buffers,
	 *	etc.) is double-buffered. Protocol requests modify the pending state,
	 *	as opposed to the current state in use by the compositor. A commit
	 *	request atomically applies all pending state, replacing the current
	 *	state. After commit, the new pending state is as documented for each
	 *	related request.
	 *
	 *	On commit, a pending wl_buffer is applied first, and all other state
	 *	second. This means that all coordinates in double-buffered state are
	 *	relative to the new wl_buffer coming into use, except for
	 *	wl_surface.attach itself. If there is no pending wl_buffer, the
	 *	coordinates are relative to the current surface contents.
	 *
	 *	All requests that need a commit to become effective are documented
	 *	to affect double-buffered state.
	 *
	 *	Other interfaces may add further double-buffered surface state.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	commit(resource) {}

	/**
	 *
	 *	This request sets an optional transformation on how the compositor
	 *	interprets the contents of the buffer attached to the surface. The
	 *	accepted values for the transform parameter are the values for
	 *	wl_output.transform.
	 *
	 *	Buffer transform is double-buffered state, see wl_surface.commit.
	 *
	 *	A newly created surface has its buffer transformation set to normal.
	 *
	 *	wl_surface.set_buffer_transform changes the pending buffer
	 *	transformation. wl_surface.commit copies the pending buffer
	 *	transformation to the current one. Otherwise, the pending and current
	 *	values are never changed.
	 *
	 *	The purpose of this request is to allow clients to render content
	 *	according to the output transform, thus permitting the compositor to
	 *	use certain optimizations even if the display is rotated. Using
	 *	hardware overlays and scanning out a client buffer for fullscreen
	 *	surfaces are examples of such optimizations. Those optimizations are
	 *	highly dependent on the compositor implementation, so the use of this
	 *	request should be considered on a case-by-case basis.
	 *
	 *	Note that if the transform value includes 90 or 270 degree rotation,
	 *	the width of the buffer will become the surface height and the height
	 *	of the buffer will become the surface width.
	 *
	 *	If transform is not one of the values from the
	 *	wl_output.transform enum the invalid_transform protocol error
	 *	is raised.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {number} transform transform for interpreting buffer contents 
	 *
	 * @since 2
	 *
	 */
	setBufferTransform(resource, transform) {}

	/**
	 *
	 *	This request sets an optional scaling factor on how the compositor
	 *	interprets the contents of the buffer attached to the window.
	 *
	 *	Buffer scale is double-buffered state, see wl_surface.commit.
	 *
	 *	A newly created surface has its buffer scale set to 1.
	 *
	 *	wl_surface.set_buffer_scale changes the pending buffer scale.
	 *	wl_surface.commit copies the pending buffer scale to the current one.
	 *	Otherwise, the pending and current values are never changed.
	 *
	 *	The purpose of this request is to allow clients to supply higher
	 *	resolution buffer data for use on high resolution outputs. It is
	 *	intended that you pick the same buffer scale as the scale of the
	 *	output that the surface is displayed on. This means the compositor
	 *	can avoid scaling when rendering the surface on that output.
	 *
	 *	Note that if the scale is larger than 1, then you have to attach
	 *	a buffer that is larger (by a factor of scale in each dimension)
	 *	than the desired surface size.
	 *
	 *	If scale is not positive the invalid_scale protocol error is
	 *	raised.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {number} scale positive scale for interpreting buffer contents 
	 *
	 * @since 3
	 *
	 */
	setBufferScale(resource, scale) {}

	/**
	 *
	 *	This request is used to describe the regions where the pending
	 *	buffer is different from the current surface contents, and where
	 *	the surface therefore needs to be repainted. The compositor
	 *	ignores the parts of the damage that fall outside of the surface.
	 *
	 *	Damage is double-buffered state, see wl_surface.commit.
	 *
	 *	The damage rectangle is specified in buffer coordinates,
	 *	where x and y specify the upper left corner of the damage rectangle.
	 *
	 *	The initial value for pending damage is empty: no damage.
	 *	wl_surface.damage_buffer adds pending damage: the new pending
	 *	damage is the union of old pending damage and the given rectangle.
	 *
	 *	wl_surface.commit assigns pending damage as the current damage,
	 *	and clears pending damage. The server will clear the current
	 *	damage as it repaints the surface.
	 *
	 *	This request differs from wl_surface.damage in only one way - it
	 *	takes damage in buffer coordinates instead of surface-local
	 *	coordinates. While this generally is more intuitive than surface
	 *	coordinates, it is especially desirable when using wp_viewport
	 *	or when a drawing library (like EGL) is unaware of buffer scale
	 *	and buffer transform.
	 *
	 *	Note: Because buffer transformation changes and damage requests may
	 *	be interleaved in the protocol stream, it is impossible to determine
	 *	the actual mapping between surface and buffer damage until
	 *	wl_surface.commit time. Therefore, compositors wishing to take both
	 *	kinds of damage into account will have to accumulate damage from the
	 *	two requests separately and only transform from one to the other
	 *	after receiving the wl_surface.commit.
	 *      
	 *
	 * @param {WlSurfaceResource} resource 
	 * @param {number} x buffer-local x coordinate 
	 * @param {number} y buffer-local y coordinate 
	 * @param {number} width width of damage rectangle 
	 * @param {number} height height of damage rectangle 
	 *
	 * @since 4
	 *
	 */
	damageBuffer(resource, x, y, width, height) {}
}

module.exports = WlSurfaceRequests


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      Clients can handle the 'done' event to get notified when
 *      the related request is done.
 *    
 */
class WlCallbackResource extends Resource {

	/**
	 *
	 *	Notify the client when the related request is done.
	 *      
	 *
	 * @param {number} callbackData request-specific data for the callback 
	 *
	 * @since 1
	 *
	 */
	done (callbackData) {
		this.client.marshall(this.id, 0, [uint(callbackData)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlCallbackRequests|null}
		 */
		this.implementation = null
	}

}
WlCallbackResource.protocolName = 'wl_callback'

module.exports = WlCallbackResource


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      An output describes part of the compositor geometry.  The
 *      compositor works in the 'compositor coordinate system' and an
 *      output corresponds to a rectangular area in that space that is
 *      actually visible.  This typically corresponds to a monitor that
 *      displays part of the compositor space.  This object is published
 *      as global during start up, or when a monitor is hotplugged.
 *    
 */
class WlOutputResource extends Resource {

	/**
	 *
	 *	The geometry event describes geometric properties of the output.
	 *	The event is sent when binding to the output object and whenever
	 *	any of the properties change.
	 *      
	 *
	 * @param {number} x x position within the global compositor space 
	 * @param {number} y y position within the global compositor space 
	 * @param {number} physicalWidth width in millimeters of the output 
	 * @param {number} physicalHeight height in millimeters of the output 
	 * @param {number} subpixel subpixel orientation of the output 
	 * @param {string} make textual description of the manufacturer 
	 * @param {string} model textual description of the model 
	 * @param {number} transform transform that maps framebuffer to output 
	 *
	 * @since 1
	 *
	 */
	geometry (x, y, physicalWidth, physicalHeight, subpixel, make, model, transform) {
		this.client.marshall(this.id, 0, [int(x), int(y), int(physicalWidth), int(physicalHeight), int(subpixel), string(make), string(model), int(transform)])
	}

	/**
	 *
	 *	The mode event describes an available mode for the output.
	 *
	 *	The event is sent when binding to the output object and there
	 *	will always be one mode, the current mode.  The event is sent
	 *	again if an output changes mode, for the mode that is now
	 *	current.  In other words, the current mode is always the last
	 *	mode that was received with the current flag set.
	 *
	 *	The size of a mode is given in physical hardware units of
	 *	the output device. This is not necessarily the same as
	 *	the output size in the global compositor space. For instance,
	 *	the output may be scaled, as described in wl_output.scale,
	 *	or transformed, as described in wl_output.transform.
	 *      
	 *
	 * @param {number} flags bitfield of mode flags 
	 * @param {number} width width of the mode in hardware units 
	 * @param {number} height height of the mode in hardware units 
	 * @param {number} refresh vertical refresh rate in mHz 
	 *
	 * @since 1
	 *
	 */
	mode (flags, width, height, refresh) {
		this.client.marshall(this.id, 1, [uint(flags), int(width), int(height), int(refresh)])
	}

	/**
	 *
	 *	This event is sent after all other properties have been
	 *	sent after binding to the output object and after any
	 *	other property changes done after that. This allows
	 *	changes to the output properties to be seen as
	 *	atomic, even if they happen via multiple events.
	 *      
	 * @since 2
	 *
	 */
	done () {
		this.client.marshall(this.id, 2, [])
	}

	/**
	 *
	 *	This event contains scaling geometry information
	 *	that is not in the geometry event. It may be sent after
	 *	binding the output object or if the output scale changes
	 *	later. If it is not sent, the client should assume a
	 *	scale of 1.
	 *
	 *	A scale larger than 1 means that the compositor will
	 *	automatically scale surface buffers by this amount
	 *	when rendering. This is used for very high resolution
	 *	displays where applications rendering at the native
	 *	resolution would be too small to be legible.
	 *
	 *	It is intended that scaling aware clients track the
	 *	current output of a surface, and if it is on a scaled
	 *	output it should use wl_surface.set_buffer_scale with
	 *	the scale of the output. That way the compositor can
	 *	avoid scaling the surface, and the client can supply
	 *	a higher detail image.
	 *      
	 *
	 * @param {number} factor scaling factor of output 
	 *
	 * @since 2
	 *
	 */
	scale (factor) {
		this.client.marshall(this.id, 3, [int(factor)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlOutputRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.release(this)
	}
}
WlOutputResource.protocolName = 'wl_output'

WlOutputResource.Subpixel = {
  /**
   * unknown geometry
   */
  unknown: 0,
  /**
   * no geometry
   */
  none: 1,
  /**
   * horizontal RGB
   */
  horizontalRgb: 2,
  /**
   * horizontal BGR
   */
  horizontalBgr: 3,
  /**
   * vertical RGB
   */
  verticalRgb: 4,
  /**
   * vertical BGR
   */
  verticalBgr: 5
}

WlOutputResource.Transform = {
  /**
   * no transform
   */
  normal: 0,
  /**
   * 90 degrees counter-clockwise
   */
  90: 1,
  /**
   * 180 degrees counter-clockwise
   */
  180: 2,
  /**
   * 270 degrees counter-clockwise
   */
  270: 3,
  /**
   * 180 degree flip around a vertical axis
   */
  flipped: 4,
  /**
   * flip and rotate 90 degrees counter-clockwise
   */
  flipped90: 5,
  /**
   * flip and rotate 180 degrees counter-clockwise
   */
  flipped180: 6,
  /**
   * flip and rotate 270 degrees counter-clockwise
   */
  flipped270: 7
}

WlOutputResource.Mode = {
  /**
   * indicates this is the current mode
   */
  current: 0x1,
  /**
   * indicates this is the preferred mode
   */
  preferred: 0x2
}

module.exports = WlOutputResource


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return View; });
/* harmony import */ var _math_Mat4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _BufferedCanvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _math_Vec4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);







class View {
  /**
   *
   * @param {Surface} surface
   * @param {number} width
   * @param {number} height
   * @returns {View}
   */
  static create (surface, width, height) {
    const bufferedCanvas = _BufferedCanvas__WEBPACK_IMPORTED_MODULE_1__["default"].create(width, height)
    const view = new View(bufferedCanvas, surface, _math_Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].IDENTITY())
    bufferedCanvas.view = view
    view.updateInputRegion()
    return view
  }

  /**
   * @return {number}
   * @private
   */
  static _nextTopZIndex () {
    this._topZIndex++
    return this._topZIndex
  }

  /**
   * Use View.create(..) instead.
   * @private
   * @param {BufferedCanvas}bufferedCanvas
   * @param {Surface}surface
   * @param {Mat4} transformation
   */
  constructor (bufferedCanvas, surface, transformation) {
    /**
     * @type {BufferedCanvas}
     */
    this.bufferedCanvas = bufferedCanvas
    /**
     * @type {Surface}
     */
    this.surface = surface
    /**
     * @type {?Mat4}
     */
    this.customTransformation = null
    /**
     * @type {Mat4}
     */
    this._transformation = transformation
    /**
     * @type {Mat4}
     */
    this._backBufferTransformation = transformation
    /**
     * @type {Mat4}
     */
    this._inverseTransformation = transformation.invert()
    /**
     * @type {Promise}
     * @private
     */
    this._destroyPromise = new Promise((resolve) => {
      this._destroyResolve = resolve
    })
    /**
     * @type {boolean}
     */
    this.destroyed = false
    /**
     * @type {View}
     * @private
     */
    this._parent = null
    /**
     * @type {boolean}
     * @private
     */
    this._primary = false
  }

  /**
   * @param {View}parent
   */
  set parent (parent) {
    if (this.destroyed) {
      return
    }
    this._parent = parent

    if (this._parent) {
      this.primary = parent.primary

      parent.onDestroy().then(() => {
        if (this.parent === parent) {
          this.destroy()
          this.parent = null
        }
      })
      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_4__["default"].createRenderFrame()
      this.applyTransformations(renderFrame)
      renderFrame.fire()
      if (this._parent.isAttached()) {
        this.attachTo(this._parent.parentElement())
      } else {
        this.detach()
      }
    }
  }

  set primary (primary) {
    if (this.destroyed) {
      return
    }
    this._primary = primary
  }

  get primary () {
    if (this._primary) {
      return true
    } else if (this.parent) {
      return this.parent.primary
    } else {
      return false
    }
  }

  /**
   * @return {View}
   */
  get parent () {
    return this._parent
  }

  /**
   * @param {Mat4}transformation
   */
  set transformation (transformation) {
    if (this.destroyed) {
      return
    }
    this._transformation = transformation
    this._inverseTransformation = transformation.invert()
  }

  /**
   * @return {Mat4}
   */
  get transformation () {
    return this._transformation
  }

  /**
   * @param {RenderFrame}renderFrame
   */
  applyTransformations (renderFrame) {
    if (this.destroyed) {
      return
    }
    const transformation = this._calculateTransformation()
    this.transformation = transformation
    const bufferToViewTransformation = transformation.timesMat4(this.surface.inverseBufferTransformation)
    // update canvas
    const newCssTransform = bufferToViewTransformation.toCssMatrix()
    renderFrame.then(() => {
      this.bufferedCanvas.setElementTransformation(newCssTransform)
    })
    this._applyTransformationsChild(renderFrame)
  }

  /**
   * @param renderFrame
   * @private
   */
  _applyTransformationsChild (renderFrame) {
    // find all child views who have this view as it's parent and update their transformation
    this.surface.children.forEach((surfaceChild) => {
      if (surfaceChild.surface === this.surface) {
        return
      }

      surfaceChild.surface.views.filter((view) => {
        return view.parent === this
      }).forEach((childView) => {
        childView.applyTransformations(renderFrame)
      })
    })
  }

  /**
   * @private
   */
  _applyTransformationsBackBuffer () {
    const transformation = this._calculateTransformation()
    this._backBufferTransformation = transformation
    const bufferToViewTransformation = transformation.timesMat4(this.surface.inverseBufferTransformation)
    // update canvas
    const newCssTransform = bufferToViewTransformation.toCssMatrix()
    this.bufferedCanvas.setBackBufferElementTransformation(newCssTransform)
  }

  /**
   * @return {Mat4}
   * @private
   */
  _calculateTransformation () {
    if (this.customTransformation) {
      return this.customTransformation
    }
    // TODO we might want to keep some 'transformation dirty' flags to avoid needless matrix multiplications

    // inherit parent transformation
    let parentTransformation = _math_Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].IDENTITY()
    if (this._parent) {
      parentTransformation = this._parent.transformation
    }

    // position transformation
    const surfaceChild = this.surface.surfaceChildSelf
    const {x, y} = surfaceChild.position
    const positionTransformation = _math_Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].translation(x, y)

    return parentTransformation.timesMat4(positionTransformation)
  }

  raise () {
    if (this.destroyed) {
      return
    }
    this.zIndex = View._nextTopZIndex()
    this.surface.updateChildViewsZIndexes()
  }

  /**
   * @param {number}index
   */
  set zIndex (index) {
    if (this.destroyed) {
      return
    }
    if (index >= View._topZIndex) {
      View._topZIndex = index
    }
    this.bufferedCanvas.zIndex = index
  }

  /**
   * @return {number}
   */
  get zIndex () {
    return window.parseInt(this.bufferedCanvas.frontContext.canvas.style.zIndex, 10)
  }

  /**
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap}image
   */
  draw (image) {
    if (this.destroyed) {
      return
    }
    // FIXME adjust final transformation with additional transformations defined in the surface
    this._applyTransformationsBackBuffer()
    this.bufferedCanvas.drawBackBuffer(image)
  }

  /**
   * @param {RenderFrame}renderFrame
   */
  swapBuffers (renderFrame) {
    if (this.destroyed) {
      return
    }
    this.transformation = this._backBufferTransformation
    renderFrame.then(() => {
      this.bufferedCanvas.swapBuffers()
    })
    // update child transformations as new parent buffer is visible
    this._applyTransformationsChild(renderFrame)
  }

  /**
   * @param {Point} viewPoint point in view coordinates with respect to view transformations
   * @return {Point} point in browser coordinates
   */
  toBrowserSpace (viewPoint) {
    return this.transformation.timesPoint(viewPoint)
  }

  /**
   * @param {Point} browserPoint point in browser coordinates
   * @return {Point} point in view coordinates with respect to view transformations
   */
  toViewSpaceFromBrowser (browserPoint) {
    return this._inverseTransformation.timesPoint(browserPoint)
  }

  toViewSpaceFromSurface (surfacePoint) {
    const canvas = this.bufferedCanvas.frontContext.canvas
    const boundingRect = canvas.getBoundingClientRect()
    const canvasWidth = Math.round(boundingRect.width)
    const canvasHeight = Math.round(boundingRect.height)
    const surfaceSize = this.surface.size
    const surfaceWidth = surfaceSize.w
    const surfaceHeight = surfaceSize.h
    if (surfaceWidth === canvasWidth && surfaceHeight === canvasHeight) {
      return surfacePoint
    } else {
      return _math_Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].scalarVector(_math_Vec4__WEBPACK_IMPORTED_MODULE_2__["default"].create2D(canvasWidth / surfaceWidth, canvasHeight / surfaceHeight)).timesPoint(surfacePoint)
    }
  }

  /**
   * @param {Point} browserPoint point in browser coordinates
   * @return {Point}
   */
  toSurfaceSpace (browserPoint) {
    const viewPoint = this.toViewSpaceFromBrowser(browserPoint)

    const canvas = this.bufferedCanvas.frontContext.canvas
    const boundingRect = canvas.getBoundingClientRect()
    const canvasWidth = Math.round(boundingRect.width)
    const canvasHeight = Math.round(boundingRect.height)
    const surfaceSize = this.surface.size
    const surfaceWidth = surfaceSize.w
    const surfaceHeight = surfaceSize.h
    if (surfaceWidth === canvasWidth && surfaceHeight === canvasHeight) {
      return viewPoint
    } else {
      return _math_Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].scalarVector(_math_Vec4__WEBPACK_IMPORTED_MODULE_2__["default"].create2D(surfaceWidth / canvasWidth, surfaceHeight / canvasHeight)).timesPoint(viewPoint)
    }
  }

  fadeOut () {
    this.bufferedCanvas.addCssClass('fadeToHidden')
  }

  show () {
    if (this.destroyed) {
      return
    }
    this.bufferedCanvas.removeCssClass('fadeToHidden')
  }

  destroy () {
    this.destroyed = true
    this._destroyResolve()
  }

  /**
   * @return {Promise}
   */
  onDestroy () {
    return this._destroyPromise
  }

  isAttached () {
    return this.bufferedCanvas.isAttachedToElement()
  }

  /**
   * @param {HTMLElement}element
   */
  attachTo (element) {
    if (this.destroyed) {
      return
    }
    this.bufferedCanvas.attachToElement(element)

    // attach child views
    this.surface.children.forEach((surfaceChild) => {
      surfaceChild.surface.views.filter((childView) => {
        return childView.parent === this
      }).forEach((childView) => {
        childView.attachTo(element)
      })
    })
  }

  /**
   * @return {HTMLElement}
   */
  parentElement () {
    return this.bufferedCanvas.frontContext.canvas.parentElement
  }

  detach () {
    this.bufferedCanvas.detachFromElement()
  }

  updateInputRegion () {
    if (this.destroyed) {
      return
    }
    const inputPixmanRegion = this.surface.state.inputPixmanRegion
    const surfacePixmanRegion = this.surface.pixmanRegion
    _Region__WEBPACK_IMPORTED_MODULE_3__["default"].intersect(inputPixmanRegion, inputPixmanRegion, surfacePixmanRegion)
    const inputRectangles = _Region__WEBPACK_IMPORTED_MODULE_3__["default"].rectangles(inputPixmanRegion)
    this.bufferedCanvas.updateInputRegionElements(inputRectangles)
  }
}

/**
 * @type {number}
 * @private
 */
View._topZIndex = 20


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mat4; });
/* harmony import */ var _Vec4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);






class Mat4 {
  /**
   * @param m00 Column 0, Row 0
   * @param m10 Column 1, Row 0
   * @param m20 Column 2, Row 0
   * @param m30 Column 3, Row 0
   * @param m01 Column 0, Row 1
   * @param m11 Column 1, Row 1
   * @param m21 Column 2, Row 1
   * @param m31 Column 3, Row 1
   * @param m02 Column 0, Row 2
   * @param m12 Column 1, Row 2
   * @param m22 Column 2, Row 2
   * @param m32 Column 3, Row 2
   * @param m03 Column 0, Row 3
   * @param m13 Column 1, Row 3
   * @param m23 Column 2, Row 3
   * @param m33 Column 3, Row 3
   * @returns {Mat4}
   */
  static create (m00, m10, m20, m30,
                 m01, m11, m21, m31,
                 m02, m12, m22, m32,
                 m03, m13, m23, m33) {
    return new Mat4(
      m00, m10, m20, m30,
      m01, m11, m21, m31,
      m02, m12, m22, m32,
      m03, m13, m23, m33
    )
  }

  /**
   * @returns {Mat4}
   */
  static IDENTITY () {
    return this.create(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1)
  }

  /**
   * @param {Number}scale
   * @returns {Mat4}
   */
  static scalar (scale) {
    return this.create(
      scale, 0, 0, 0,
      0, scale, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    )
  }

  /**
   * @param {Vec4}vect4
   * @returns {Mat4}
   */
  static scalarVector (vect4) {
    return this.create(
      vect4.x, 0, 0, 0,
      0, vect4.y, 0, 0,
      0, 0, vect4.z, 0,
      0, 0, 0, vect4.w
    )
  }

  /**
   * @param {Number}x
   * @param {Number}y
   * @returns {Mat4}
   */
  static translation (x, y) {
    return this.create(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, 0,
      0, 0, 0, 1
    )
  }

  constructor (m00, m10, m20, m30,
               m01, m11, m21, m31,
               m02, m12, m22, m32,
               m03, m13, m23, m33) {
    this.m00 = m00
    this.m10 = m10
    this.m20 = m20
    this.m30 = m30
    this.m01 = m01
    this.m11 = m11
    this.m21 = m21
    this.m31 = m31
    this.m02 = m02
    this.m12 = m12
    this.m22 = m22
    this.m32 = m32
    this.m03 = m03
    this.m13 = m13
    this.m23 = m23
    this.m33 = m33
  }

  /**
   * Add a matrix using this matrix, resulting in a new matrix.
   * @param {Mat4} other
   * @returns {Mat4}
   */
  plus (other) {
    return Mat4.create(
      this.m00 + other.m00, this.m10 + other.m10, this.m20 + other.m20, this.m30 + other.m30,
      this.m01 + other.m01, this.m11 + other.m11, this.m21 + other.m21, this.m31 + other.m31,
      this.m02 + other.m02, this.m12 + other.m12, this.m22 + other.m22, this.m32 + other.m32,
      this.m03 + other.m03, this.m13 + other.m13, this.m23 + other.m23, this.m33 + other.m33
    )
  }

  /**
   * Multiply a point using this matrix, resulting in a new point
   * @param {Point} right
   * @return {Point}
   */
  timesPoint (right) {
    return this.timesVec4(right.toVec4()).toPoint()
  }

  /**
   * Multiply a vector using this matrix, resulting in a new vector.
   * @param {Vec4} right
   * @return {Vec4}
   */
  timesVec4 (right) {
    const rightX = right.x
    const rightY = right.y
    const rightZ = right.z
    const rightW = right.w

    return _Vec4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
      this.m00 * rightX + this.m10 * rightY + this.m20 * rightZ + this.m30 * rightW,
      this.m01 * rightX + this.m11 * rightY + this.m21 * rightZ + this.m31 * rightW,
      this.m02 * rightX + this.m12 * rightY + this.m22 * rightZ + this.m32 * rightW,
      this.m03 * rightX + this.m13 * rightY + this.m23 * rightZ + this.m33 * rightW
    )
  }

  /**
   * Multiply a matrix using this matrix, resulting in a new matrix.
   * @param {Mat4} right
   * @returns {Mat4}
   */
  timesMat4 (right) {
    const nm00 = this.m00 * right.m00 + this.m10 * right.m01 + this.m20 * right.m02 + this.m30 * right.m03
    const nm01 = this.m01 * right.m00 + this.m11 * right.m01 + this.m21 * right.m02 + this.m31 * right.m03
    const nm02 = this.m02 * right.m00 + this.m12 * right.m01 + this.m22 * right.m02 + this.m32 * right.m03
    const nm03 = this.m03 * right.m00 + this.m13 * right.m01 + this.m23 * right.m02 + this.m33 * right.m03
    const nm10 = this.m00 * right.m10 + this.m10 * right.m11 + this.m20 * right.m12 + this.m30 * right.m13
    const nm11 = this.m01 * right.m10 + this.m11 * right.m11 + this.m21 * right.m12 + this.m31 * right.m13
    const nm12 = this.m02 * right.m10 + this.m12 * right.m11 + this.m22 * right.m12 + this.m32 * right.m13
    const nm13 = this.m03 * right.m10 + this.m13 * right.m11 + this.m23 * right.m12 + this.m33 * right.m13
    const nm20 = this.m00 * right.m20 + this.m10 * right.m21 + this.m20 * right.m22 + this.m30 * right.m23
    const nm21 = this.m01 * right.m20 + this.m11 * right.m21 + this.m21 * right.m22 + this.m31 * right.m23
    const nm22 = this.m02 * right.m20 + this.m12 * right.m21 + this.m22 * right.m22 + this.m32 * right.m23
    const nm23 = this.m03 * right.m20 + this.m13 * right.m21 + this.m23 * right.m22 + this.m33 * right.m23
    const nm30 = this.m00 * right.m30 + this.m10 * right.m31 + this.m20 * right.m32 + this.m30 * right.m33
    const nm31 = this.m01 * right.m30 + this.m11 * right.m31 + this.m21 * right.m32 + this.m31 * right.m33
    const nm32 = this.m02 * right.m30 + this.m12 * right.m31 + this.m22 * right.m32 + this.m32 * right.m33
    const nm33 = this.m03 * right.m30 + this.m13 * right.m31 + this.m23 * right.m32 + this.m33 * right.m33

    return Mat4.create(
      nm00, nm10, nm20, nm30,
      nm01, nm11, nm21, nm31,
      nm02, nm12, nm22, nm32,
      nm03, nm13, nm23, nm33
    )
  }

  /**
   * Multiply a rectangle using this matrix, resulting in a new rectangle.
   * @param {Rect} right
   * @returns {Rect}
   */
  timesRect (right) {
    const topLeft = this.timesPoint(_Point__WEBPACK_IMPORTED_MODULE_1__["default"].create(right.x0, right.y0))
    const bottomRight = this.timesPoint(_Point__WEBPACK_IMPORTED_MODULE_1__["default"].create(right.x1, right.y1))
    return _Rect__WEBPACK_IMPORTED_MODULE_2__["default"].create(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y)
  }

  /**
   *
   * @returns {Mat4}
   */
  invert () {
    const M = [
      [this.m00, this.m01, this.m02, this.m03],
      [this.m10, this.m11, this.m12, this.m13],
      [this.m20, this.m21, this.m22, this.m23],
      [this.m30, this.m31, this.m32, this.m33]
    ]

    let i
    let ii = 0
    let j = 0
    const dim = M.length
    let e = 0
    const I = []
    const C = []
    for (i = 0; i < dim; i += 1) {
      I[I.length] = []
      C[C.length] = []
      for (j = 0; j < dim; j += 1) {
        if (i === j) { I[i][j] = 1 } else { I[i][j] = 0 }
        C[i][j] = M[i][j]
      }
    }

    for (i = 0; i < dim; i += 1) {
      e = C[i][i]

      if (e === 0) {
        for (ii = i + 1; ii < dim; ii += 1) {
          if (C[ii][i] !== 0) {
            for (j = 0; j < dim; j++) {
              e = C[i][j]
              C[i][j] = C[ii][j]
              C[ii][j] = e
              e = I[i][j]
              I[i][j] = I[ii][j]
              I[ii][j] = e
            }
            break
          }
        }
        e = C[i][i]
        if (e === 0) { return }
      }

      for (j = 0; j < dim; j++) {
        C[i][j] = C[i][j] / e
        I[i][j] = I[i][j] / e
      }

      for (ii = 0; ii < dim; ii++) {
        if (ii === i) { continue }

        // We want to change this element to 0
        e = C[ii][i]

        for (j = 0; j < dim; j++) {
          C[ii][j] -= e * C[i][j]
          I[ii][j] -= e * I[i][j]
        }
      }
    }

    return Mat4.create(
      I[0][0], I[1][0], I[2][0], I[3][0],
      I[0][1], I[1][1], I[2][1], I[3][1],
      I[0][2], I[1][2], I[2][2], I[3][2],
      I[0][3], I[1][3], I[2][3], I[3][3]
    )
  }

  clone () {
    return Mat4.create(
      this.m00, this.m10, this.m20, this.m30,
      this.m01, this.m11, this.m21, this.m31,
      this.m02, this.m12, this.m22, this.m32,
      this.m03, this.m13, this.m23, this.m33
    )
  }

  /**
   * @return {string}
   */
  toCssMatrix () {
    // css matrix is column major order
    return `matrix3d(${this.m00}, ${this.m01}, ${this.m02}, ${this.m03}, ${this.m10}, ${this.m11}, ${this.m12}, ${this.m13}, ${this.m20}, ${this.m21}, ${this.m22}, ${this.m23}, ${this.m30}, ${this.m31}, ${this.m32}, ${this.m33})`
  }
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vec4; });
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);


class Vec4 {
  /**
   * @param {number}x
   * @param {number}y
   * @param {number}z
   * @param {number}w
   * @returns {Vec4}
   */
  static create (x, y, z, w) {
    return new Vec4(x, y, z, w)
  }

  static create2D (x, y) {
    return this.create(x, y, 1, 1)
  }

  /**
   * @param {number}x
   * @param {number}y
   * @param {number}z
   * @param {number}w
   */
  constructor (x, y, z, w) {
    this.x = x
    this.y = y
    this.z = z
    this.w = w
  }

  /**
   * @param {Vec4} right
   * @returns {Vec4}
   */
  plus (right) {
    return Vec4.create(
      this.x + right.x,
      this.y + right.y,
      this.z + right.z,
      this.w + right.w
    )
  }

  /**
   * @param {Vec4} right
   * @returns {Vec4}
   */
  minus (right) {
    return Vec4.create(
      this.x - right.x,
      this.y - right.y,
      this.z - right.z,
      this.w - right.w
    )
  }

  /**
   * @returns {Point}
   */
  toPoint () {
    return _Point__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.x, this.y)
  }
}


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Point; });
/* harmony import */ var _Vec4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);




class Point {
  /**
   * @param {number }x
   * @param {number} y
   * @returns {Point}
   */
  static create (x, y) {
    return new Point(x, y)
  }

  /**
   *
   * @param {number}x
   * @param {number}y
   */
  constructor (x, y) {
    /**
     * @type {number}
     */
    this.x = x
    /**
     * @type {number}
     */
    this.y = y
  }

  /**
   * @returns {Vec4}
   */
  toVec4 () {
    return _Vec4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
      this.x,
      this.y,
      0,
      1)
  }

  /**
   * @param {Point} right
   * @returns {Point}
   */
  plus (right) {
    return Point.create(
      this.x + right.x,
      this.y + right.y
    )
  }

  /**
   * @param {Point} right
   * @returns {Point}
   */
  minus (right) {
    return Point.create(
      this.x - right.x,
      this.y - right.y
    )
  }
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Rect; });
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);





class Rect {
  /**
   * @param {Number} x0 top left x
   * @param {Number} y0 top left y
   * @param {Number} x1 bottom right x
   * @param {Number} y1 bottom right y
   * @returns {Rect}
   */
  static create (x0, y0, x1, y1) {
    return new Rect(x0, y0, x1, y1)
  }

  /**
   * @param {Number} x0
   * @param {Number} y0
   * @param {Number} x1
   * @param {Number} y1
   * @returns {Rect}
   */
  constructor (x0, y0, x1, y1) {
    this.x0 = x0
    this.y0 = y0
    this.x1 = x1
    this.y1 = y1
  }

  /**
   * @return {number}
   */
  get width () {
    return Math.abs(this.x1 - this.x0)
  }

  /**
   * @return {number}
   */
  get height () {
    return Math.abs(this.y1 - this.y0)
  }

  /**
   * @return {Size}
   */
  get size () {
    return _Size__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.width, this.height)
  }

  /**
   * @return {Point}
   */
  get position () {
    return _Point__WEBPACK_IMPORTED_MODULE_1__["default"].create(this.x0, this.y0)
  }

  /**
   * @param {Rect}other
   * @return {Rect}
   */
  intersect (other) {
    const r1 = this
    const r2 = other

    const leftX = Math.max(r1.x0, r2.x0)
    const rightX = Math.min(r1.x1, r2.x1)
    const topY = Math.max(r1.y0, r2.y0)
    const bottomY = Math.min(r1.y1, r2.y1)

    let intersectionRect
    if (leftX < rightX && topY < bottomY) {
      intersectionRect = Rect.create(leftX, topY, rightX, bottomY)
    } else {
      // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)
      intersectionRect = Rect.create(0, 0, 0, 0)
    }

    return intersectionRect
  }
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Size; });


/**
 * Represents a 2-dimensional size value.
 */

class Size {
  /**
   *
   * @param {number} width
   * @param {number} height
   * @returns {Size}
   */
  static create (width, height) {
    return new Size(width, height)
  }

  /**
   * @param {number} w
   * @param {number} h
   */
  constructor (w, h) {
    /**
     * @type {number}
     */
    this.w = w
    /**
     * @type {number}
     */
    this.h = h
  }

  /**
   * @returns {string}
   */
  toString () {
    return '(' + this.w + ', ' + this.h + ')'
  }

  /**
   * @returns {Size}
   */
  getHalfSize () {
    return new Size(this.w >>> 1, this.h >>> 1)
  }

  /**
   * @param {Size}size
   * @return {boolean}
   */
  equals (size) {
    return size.w === this.w && size.h === this.h
  }
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferedCanvas; });
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);




/**
 * A double buffered canvas. Required as canvas resizing & css transform is not atomic and can result in flickering.
 * This class has 2 canvasses that can be swapped. Ideally one would render to the invisible 'back' canvas, once done
 * a call to requestAnimation frame can be used to perform a swapBuffers(). This will make the 'back' canvas the 'front'
 * canvas, and effectively make it visible. The 'front' canvas will then become the 'back' canvas.
 */
class BufferedCanvas {
  /**
   * @param width
   * @param height
   * @return {BufferedCanvas}
   */
  static create (width, height) {
    const frontCanvas = document.createElement('canvas')
    frontCanvas.width = width
    frontCanvas.height = height
    frontCanvas.style.display = 'inline'
    frontCanvas.style.zIndex = '0'
    const frontContext = frontCanvas.getContext('2d')
    if (!frontContext.canvas) {
      frontContext.canvas = frontCanvas
    }

    const backCanvas = document.createElement('canvas')
    backCanvas.width = width
    backCanvas.height = height
    backCanvas.style.display = 'none'
    backCanvas.style.zIndex = '0'
    const backContext = backCanvas.getContext('2d')
    if (!backContext.canvas) {
      backContext.canvas = backCanvas
    }

    const containerDiv = document.createElement('div')
    containerDiv.style.display = 'contents'
    containerDiv.appendChild(frontCanvas)
    containerDiv.appendChild(backCanvas)

    return new BufferedCanvas(frontContext, backContext, containerDiv)
  }

  /**
   * @param {CanvasRenderingContext2D}frontContext
   * @param {CanvasRenderingContext2D}backContext
   * @param {HTMLDivElement}containerDiv
   */
  constructor (frontContext, backContext, containerDiv) {
    /**
     * @type {CanvasRenderingContext2D}
     */
    this.frontContext = frontContext
    /**
     * @type {CanvasRenderingContext2D}
     */
    this.backContext = backContext
    /**
     * @type {Array<HTMLDivElement>}
     */
    this.inputDivs = []
    /**
     * @type {HTMLDivElement}
     */
    this.containerDiv = containerDiv
    /**
     * Set by the View after constructing this buffered canvas.
     * @type {View}
     */
    this.view = null
    /**
     * @type {?Promise<void>}
     * @private
     */
    this._backBufferSync = null
  }

  /**
   * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap}image
   */
  drawBackBuffer (image) {
    this._draw(this.backContext, image)
  }

  /**
   * @param {CanvasRenderingContext2D} renderingContext
   * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap}image
   * @private
   */
  _draw (renderingContext, image) {
    const canvas = renderingContext.canvas

    if (canvas.width !== image.width || canvas.height !== image.height) {
      // resizing clears the canvas
      canvas.width = image.width
      canvas.height = image.height
    } else {
      // clear canvas
      renderingContext.clearRect(0, 0, canvas.width, canvas.height)
    }

    renderingContext.drawImage(image, 0, 0)
  }

  swapBuffers () {
    // swap canvasses
    const oldFront = this.frontContext
    this.frontContext = this.backContext
    this.backContext = oldFront

    // make back canvas invisible
    this.backContext.canvas.style.display = 'none'
    // make new front canvas visible
    this.frontContext.canvas.style.display = 'inline'

    // make sure the new back canvas has the same transformation as the new front canvas
    this.containerDiv.style.transform = this.frontContext.canvas.style.transform
    this.frontContext.canvas.style.transform = 'inherit'
    this.backContext.canvas.style.transform = this.containerDiv.style.transform
  }

  /**
   * @param {number}index
   */
  set zIndex (index) {
    const zIndex = index.toString(10)
    this.frontContext.canvas.style.zIndex = zIndex
    this.backContext.canvas.style.zIndex = zIndex
    this.inputDivs.forEach((inputDiv) => {
      inputDiv.style.zIndex = zIndex + 1
    })
  }

  /**
   * @return {Size}
   */
  size () {
    return _Size__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.frontContext.canvas.width, this.frontContext.canvas.height)
  }

  /**
   * @param {string}cssClass
   */
  addCssClass (cssClass) {
    this.containerDiv.classList.add(cssClass)
  }

  /**
   * @param {string}cssClass
   */
  removeCssClass (cssClass) {
    this.containerDiv.classList.remove(cssClass)
  }

  _detachInputDivs () {
    this.inputDivs.forEach((inputDiv) => {
      if (inputDiv.parentElement) {
        inputDiv.parentElement.removeChild(inputDiv)
      }
    })
  }

  /**
   * @param {HTMLDivElement}divElement
   * @param {Rect}rectangle
   * @private
   */
  _syncDivToRect (divElement, rectangle) {
    const rectangleSize = rectangle.size
    divElement.style.left = `${rectangle.x0}px`
    divElement.style.top = `${rectangle.y0}px`
    divElement.style.width = `${rectangleSize.w}px`
    divElement.style.height = `${rectangleSize.h}px`
  }

  /**
   * @param {Array<Rect>}rectangles
   */
  updateInputRegionElements (rectangles) {
    if (this.inputDivs.length !== rectangles.length) { // recreate divs
      this._detachInputDivs()
      this.inputDivs = []
      rectangles.forEach((rectangle) => {
        const inputDiv = document.createElement('div')
        inputDiv.view = this.view
        inputDiv.classList.add('inputRegion')
        inputDiv.style.zIndex = this.frontContext.canvas.style.zIndex + 1
        this._syncDivToRect(inputDiv, rectangle)
        // TODO a document fragment might be interesting here for atomically adding a group of html elements
        this.containerDiv.appendChild(inputDiv)
        this.inputDivs.push(inputDiv)
      })
    } else { // update existing divs
      for (let i = 0; i < rectangles.length; i++) {
        const rectangle = rectangles[i]
        const inputDiv = this.inputDivs[i]
        this._syncDivToRect(inputDiv, rectangle)
      }
    }
  }

  /**
   * @param {HTMLElement}element
   */
  attachToElement (element) {
    // TODO a document fragment might be interesting here for atomically adding a group of html elements
    element.appendChild(this.containerDiv)
  }

  /**
   * @return {boolean}
   */
  isAttachedToElement () {
    return this.containerDiv.parentElement !== null
  }

  detachFromElement () {
    if (this.containerDiv.parentElement) {
      this.containerDiv.parentElement.removeChild(this.containerDiv)
    }
  }

  /**
   * @param {string}cssTransformation
   */
  setElementTransformation (cssTransformation) {
    this.containerDiv.style.transform = cssTransformation
  }

  /**
   * @param {string}cssTransformation
   */
  setBackBufferElementTransformation (cssTransformation) {
    this.backContext.canvas.style.transform = cssTransformation
  }

  /**
   * @return {HTMLElement | null}
   */
  getParentElement () {
    return this.containerDiv.parentElement
  }
}


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _protocol_WlRegionRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
/* harmony import */ var _protocol_WlRegionRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlRegionRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);






/**
 *
 *            A region object describes an area.
 *
 *            Region objects are used to describe the opaque and input
 *            regions of a surface.
 * @implements WlRegionRequests
 */
class Region extends _protocol_WlRegionRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   *
   * @param {!WlRegionResource} wlRegionResource
   * @returns {!Region}
   */
  static create (wlRegionResource) {
    const pixmanRegion = Region.createPixmanRegion()
    const region = new Region(wlRegionResource, pixmanRegion)
    wlRegionResource.implementation = region
    wlRegionResource.onDestroy().then(() => { Region.destroyPixmanRegion(pixmanRegion) })
    return region
  }

  /**
   * @return {!number}
   */
  static createPixmanRegion () {
    const pixmanRegion = _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._malloc(20)// region struct is pointer + 4*uint32 = 5*4 = 20
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_init(pixmanRegion)
    return pixmanRegion
  }

  /**
   * @param {!number} pixmanRegion
   */
  static fini (pixmanRegion) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_fini(pixmanRegion)
  }

  /**
   * @param {!number} pixmanRegion
   */
  static initInfinite (pixmanRegion) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_init_rect(pixmanRegion, -0x3FFFFFFF, -0x3FFFFFFF, 0x7FFFFFFF, 0x7FFFFFFF)
  }

  /**
   * @param {!number}pixmanRegion
   * @param {!Rect}rect
   */
  static initRect (pixmanRegion, rect) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_init_rect(pixmanRegion, rect.x0, rect.y0, rect.x1 - rect.x0, rect.y1 - rect.y0)
  }

  /**
   * @param {!number}result
   * @param {!number}left
   * @param {!number}right
   */
  static union (result, left, right) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_union(result, left, right)
  }

  /**
   * @param {!number}result
   * @param {!number}left
   * @param {!number}right
   */
  static intersect (result, left, right) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_intersect(result, left, right)
  }

  /**
   * @param {!number}result
   * @param {!number}left
   * @param {!number}x
   * @param {!number}y
   * @param {!number}width
   * @param {!number}height
   */
  static unionRect (result, left, x, y, width, height) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_union_rect(result, left, x, y, width, height)
  }

  /**
   * @param {!number}pixmanRegion
   */
  static destroyPixmanRegion (pixmanRegion) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_fini(pixmanRegion)
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._free(pixmanRegion)
  }

  /**
   * @param {!number}pixmanRegion
   * @return {!Array<Rect>}
   */
  static rectangles (pixmanRegion) {
    const nroRectsPtr = _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._malloc(4) // uint32
    const pixmanBoxPtr = _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_rectangles(pixmanRegion, nroRectsPtr)
    const rectangles = []
    const nroRects = new DataView(_lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"].HEAPU8.buffer, nroRectsPtr, 4).getUint32(0, true)
    const rectangleStructs = new DataView(_lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"].HEAPU8.buffer, pixmanBoxPtr, (4 * 4 * nroRects))
    for (let i = 0; i < nroRects; i++) {
      const x0 = rectangleStructs.getUint32(i * 16, true)
      const y0 = rectangleStructs.getUint32((i * 16) + 4, true)
      const x1 = rectangleStructs.getUint32((i * 16) + 8, true)
      const y1 = rectangleStructs.getUint32((i * 16) + 12, true)
      rectangles.push(_math_Rect__WEBPACK_IMPORTED_MODULE_2__["default"].create(x0, y0, x1, y1))
    }
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._free(nroRectsPtr)

    return rectangles
  }

  /**
   * Use Region.create(..) instead.
   * @private
   * @param {!WlRegionResource}wlRegionResource
   * @param {!number}pixmanRegion
   */
  constructor (wlRegionResource, pixmanRegion) {
    super()
    /**
     * @type {!WlRegionResource}
     * @const
     */
    this.resource = wlRegionResource
    /**
     * @type {!number}
     * @const
     */
    this.pixmanRegion = pixmanRegion
  }

  /**
   *
   * Destroy the region. This will invalidate the object ID.
   *
   *
   * @param {!WlRegionResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *  Add the specified rectangle to the region.
   *
   *
   * @param {!WlRegionResource} resource
   * @param {!number} x undefined
   * @param {!number} y undefined
   * @param {!number} width undefined
   * @param {!number} height undefined
   *
   * @since 1
   * @override
   */
  add (resource, x, y, width, height) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_union_rect(this.pixmanRegion, this.pixmanRegion, x, y, width, height)
  }

  /**
   *
   * Subtract the specified rectangle from the region.
   *
   *
   * @param {!WlRegionResource} resource
   * @param {!number} x undefined
   * @param {!number} y undefined
   * @param {!number} width undefined
   * @param {!number} height undefined
   *
   * @since 1
   * @override
   */
  subtract (resource, x, y, width, height) {
    const deltaPixmanRegion = _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._malloc(20)
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_init_rect(deltaPixmanRegion, x, y, width, height)
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_subtract(this.pixmanRegion, this.pixmanRegion, deltaPixmanRegion)
    Region.destroyPixmanRegion(deltaPixmanRegion)
  }

  /**
   * @param {!number} pixmanRegion
   * @param {!Point}point
   * @return {!boolean}
   */
  static contains (pixmanRegion, point) {
    return _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_contains_point(pixmanRegion, point.x, point.y, null) !== 0
  }

  /**
   * @param {!number} destination
   * @param {!number} source
   */
  static copyTo (destination, source) {
    _lib_libpixman_1__WEBPACK_IMPORTED_MODULE_1__["default"]._pixman_region32_copy(destination, source)
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Region);


/***/ }),
/* 34 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlRegionRequests {

	/**
	 *
	 *	Destroy the region.  This will invalidate the object ID.
	 *      
	 *
	 * @param {WlRegionResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Add the specified rectangle to the region.
	 *      
	 *
	 * @param {WlRegionResource} resource 
	 * @param {number} x region-local x coordinate 
	 * @param {number} y region-local y coordinate 
	 * @param {number} width rectangle width 
	 * @param {number} height rectangle height 
	 *
	 * @since 1
	 *
	 */
	add(resource, x, y, width, height) {}

	/**
	 *
	 *	Subtract the specified rectangle from the region.
	 *      
	 *
	 * @param {WlRegionResource} resource 
	 * @param {number} x region-local x coordinate 
	 * @param {number} y region-local y coordinate 
	 * @param {number} width rectangle width 
	 * @param {number} height rectangle height 
	 *
	 * @since 1
	 *
	 */
	subtract(resource, x, y, width, height) {}
}

module.exports = WlRegionRequests


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
let Module = function (Module) {
  const FS = null
  const ERRNO_CODES = null

  Module = Module || {}

  var Module = typeof Module !== 'undefined' ? Module : {}
  Module['ENVIRONMENT'] = 'WEB'
  let moduleOverrides = {}
  let key
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key]
    }
  }
  Module['arguments'] = []
  Module['thisProgram'] = './this.program'
  Module['quit'] = function (status, toThrow) {
    throw toThrow
  }
  Module['preRun'] = []
  Module['postRun'] = []
  let ENVIRONMENT_IS_WEB = false
  let ENVIRONMENT_IS_WORKER = false
  if (Module['ENVIRONMENT']) {
    if (Module['ENVIRONMENT'] === 'WEB') {
      ENVIRONMENT_IS_WEB = true
    } else if (Module['ENVIRONMENT'] === 'WORKER') {
      ENVIRONMENT_IS_WORKER = true
    } else {
      throw new Error('Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER.')
    }
  } else {
    ENVIRONMENT_IS_WEB = typeof window === 'object'
    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'
  }
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    Module['read'] = function shell_read (url) {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', url, false)
      xhr.send(null)
      return xhr.responseText
    }
    if (ENVIRONMENT_IS_WORKER) {
      Module['readBinary'] = function readBinary (url) {
        const xhr = new XMLHttpRequest()
        xhr.open('GET', url, false)
        xhr.responseType = 'arraybuffer'
        xhr.send(null)
        return new Uint8Array(xhr.response)
      }
    }
    Module['readAsync'] = function readAsync (url, onload, onerror) {
      const xhr = new XMLHttpRequest()
      xhr.open('GET', url, true)
      xhr.responseType = 'arraybuffer'
      xhr.onload = function xhr_onload () {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response)
          return
        }
        onerror()
      }
      xhr.onerror = onerror
      xhr.send(null)
    }
    if (typeof arguments !== 'undefined') {
      Module['arguments'] = arguments
    }
    Module['setWindowTitle'] = function (title) {
      document.title = title
    }
  }
  Module['print'] = console.log.bind(console)
  Module['printErr'] = console.warn.bind(console) || Module['print']
  Module.print = Module['print']
  Module.printErr = Module['printErr']
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key]
    }
  }
  moduleOverrides = undefined
  const STACK_ALIGN = 16

  function staticAlloc (size) {
    assert(!staticSealed)
    const ret = STATICTOP
    STATICTOP = STATICTOP + size + 15 & -16
    return ret
  }

  function alignMemory (size, factor) {
    if (!factor) factor = STACK_ALIGN
    const ret = size = Math.ceil(size / factor) * factor
    return ret
  }

  const functionPointers = new Array(0)
  const GLOBAL_BASE = 1024
  let ABORT = 0
  let EXITSTATUS = 0

  function assert (condition, text) {
    if (!condition) {
      abort('Assertion failed: ' + text)
    }
  }

  function Pointer_stringify (ptr, length) {
    if (length === 0 || !ptr) return ''
    let hasUtf = 0
    let t
    let i = 0
    while (1) {
      t = HEAPU8[ptr + i >> 0]
      hasUtf |= t
      if (t == 0 && !length) break
      i++
      if (length && i == length) break
    }
    if (!length) length = i
    let ret = ''
    if (hasUtf < 128) {
      const MAX_CHUNK = 1024
      let curr
      while (length > 0) {
        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)))
        ret = ret ? ret + curr : curr
        ptr += MAX_CHUNK
        length -= MAX_CHUNK
      }
      return ret
    }
    return UTF8ToString(ptr)
  }

  const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined

  function UTF8ArrayToString (u8Array, idx) {
    let endPtr = idx
    while (u8Array[endPtr]) ++endPtr
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
    } else {
      let u0, u1, u2, u3, u4, u5
      let str = ''
      while (1) {
        u0 = u8Array[idx++]
        if (!u0) return str
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0)
          continue
        }
        u1 = u8Array[idx++] & 63
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1)
          continue
        }
        u2 = u8Array[idx++] & 63
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2
        } else {
          u3 = u8Array[idx++] & 63
          if ((u0 & 248) == 240) {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3
          } else {
            u4 = u8Array[idx++] & 63
            if ((u0 & 252) == 248) {
              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4
            } else {
              u5 = u8Array[idx++] & 63
              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5
            }
          }
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0)
        } else {
          const ch = u0 - 65536
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
        }
      }
    }
  }

  function UTF8ToString (ptr) {
    return UTF8ArrayToString(HEAPU8, ptr)
  }

  function stringToUTF8Array (str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) return 0
    const startIdx = outIdx
    const endIdx = outIdx + maxBytesToWrite - 1
    for (let i = 0; i < str.length; ++i) {
      let u = str.charCodeAt(i)
      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023
      if (u <= 127) {
        if (outIdx >= endIdx) break
        outU8Array[outIdx++] = u
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx) break
        outU8Array[outIdx++] = 192 | u >> 6
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx) break
        outU8Array[outIdx++] = 224 | u >> 12
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 2097151) {
        if (outIdx + 3 >= endIdx) break
        outU8Array[outIdx++] = 240 | u >> 18
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 67108863) {
        if (outIdx + 4 >= endIdx) break
        outU8Array[outIdx++] = 248 | u >> 24
        outU8Array[outIdx++] = 128 | u >> 18 & 63
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else {
        if (outIdx + 5 >= endIdx) break
        outU8Array[outIdx++] = 252 | u >> 30
        outU8Array[outIdx++] = 128 | u >> 24 & 63
        outU8Array[outIdx++] = 128 | u >> 18 & 63
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      }
    }
    outU8Array[outIdx] = 0
    return outIdx - startIdx
  }

  function lengthBytesUTF8 (str) {
    let len = 0
    for (let i = 0; i < str.length; ++i) {
      let u = str.charCodeAt(i)
      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023
      if (u <= 127) {
        ++len
      } else if (u <= 2047) {
        len += 2
      } else if (u <= 65535) {
        len += 3
      } else if (u <= 2097151) {
        len += 4
      } else if (u <= 67108863) {
        len += 5
      } else {
        len += 6
      }
    }
    return len
  }

  const UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined

  function allocateUTF8 (str) {
    const size = lengthBytesUTF8(str) + 1
    const ret = _malloc(size)
    if (ret) stringToUTF8Array(str, HEAP8, ret, size)
    return ret
  }

  const WASM_PAGE_SIZE = 65536
  const ASMJS_PAGE_SIZE = 16777216

  function alignUp (x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple
    }
    return x
  }

  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64

  function updateGlobalBuffer (buf) {
    Module['buffer'] = buffer = buf
  }

  function updateGlobalBufferViews () {
    Module['HEAP8'] = HEAP8 = new Int8Array(buffer)
    Module['HEAP16'] = HEAP16 = new Int16Array(buffer)
    Module['HEAP32'] = HEAP32 = new Int32Array(buffer)
    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer)
    Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer)
    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer)
    Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer)
    Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer)
  }

  var STATIC_BASE, STATICTOP, staticSealed
  let STACK_BASE, STACKTOP, STACK_MAX
  let DYNAMIC_BASE, DYNAMICTOP_PTR
  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0
  staticSealed = false

  function abortOnCannotGrowMemory () {
    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ')
  }

  function enlargeMemory () {
    abortOnCannotGrowMemory()
  }

  const TOTAL_STACK = Module['TOTAL_STACK'] || 5242880
  var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216
  if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')')
  if (Module['buffer']) {
    buffer = Module['buffer']
  } else {
    if (typeof window.WebAssembly === 'object' && typeof window.WebAssembly.Memory === 'function') {
      Module['wasmMemory'] = new window.WebAssembly.Memory({
        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,
        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE
      })
      buffer = Module['wasmMemory'].buffer
    } else {
      buffer = new ArrayBuffer(TOTAL_MEMORY)
    }
    Module['buffer'] = buffer
  }
  updateGlobalBufferViews()

  function getTotalMemory () {
    return TOTAL_MEMORY
  }

  HEAP32[0] = 1668509029
  HEAP16[1] = 25459
  if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw new Error('Runtime error: expected the system to be little-endian!')

  function callRuntimeCallbacks (callbacks) {
    while (callbacks.length > 0) {
      let callback = callbacks.shift()
      if (typeof callback === 'function') {
        callback()
        continue
      }
      let func = callback.func
      if (typeof func === 'number') {
        if (callback.arg === undefined) {
          Module['dynCall_v'](func)
        } else {
          Module['dynCall_vi'](func, callback.arg)
        }
      } else {
        func(callback.arg === undefined ? null : callback.arg)
      }
    }
  }

  const __ATPRERUN__ = []
  const __ATINIT__ = []
  const __ATMAIN__ = []
  const __ATEXIT__ = []
  const __ATPOSTRUN__ = []
  let runtimeInitialized = false
  let runtimeExited = false

  function preRun () {
    if (Module['preRun']) {
      if (typeof Module['preRun'] === 'function') Module['preRun'] = [Module['preRun']]
      while (Module['preRun'].length) {
        addOnPreRun(Module['preRun'].shift())
      }
    }
    callRuntimeCallbacks(__ATPRERUN__)
  }

  function ensureInitRuntime () {
    if (runtimeInitialized) return
    runtimeInitialized = true
    callRuntimeCallbacks(__ATINIT__)
  }

  function preMain () {
    callRuntimeCallbacks(__ATMAIN__)
  }

  function exitRuntime () {
    callRuntimeCallbacks(__ATEXIT__)
    runtimeExited = true
  }

  function postRun () {
    if (Module['postRun']) {
      if (typeof Module['postRun'] === 'function') Module['postRun'] = [Module['postRun']]
      while (Module['postRun'].length) {
        addOnPostRun(Module['postRun'].shift())
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__)
  }

  function addOnPreRun (cb) {
    __ATPRERUN__.unshift(cb)
  }

  function addOnPostRun (cb) {
    __ATPOSTRUN__.unshift(cb)
  }

  function writeAsciiToMemory (str, buffer, dontAddNull) {
    for (let i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i)
    }
    if (!dontAddNull) HEAP8[buffer >> 0] = 0
  }

  const Math_abs = Math.abs
  const Math_cos = Math.cos
  const Math_sin = Math.sin
  const Math_tan = Math.tan
  const Math_acos = Math.acos
  const Math_asin = Math.asin
  const Math_atan = Math.atan
  const Math_atan2 = Math.atan2
  const Math_exp = Math.exp
  const Math_log = Math.log
  const Math_sqrt = Math.sqrt
  const Math_ceil = Math.ceil
  const Math_floor = Math.floor
  const Math_pow = Math.pow
  const Math_imul = Math.imul
  const Math_fround = Math.fround
  const Math_round = Math.round
  const Math_min = Math.min
  const Math_max = Math.max
  const Math_clz32 = Math.clz32
  const Math_trunc = Math.trunc
  let runDependencies = 0
  let runDependencyWatcher = null
  let dependenciesFulfilled = null

  function addRunDependency (id) {
    runDependencies++
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies)
    }
  }

  function removeRunDependency (id) {
    runDependencies--
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies)
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher)
        runDependencyWatcher = null
      }
      if (dependenciesFulfilled) {
        const callback = dependenciesFulfilled
        dependenciesFulfilled = null
        callback()
      }
    }
  }

  Module['preloadedImages'] = {}
  Module['preloadedAudios'] = {}
  const dataURIPrefix = 'data:application/octet-stream;base64,'

  function isDataURI (filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0
  }

  function integrateWasmJS () {
    let wasmTextFile = 'libpixman-1.wast'
    let wasmBinaryFile = 'libpixman-1.wasm'
    let asmjsCodeFile = 'libpixman-1.temp.asm.js'
    if (typeof Module['locateFile'] === 'function') {
      if (!isDataURI(wasmTextFile)) {
        wasmTextFile = Module['locateFile'](wasmTextFile)
      }
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = Module['locateFile'](wasmBinaryFile)
      }
      if (!isDataURI(asmjsCodeFile)) {
        asmjsCodeFile = Module['locateFile'](asmjsCodeFile)
      }
    }
    const wasmPageSize = 64 * 1024
    const info = {
      'global': null,
      'env': null,
      'asm2wasm': {
        'f64-rem': function (x, y) {
          return x % y
        },
        'debugger': function () {
          debugger
        }
      },
      'parent': Module
    }
    let exports = null

    function mergeMemory (newBuffer) {
      const oldBuffer = Module['buffer']
      if (newBuffer.byteLength < oldBuffer.byteLength) {
        Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here')
      }
      const oldView = new Int8Array(oldBuffer)
      const newView = new Int8Array(newBuffer)
      newView.set(oldView)
      updateGlobalBuffer(newBuffer)
      updateGlobalBufferViews()
    }

    function fixImports (imports) {
      return imports
    }

    function getBinary () {
      try {
        if (Module['wasmBinary']) {
          return new Uint8Array(Module['wasmBinary'])
        }
        if (Module['readBinary']) {
          return Module['readBinary'](wasmBinaryFile)
        } else {
          throw new Error('on the web, we need the wasm binary to be preloaded and set on Module[\'wasmBinary\']. emcc.py will do that for you when generating HTML (but not JS)')
        }
      } catch (err) {
        abort(err)
      }
    }

    function getBinaryPromise () {
      if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
        return fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }).then(function (response) {
          if (!response['ok']) {
            throw new Error('failed to load wasm binary file at \'' + wasmBinaryFile + '\'')
          }
          return response['arrayBuffer']()
        }).catch(function () {
          return getBinary()
        })
      }
      return new Promise(function (resolve, reject) {
        resolve(getBinary())
      })
    }

    function doNativeWasm (global, env, providedBuffer) {
      if (typeof window.WebAssembly !== 'object') {
        Module['printErr']('no native wasm support detected')
        return false
      }
      if (!(Module['wasmMemory'] instanceof window.WebAssembly.Memory)) {
        Module['printErr']('no native wasm Memory in use')
        return false
      }
      env['memory'] = Module['wasmMemory']
      info['global'] = {
        'NaN': NaN,
        'Infinity': Infinity
      }
      info['global.Math'] = Math
      info['env'] = env

      function receiveInstance (instance, module) {
        exports = instance.exports
        if (exports.memory) mergeMemory(exports.memory)
        Module['asm'] = exports
        Module['usingWasm'] = true
        removeRunDependency('wasm-instantiate')
      }

      addRunDependency('wasm-instantiate')
      if (Module['instantiateWasm']) {
        try {
          return Module['instantiateWasm'](info, receiveInstance)
        } catch (e) {
          Module['printErr']('Module.instantiateWasm callback failed with error: ' + e)
          return false
        }
      }

      function receiveInstantiatedSource (output) {
        receiveInstance(output['instance'], output['module'])
      }

      function instantiateArrayBuffer (receiver) {
        getBinaryPromise().then(function (binary) {
          return window.WebAssembly.instantiate(binary, info)
        }).then(receiver).catch(function (reason) {
          Module['printErr']('failed to asynchronously prepare wasm: ' + reason)
          abort(reason)
        })
      }

      if (!Module['wasmBinary'] && typeof window.WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {
        window.WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }), info).then(receiveInstantiatedSource).catch(function (reason) {
          Module['printErr']('wasm streaming compile failed: ' + reason)
          Module['printErr']('falling back to ArrayBuffer instantiation')
          instantiateArrayBuffer(receiveInstantiatedSource)
        })
      } else {
        instantiateArrayBuffer(receiveInstantiatedSource)
      }
      return {}
    }

    Module['asmPreload'] = Module['asm']
    const asmjsReallocBuffer = Module['reallocBuffer']
    const wasmReallocBuffer = function (size) {
      const PAGE_MULTIPLE = Module['usingWasm'] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE
      size = alignUp(size, PAGE_MULTIPLE)
      const old = Module['buffer']
      const oldSize = old.byteLength
      if (Module['usingWasm']) {
        try {
          const result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize)
          if (result !== (-1 | 0)) {
            return Module['buffer'] = Module['wasmMemory'].buffer
          } else {
            return null
          }
        } catch (e) {
          return null
        }
      }
    }
    Module['reallocBuffer'] = function (size) {
      if (finalMethod === 'asmjs') {
        return asmjsReallocBuffer(size)
      } else {
        return wasmReallocBuffer(size)
      }
    }
    var finalMethod = ''
    Module['asm'] = function (global, env, providedBuffer) {
      env = fixImports(env)
      if (!env['table']) {
        let TABLE_SIZE = Module['wasmTableSize']
        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024
        const MAX_TABLE_SIZE = Module['wasmMaxTableSize']
        if (typeof window.WebAssembly === 'object' && typeof window.WebAssembly.Table === 'function') {
          if (MAX_TABLE_SIZE !== undefined) {
            env['table'] = new window.WebAssembly.Table({
              'initial': TABLE_SIZE,
              'maximum': MAX_TABLE_SIZE,
              'element': 'anyfunc'
            })
          } else {
            env['table'] = new window.WebAssembly.Table({
              'initial': TABLE_SIZE,
              element: 'anyfunc'
            })
          }
        } else {
          env['table'] = new Array(TABLE_SIZE)
        }
        Module['wasmTable'] = env['table']
      }
      if (!env['memoryBase']) {
        env['memoryBase'] = Module['STATIC_BASE']
      }
      if (!env['tableBase']) {
        env['tableBase'] = 0
      }
      let exports
      exports = doNativeWasm(global, env, providedBuffer)
      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods')
      return exports
    }
  }

  integrateWasmJS()
  STATIC_BASE = GLOBAL_BASE
  STATICTOP = STATIC_BASE + 19344
  __ATINIT__.push({
    func: function () {
      _pixman_constructor()
    }
  })
  const STATIC_BUMP = 19344
  Module['STATIC_BASE'] = STATIC_BASE
  Module['STATIC_BUMP'] = STATIC_BUMP
  STATICTOP += 16

  function ___assert_fail (condition, filename, line, func) {
    abort('Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'])
  }

  const SYSCALLS = {
    varargs: 0,
    get: function (varargs) {
      SYSCALLS.varargs += 4
      const ret = HEAP32[SYSCALLS.varargs - 4 >> 2]
      return ret
    },
    getStr: function () {
      const ret = Pointer_stringify(SYSCALLS.get())
      return ret
    },
    get64: function () {
      const low = SYSCALLS.get(), high = SYSCALLS.get()
      if (low >= 0) assert(high === 0)
      else assert(high === -1)
      return low
    },
    getZero: function () {
      assert(SYSCALLS.get() === 0)
    }
  }

  function ___syscall140 (which, varargs) {
    SYSCALLS.varargs = varargs
    const FS = null
    try {
      const stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(),
        result = SYSCALLS.get(), whence = SYSCALLS.get()
      const offset = offset_low
      FS.llseek(stream, offset, whence)
      HEAP32[result >> 2] = stream.position
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall146 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get()
      let ret = 0
      if (!___syscall146.buffers) {
        ___syscall146.buffers = [null, [], []]
        ___syscall146.printChar = function (stream, curr) {
          const buffer = ___syscall146.buffers[stream]
          assert(buffer)
          if (curr === 0 || curr === 10) {
            (stream === 1 ? Module['print'] : Module['printErr'])(UTF8ArrayToString(buffer, 0))
            buffer.length = 0
          } else {
            buffer.push(curr)
          }
        }
      }
      for (let i = 0; i < iovcnt; i++) {
        const ptr = HEAP32[iov + i * 8 >> 2]
        const len = HEAP32[iov + (i * 8 + 4) >> 2]
        for (let j = 0; j < len; j++) {
          ___syscall146.printChar(stream, HEAPU8[ptr + j])
        }
        ret += len
      }
      return ret
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall54 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall6 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.getStreamFromFD()
      FS.close(stream)
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function _abort () {
    Module['abort']()
  }

  const _environ = STATICTOP
  STATICTOP += 16

  function ___buildEnvironment (env) {
    const MAX_ENV_VALUES = 64
    const TOTAL_ENV_SIZE = 1024
    let poolPtr
    let envPtr
    if (!___buildEnvironment.called) {
      ___buildEnvironment.called = true
      ENV['USER'] = ENV['LOGNAME'] = 'web_user'
      ENV['PATH'] = '/'
      ENV['PWD'] = '/'
      ENV['HOME'] = '/home/web_user'
      ENV['LANG'] = 'C.UTF-8'
      ENV['_'] = Module['thisProgram']
      poolPtr = staticAlloc(TOTAL_ENV_SIZE)
      envPtr = staticAlloc(MAX_ENV_VALUES * 4)
      HEAP32[envPtr >> 2] = poolPtr
      HEAP32[_environ >> 2] = envPtr
    } else {
      envPtr = HEAP32[_environ >> 2]
      poolPtr = HEAP32[envPtr >> 2]
    }
    const strings = []
    let totalSize = 0
    for (let key in env) {
      if (typeof env[key] === 'string') {
        var line = key + '=' + env[key]
        strings.push(line)
        totalSize += line.length
      }
    }
    if (totalSize > TOTAL_ENV_SIZE) {
      throw new Error('Environment size exceeded TOTAL_ENV_SIZE!')
    }
    const ptrSize = 4
    for (let i = 0; i < strings.length; i++) {
      var line = strings[i]
      writeAsciiToMemory(line, poolPtr)
      HEAP32[envPtr + i * ptrSize >> 2] = poolPtr
      poolPtr += line.length + 1
    }
    HEAP32[envPtr + strings.length * ptrSize >> 2] = 0
  }

  var ENV = {}

  function _getenv (name) {
    if (name === 0) return 0
    name = Pointer_stringify(name)
    if (!ENV.hasOwnProperty(name)) return 0
    if (_getenv.ret) _free(_getenv.ret)
    _getenv.ret = allocateUTF8(ENV[name])
    return _getenv.ret
  }

  function _emscripten_memcpy_big (dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest)
    return dest
  }

  function ___setErrNo (value) {
    if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value
    return value
  }

  ___buildEnvironment(ENV)
  DYNAMICTOP_PTR = staticAlloc(4)
  STACK_BASE = STACKTOP = alignMemory(STATICTOP)
  STACK_MAX = STACK_BASE + TOTAL_STACK
  DYNAMIC_BASE = alignMemory(STACK_MAX)
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE
  staticSealed = true
  Module['wasmTableSize'] = 737
  Module['wasmMaxTableSize'] = 737
  Module.asmGlobalArg = {}
  Module.asmLibraryArg = {
    'abort': abort,
    'enlargeMemory': enlargeMemory,
    'getTotalMemory': getTotalMemory,
    'abortOnCannotGrowMemory': abortOnCannotGrowMemory,
    '___assert_fail': ___assert_fail,
    '___setErrNo': ___setErrNo,
    '___syscall140': ___syscall140,
    '___syscall146': ___syscall146,
    '___syscall54': ___syscall54,
    '___syscall6': ___syscall6,
    '_abort': _abort,
    '_emscripten_memcpy_big': _emscripten_memcpy_big,
    '_getenv': _getenv,
    'DYNAMICTOP_PTR': DYNAMICTOP_PTR,
    'STACKTOP': STACKTOP
  }
  const asm = Module['asm'](Module.asmGlobalArg, Module.asmLibraryArg, buffer)
  Module['asm'] = asm
  var _free = Module['_free'] = function () {
    return Module['asm']['_free'].apply(null, arguments)
  }
  var _malloc = Module['_malloc'] = function () {
    return Module['asm']['_malloc'].apply(null, arguments)
  }
  var _pixman_constructor = Module['_pixman_constructor'] = function () {
    return Module['asm']['_pixman_constructor'].apply(null, arguments)
  }
  const _pixman_region32_clear = Module['_pixman_region32_clear'] = function () {
    return Module['asm']['_pixman_region32_clear'].apply(null, arguments)
  }
  const _pixman_region32_contains_point = Module['_pixman_region32_contains_point'] = function () {
    return Module['asm']['_pixman_region32_contains_point'].apply(null, arguments)
  }
  const _pixman_region32_copy = Module['_pixman_region32_copy'] = function () {
    return Module['asm']['_pixman_region32_copy'].apply(null, arguments)
  }
  const _pixman_region32_fini = Module['_pixman_region32_fini'] = function () {
    return Module['asm']['_pixman_region32_fini'].apply(null, arguments)
  }
  const _pixman_region32_init = Module['_pixman_region32_init'] = function () {
    return Module['asm']['_pixman_region32_init'].apply(null, arguments)
  }
  const _pixman_region32_intersect = Module['_pixman_region32_intersect'] = function () {
    return Module['asm']['_pixman_region32_intersect'].apply(null, arguments)
  }
  const _pixman_region32_init_rect = Module['_pixman_region32_init_rect'] = function () {
    return Module['asm']['_pixman_region32_init_rect'].apply(null, arguments)
  }
  const _pixman_region32_rectangles = Module['_pixman_region32_rectangles'] = function () {
    return Module['asm']['_pixman_region32_rectangles'].apply(null, arguments)
  }
  const _pixman_region32_subtract = Module['_pixman_region32_subtract'] = function () {
    return Module['asm']['_pixman_region32_subtract'].apply(null, arguments)
  }
  const _pixman_region32_union = Module['_pixman_region32_union'] = function () {
    return Module['asm']['_pixman_region32_union'].apply(null, arguments)
  }
  const _pixman_region32_union_rect = Module['_pixman_region32_union_rect'] = function () {
    return Module['asm']['_pixman_region32_union_rect'].apply(null, arguments)
  }
  const dynCall_vi = Module['dynCall_vi'] = function () {
    return Module['asm']['dynCall_vi'].apply(null, arguments)
  }
  Module['asm'] = asm
  Module['then'] = function (func) {
    if (Module['calledRun']) {
      func(Module)
    } else {
      const old = Module['onRuntimeInitialized']
      Module['onRuntimeInitialized'] = function () {
        if (old) old()
        func(Module)
      }
    }
    return Module
  }

  function ExitStatus (status) {
    this.name = 'ExitStatus'
    this.message = 'Program terminated with exit(' + status + ')'
    this.status = status
  }

  ExitStatus.prototype = new Error()
  ExitStatus.prototype.constructor = ExitStatus
  let initialStackTop
  dependenciesFulfilled = function runCaller () {
    if (!Module['calledRun']) run()
    if (!Module['calledRun']) dependenciesFulfilled = runCaller
  }

  function run (args) {
    args = args || Module['arguments']
    if (runDependencies > 0) {
      return
    }
    preRun()
    if (runDependencies > 0) return
    if (Module['calledRun']) return

    function doRun () {
      if (Module['calledRun']) return
      Module['calledRun'] = true
      if (ABORT) return
      ensureInitRuntime()
      preMain()
      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']()
      postRun()
    }

    if (Module['setStatus']) {
      Module['setStatus']('Running...')
      setTimeout(function () {
        setTimeout(function () {
          Module['setStatus']('')
        }, 1)
        doRun()
      }, 1)
    } else {
      doRun()
    }
  }

  Module['run'] = run

  function exit (status, implicit) {
    if (implicit && Module['noExitRuntime'] && status === 0) {
      return
    }
    if (Module['noExitRuntime']) {} else {
      ABORT = true
      EXITSTATUS = status
      STACKTOP = initialStackTop
      exitRuntime()
      if (Module['onExit']) Module['onExit'](status)
    }
    Module['quit'](status, new ExitStatus(status))
  }

  Module['exit'] = exit

  function abort (what) {
    if (Module['onAbort']) {
      Module['onAbort'](what)
    }
    if (what !== undefined) {
      Module.print(what)
      Module.printErr(what)
      what = JSON.stringify(what)
    } else {
      what = ''
    }
    ABORT = true
    EXITSTATUS = 1
    throw new Error('abort(' + what + '). Build with -s ASSERTIONS=1 for more info.')
  }

  Module['abort'] = abort
  if (Module['preInit']) {
    if (typeof Module['preInit'] === 'function') Module['preInit'] = [Module['preInit']]
    while (Module['preInit'].length > 0) {
      Module['preInit'].pop()()
    }
  }
  Module['noExitRuntime'] = true
  run()

  return Module
}
/* harmony default export */ __webpack_exports__["default"] = (Module());


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderer; });
/* harmony import */ var _JpegRenderState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _JpegAlphaSurfaceShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _EncodingOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _JpegSurfaceShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _H264RenderState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/* harmony import */ var _YUVASurfaceShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49);
/* harmony import */ var _YUVSurfaceShader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);










class Renderer {
  /**
   * @returns {Renderer}
   */
  static create () {
    // create offscreen gl context
    const canvas = /** @type{HTMLCanvasElement} */document.createElement('canvas')
    const gl = canvas.getContext('webgl2', {
      antialias: false,
      depth: false,
      alpha: true,
      preserveDrawingBuffer: false
    })
    if (!gl) {
      throw new Error('This browser doesn\'t support WebGL2!')
    }

    gl.clearColor(0, 0, 0, 0)
    const jpegAlphaSurfaceShader = _JpegAlphaSurfaceShader__WEBPACK_IMPORTED_MODULE_1__["default"].create(gl)
    const jpegSurfaceShader = _JpegSurfaceShader__WEBPACK_IMPORTED_MODULE_3__["default"].create(gl)

    const yuvaSurfaceShader = _YUVASurfaceShader__WEBPACK_IMPORTED_MODULE_5__["default"].create(gl)
    const yuvSurfaceShader = _YUVSurfaceShader__WEBPACK_IMPORTED_MODULE_6__["default"].create(gl)

    return new Renderer(gl, jpegAlphaSurfaceShader, jpegSurfaceShader, yuvaSurfaceShader, yuvSurfaceShader, canvas)
  }

  /**
   * @name RenderFrame
   * @type{Promise<number>}
   * @property {Function} fire
   * @property {Function} then
   */
  /**
   * @return {RenderFrame}
   */
  static createRenderFrame () {
    let animationResolve = null
    const animationPromise = new Promise((resolve) => {
      animationResolve = resolve
    })
    animationPromise._animationResolve = animationResolve
    animationPromise.fire = () => {
      window.requestAnimationFrame((time) => {
        animationPromise._animationResolve(time)
      })
    }
    return animationPromise
  }

  /**
   * Use Renderer.create(..) instead.
   * @private
   * @param {WebGLRenderingContext}gl
   * @param {JpegAlphaSurfaceShader}jpegAlphaSurfaceShader
   * @param {JpegSurfaceShader}jpegSurfaceShader
   * @param {YUVASurfaceShader}yuvaSurfaceShader
   * @param {YUVSurfaceShader}yuvSurfaceShader
   * @param {HTMLCanvasElement}canvas
   */
  constructor (gl, jpegAlphaSurfaceShader, jpegSurfaceShader, yuvaSurfaceShader, yuvSurfaceShader, canvas) {
    /**
     * @type {WebGLRenderingContext}
     */
    this._gl = gl
    /**
     * @type {JpegAlphaSurfaceShader}
     * @private
     */
    this._jpegAlphaSurfaceShader = jpegAlphaSurfaceShader
    /**
     * @type {JpegSurfaceShader}
     * @private
     */
    this._jpegSurfaceShader = jpegSurfaceShader
    /**
     * @type {YUVASurfaceShader}
     * @private
     */
    this._yuvaSurfaceShader = yuvaSurfaceShader
    /**
     * @type {YUVSurfaceShader}
     * @private
     */
    this._yuvSurfaceShader = yuvSurfaceShader
    /**
     * @type {HTMLCanvasElement}
     * @private
     */
    this._canvas = canvas

    this._emptyImage = new window.Image(0, 0)
    this._emptyImage.src = '//:0'

    this._viewDrawTotal = 0
    this._textureUpdateTotal = 0
    this._shaderInvocationTotal = 0
    this._count = 0
  }

  /**
   * @param {Surface}surface
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   */
  async render (surface, newState) {
    const views = surface.views
    const bufferContents = newState.bufferContents

    if (bufferContents) {
      await this._draw(bufferContents, surface, views)
    } else {
      views.forEach((view) => { view.draw(this._emptyImage) })
    }
  }

  /**
   * @param {EncodedFrame}encodedFrame
   * @param {Surface}surface
   * @param {Array<View>}views
   * @return {Promise<void>}
   * @private
   */
  async ['image/jpeg'] (encodedFrame, surface, views) {
    let renderState = surface.renderState
    if (!(renderState instanceof _JpegRenderState__WEBPACK_IMPORTED_MODULE_0__["default"])) {
      if (renderState) {
        renderState.destroy()
      }
      renderState = _JpegRenderState__WEBPACK_IMPORTED_MODULE_0__["default"].create(this._gl)
      surface.renderState = renderState
    }
    const jpegRenderState = /** @type JpegRenderState */ renderState

    const {
      /** @type {number} */ w: frameWidth, /** @type {number} */ h: frameHeight
    } = encodedFrame.size

    // We update the texture with the fragments as early as possible, this is to avoid gl state mixup with other
    // calls to _draw() while we're in await. If we were to do this call later, this.canvas will have state specifically
    // for our _draw() call, yet because we are in (a late) await, another call might adjust our canvas, which results
    // in bad draws/flashing/flickering/...
    let start = Date.now()
    await jpegRenderState.update(encodedFrame)
    this._textureUpdateTotal += Date.now() - start
    false && console.log('updating textures avg', this._textureUpdateTotal / this._count)

    if (_EncodingOptions__WEBPACK_IMPORTED_MODULE_2__["default"].splitAlpha(encodedFrame.encodingOptions)) {
      // Image is in jpeg format with a separate alpha channel, shade & decode alpha & opaque fragments together using webgl.

      this._jpegAlphaSurfaceShader.use()
      this._jpegAlphaSurfaceShader.setTexture(jpegRenderState.opaqueTexture, jpegRenderState.alphaTexture)

      start = Date.now()
      const canvasSizeChanged = (this._canvas.width !== frameWidth) || (this._canvas.height !== frameHeight)
      if (canvasSizeChanged) {
        this._canvas.width = frameWidth
        this._canvas.height = frameHeight
        this._jpegAlphaSurfaceShader.updatePerspective(encodedFrame.size)
      }

      // TODO we could try to optimize and only shade the fragments of the texture that were updated
      this._jpegAlphaSurfaceShader.draw(encodedFrame.size, canvasSizeChanged)
      this._jpegAlphaSurfaceShader.release()
      this._shaderInvocationTotal += (Date.now() - start)
      false && console.log('shader invocation avg', this._shaderInvocationTotal / this._count)

      start = Date.now()
      const image = await window.createImageBitmap(this._canvas)
      views.forEach((view) => { view.draw(image) })
      this._viewDrawTotal += Date.now() - start
      false && console.log('drawing views avg', this._viewDrawTotal / this._count)
    } else {
      // Image is in jpeg format with no separate alpha channel, shade & decode opaque fragments using webgl.
      this._jpegSurfaceShader.use()
      this._jpegSurfaceShader.setTexture(jpegRenderState.opaqueTexture)

      const canvasSizeChanged = (this._canvas.width !== frameWidth) || (this._canvas.height !== frameHeight)
      if (canvasSizeChanged) {
        this._canvas.width = frameWidth
        this._canvas.height = frameHeight
        this._jpegSurfaceShader.updatePerspective(encodedFrame.size)
      }

      this._jpegSurfaceShader.draw(encodedFrame.size, canvasSizeChanged)
      this._jpegSurfaceShader.release()
      views.forEach((view) => { view.draw(this._canvas) })
    }
  }

  /**
   * @param {EncodedFrame}encodedFrame
   * @param {Surface}surface
   * @param {Array<View>}views
   * @return {Promise<void>}
   * @private
   */
  async ['image/png'] (encodedFrame, surface, views) {
    const fullFrame = _EncodingOptions__WEBPACK_IMPORTED_MODULE_2__["default"].fullFrame(encodedFrame.encodingOptions)
    const splitAlpha = _EncodingOptions__WEBPACK_IMPORTED_MODULE_2__["default"].splitAlpha(encodedFrame.encodingOptions)

    if (fullFrame && !splitAlpha) {
      // Full frame without a separate alpha. Let the browser do all the drawing.
      const frame = encodedFrame.fragments[0]
      const opaqueImageBlob = new Blob([frame.opaque], {'type': 'image/png'})
      const opaqueImageBitmap = await createImageBitmap(opaqueImageBlob, 0, 0, frame.geo.width, frame.geo.height)
      views.forEach((view) => { view.draw(opaqueImageBitmap) })
    } else {
      // we don't support/care about fragmented pngs (and definitely not with a separate alpha channel as png has it internal)
      throw new Error(`Unsupported buffer. Encoding type: ${encodedFrame.encodingType}, full frame:${fullFrame}, split alpha: ${splitAlpha}`)
    }
  }

  /**
   * @param {EncodedFrame}encodedFrame
   * @param {Surface}surface
   * @param {Array<View>}views
   * @return {Promise<void>}
   * @private
   */
  async ['video/h264'] (encodedFrame, surface, views) {
    let renderState = surface.renderState
    if (!(renderState instanceof _H264RenderState__WEBPACK_IMPORTED_MODULE_4__["default"])) {
      if (renderState) {
        renderState.destroy()
      }
      renderState = _H264RenderState__WEBPACK_IMPORTED_MODULE_4__["default"].create(this._gl)
      surface.renderState = renderState
    }
    const h264RenderState = /** @type H264RenderState */ renderState

    const {/** @type {number} */ w: frameWidth, /** @type {number} */ h: frameHeight} = encodedFrame.size

    // We update the texture with the fragments as early as possible, this is to avoid gl state mixup with other
    // calls to _draw() while we're in await. If we were to do this call later, this.canvas will have state specifically
    // for our _draw() call, yet because we are in (a late) await, another call might adjust our canvas, which results
    // in bad draws/flashing/flickering/...
    let start = Date.now()
    await h264RenderState.update(encodedFrame)
    this._textureUpdateTotal += Date.now() - start
    false && console.log('updating textures avg', this._textureUpdateTotal / this._count)

    if (_EncodingOptions__WEBPACK_IMPORTED_MODULE_2__["default"].splitAlpha(encodedFrame.encodingOptions)) {
      // Image is in h264 format with a separate alpha channel, color convert alpha & yuv fragments to rgba using webgl.
      this._yuvaSurfaceShader.use()
      this._yuvaSurfaceShader.setTexture(h264RenderState.yTexture, h264RenderState.uTexture, h264RenderState.vTexture, h264RenderState.alphaTexture)

      start = Date.now()
      const canvasSizeChanged = (this._canvas.width !== frameWidth) || (this._canvas.height !== frameHeight)
      if (canvasSizeChanged) {
        this._canvas.width = frameWidth
        this._canvas.height = frameHeight
        this._yuvaSurfaceShader.updatePerspective(encodedFrame.size)
      }

      // TODO we could try to optimize and only shade the fragments of the texture that were updated
      this._yuvaSurfaceShader.draw(encodedFrame.size, canvasSizeChanged)
      this._yuvaSurfaceShader.release()
      this._shaderInvocationTotal += (Date.now() - start)
      false && console.log('shader invocation avg', this._shaderInvocationTotal / this._count)

      start = Date.now()
      const image = await window.createImageBitmap(this._canvas)
      views.forEach((view) => { view.draw(image) })
      this._viewDrawTotal += Date.now() - start
      false && console.log('drawing views avg', this._viewDrawTotal / this._count)
    } else {
      // Image is in h264 format with no separate alpha channel, color convert yuv fragments to rgb using webgl.
      this._yuvSurfaceShader.use()
      this._yuvSurfaceShader.setTexture(h264RenderState.yTexture, h264RenderState.uTexture, h264RenderState.vTexture)

      const canvasSizeChanged = (this._canvas.width !== frameWidth) || (this._canvas.height !== frameHeight)
      if (canvasSizeChanged) {
        this._canvas.width = frameWidth
        this._canvas.height = frameHeight
        this._yuvSurfaceShader.updatePerspective(encodedFrame.size)
      }

      this._yuvSurfaceShader.draw(encodedFrame.size, canvasSizeChanged)
      this._yuvSurfaceShader.release()

      views.forEach((view) => { view.draw(this._canvas) })
    }
  }

  /**
   * @param {EncodedFrame}bufferContents
   * @param {Surface}surface
   * @param {Array<View>}views
   * @private
   */
  async _draw (bufferContents, surface, views) {
    this._count++
    // invokes mime type named drawing methods
    await this[bufferContents.encodingType](bufferContents, surface, views)
  }
}
/**
 * @type {Promise<number>}
 * @private
 */
Renderer._animationPromise = null
/**
 * @type {Function}
 * @private
 */
Renderer._animationResolve = null


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JpegRenderState; });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _RenderState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _EncodingOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);







/**
 * @implements RenderState
 */
class JpegRenderState extends _RenderState__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {!WebGLRenderingContext}gl
   * @returns {!JpegRenderState}
   */
  static create (gl) {
    return new JpegRenderState(gl)
  }

  /**
   * Use ViewState.create(..) instead.
   * @param {!WebGLRenderingContext}gl
   * @private
   */
  constructor (gl) {
    super()
    /**
     * @type {!WebGLRenderingContext}
     */
    this.gl = gl
    /**
     * @type {!Texture}
     */
    this.opaqueTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.RGBA)
    /**
     * @type {!Texture}
     */
    this.alphaTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.RGBA)
    /**
     * @type {!Size}
     */
    this.size = _Size__WEBPACK_IMPORTED_MODULE_1__["default"].create(0, 0)
  }

  /**
   * @param {EncodedFrame}encodedFrame
   * @return {Promise<void>}
   * @override
   */
  async update (encodedFrame) {
    const hasAlpha = _EncodingOptions__WEBPACK_IMPORTED_MODULE_3__["default"].splitAlpha(encodedFrame.encodingOptions)
    const sizeChanged = !this.size.equals(encodedFrame.size)
    if (sizeChanged) {
      this.size = encodedFrame.size
    }

    await Promise.all(encodedFrame.fragments.map(async (fragment) => {
      const opaqueImageBitmapPromise = window.createImageBitmap(new window.Blob([fragment.opaque], {'type': 'image/jpeg'}), 0, 0, fragment.geo.width, fragment.geo.height)
      let alphaImageBitmapPromise = null
      if (hasAlpha) {
        alphaImageBitmapPromise = window.createImageBitmap(new window.Blob([fragment.alpha], {'type': 'image/jpeg'}), 0, 0, fragment.geo.width, fragment.geo.height)
      }

      if (sizeChanged) {
        this.opaqueTexture.image2dElement(await opaqueImageBitmapPromise)
        if (hasAlpha) {
          this.alphaTexture.image2dElement(await alphaImageBitmapPromise)
        }
      } else {
        this.opaqueTexture.subImage2dElement(await opaqueImageBitmapPromise, fragment.geo)
        if (hasAlpha) {
          this.alphaTexture.subImage2dElement(await alphaImageBitmapPromise, fragment.geo)
        }
      }
    }))
  }

  /**
   * @override
   */
  destroy () {
    this.opaqueTexture.delete()
    this.alphaTexture.delete()
  }
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });


/**
 * Represents a WebGL texture object.
 */
class Texture {
  /**
   * @param {!WebGLRenderingContext}gl
   * @param {!number}format
   * @return {!Texture}
   */
  static create (gl, format) {
    const texture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, texture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    gl.bindTexture(gl.TEXTURE_2D, null)
    return new Texture(gl, format, texture)
  }

  /**
   * Use Texture.create(..) instead.
   * @param {WebGLRenderingContext}gl
   * @param {number}format
   * @param {WebGLTexture}texture
   * @private
   */
  constructor (gl, format, texture) {
    /**
     * @type {WebGLRenderingContext}
     */
    this.gl = gl
    /**
     * @type {WebGLTexture}
     */
    this.texture = texture
    /**
     * @type {number}
     */
    this.format = format
  }

  /**
   * @param {!Uint8Array}buffer
   * @param {!Rect}geo
   * @param {number}stride
   */
  subImage2dBuffer (buffer, geo, stride) {
    const gl = this.gl

    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, stride)
    gl.bindTexture(gl.TEXTURE_2D, this.texture)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, geo.x0, geo.y0, geo.width, geo.height, this.format, gl.UNSIGNED_BYTE, buffer)
    gl.bindTexture(gl.TEXTURE_2D, null)
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, 0)
  }

  /**
   * @param {!Uint8Array}buffer
   * @param {number}width
   * @param {number}height
   * @param {number}stride
   */
  image2dBuffer (buffer, width, height, stride) {
    const gl = this.gl

    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, stride)
    gl.bindTexture(gl.TEXTURE_2D, this.texture)
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, buffer)
    gl.bindTexture(gl.TEXTURE_2D, null)
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, 0)
  }

  /**
   * @param {ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement}imageElement
   * @param {!Rect}geo
   */
  subImage2dElement (imageElement, geo) {
    const gl = this.gl

    gl.bindTexture(gl.TEXTURE_2D, this.texture)
    gl.texSubImage2D(gl.TEXTURE_2D, 0, geo.x0, geo.y0, this.format, gl.UNSIGNED_BYTE, imageElement)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }

  /**
   * @param {ImageBitmap | ImageData | HTMLVideoElement | HTMLImageElement | HTMLCanvasElement}imageElement
   */
  image2dElement (imageElement) {
    const gl = this.gl

    gl.bindTexture(gl.TEXTURE_2D, this.texture)
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, imageElement)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }

  delete () {
    this.gl.deleteTexture(this.texture)
    this.texture = null
  }
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderState; });
/**
 * @interface
 */
class RenderState {
  /**
   * @param {EncodedFrame}encodedFrame
   */
  update (encodedFrame) {}

  destroy () {}
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


class EncodingOptions {
  /**
   * @param {number}encodingOptions
   * return {boolean}
   */
  static splitAlpha (encodingOptions) {
    return (encodingOptions & EncodingOptions._ALPHA) !== 0
  }

  /**
   * @param encodingOptions
   * @return {boolean}
   */
  static fullFrame (encodingOptions) {
    return (encodingOptions & EncodingOptions._FULL_FRAME) !== 0
  }
}

/**
 * @type {number}
 * @private
 */
EncodingOptions._ALPHA = (1 << 0)
/**
 * @type {number}
 * @private
 */
EncodingOptions._FULL_FRAME = (1 << 1)

/* harmony default export */ __webpack_exports__["default"] = (EncodingOptions);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JpegAlphaSurfaceShader; });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _ShaderSources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);






class JpegAlphaSurfaceShader {
  /**
   *
   * @param {WebGLRenderingContext} gl
   * @returns {JpegAlphaSurfaceShader}
   */
  static create (gl) {
    const program = this._initShaders(gl)
    const shaderArgs = this._initShaderArgs(gl, program)
    const vertexBuffer = this._initBuffers(gl)

    return new JpegAlphaSurfaceShader(gl, vertexBuffer, shaderArgs, program)
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @return {Program}
   * @private
   */
  static _initShaders (gl) {
    const program = new _Program__WEBPACK_IMPORTED_MODULE_0__["default"](gl)
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["vertexQuad"]))
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["fragmentJpegAlpha"]))
    program.link()
    program.use()

    return program
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @param {Program}program
   * @return {{opaqueTexture:WebGLUniformLocation}}
   * @private
   */
  static _initShaderArgs (gl, program) {
    // find shader arguments
    const shaderArgs = {}
    shaderArgs.opaqueTexture = program.getUniformLocation('opaqueTexture')
    shaderArgs.alphaTexture = program.getUniformLocation('alphaTexture')

    shaderArgs.u_projection = program.getUniformLocation('u_projection')

    shaderArgs.a_position = program.getAttributeLocation('a_position')
    gl.enableVertexAttribArray(shaderArgs.a_position)
    shaderArgs.a_texCoord = program.getAttributeLocation('a_texCoord')
    gl.enableVertexAttribArray(shaderArgs.a_texCoord)

    return shaderArgs
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @return {WebGLBuffer}
   * @private
   */
  static _initBuffers (gl) {
    // Create vertex buffer object.
    return gl.createBuffer()
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @param {WebGLBuffer}vertexBuffer
   * @param shaderArgs
   * @param program
   */
  constructor (gl, vertexBuffer, shaderArgs, program) {
    this.gl = gl
    this.vertexBuffer = vertexBuffer
    this.shaderArgs = shaderArgs
    this.program = program
  }

  /**
   * @param {Texture} textureOpaque
   * @param {Texture} textureAlpha
   */
  setTexture (textureOpaque, textureAlpha) {
    const gl = this.gl

    gl.uniform1i(this.shaderArgs.opaqueTexture, 0)
    gl.uniform1i(this.shaderArgs.alphaTexture, 1)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, textureOpaque.texture)
    gl.activeTexture(gl.TEXTURE1)
    gl.bindTexture(gl.TEXTURE_2D, textureAlpha.texture)
  }

  use () {
    this.program.use()
  }

  release () {
    const gl = this.gl
    gl.useProgram(null)
  }

  /**
   * @param {!Size}viewportSize
   */
  updatePerspective (viewportSize) {
    const gl = this.gl
    const {w, h} = viewportSize
    gl.viewport(0, 0, w, h)
    this.program.setUniformM4(this.shaderArgs.u_projection, [
      2.0 / w, 0, 0, 0,
      0, 2.0 / -h, 0, 0,
      0, 0, 1, 0,
      -1, 1, 0, 1
    ])
    gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
    gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
      // top left:
      0, 0, 0, 0,
      // top right:
      w, 0, 1, 0,
      // bottom right:
      w, h, 1, 1,
      // bottom right:
      w, h, 1, 1,
      // bottom left:
      0, h, 0, 1,
      // top left:
      0, 0, 0, 0
    ]), this.gl.DYNAMIC_DRAW)
    gl.vertexAttribPointer(this.shaderArgs.a_position, 2, gl.FLOAT, false, 16, 0)
    gl.vertexAttribPointer(this.shaderArgs.a_texCoord, 2, gl.FLOAT, false, 16, 8)
  }

  draw () {
    const gl = this.gl
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
    gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 6)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Program; });


class Program {
  /**
   * @param {WebGLRenderingContext}gl
   */
  constructor (gl) {
    this.gl = gl
    this.program = this.gl.createProgram()
  }

  /**
   * @param {WebGLShader}shader
   */
  attach (shader) {
    this.gl.attachShader(this.program, shader)
  }

  link () {
    this.gl.linkProgram(this.program)
    // If creating the shader program failed, alert.
    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Unable to initialize the shader program.')
    }
  }

  use () {
    this.gl.useProgram(this.program)
  }

  /**
   * @param {string}name
   * @return {number}
   */
  getAttributeLocation (name) {
    return this.gl.getAttribLocation(this.program, name)
  }

  /**
   * @param {string}name
   * @return {WebGLUniformLocation | null}
   */
  getUniformLocation (name) {
    return this.gl.getUniformLocation(this.program, name)
  }

  /**
   * @param {WebGLUniformLocation}uniformLocation
   * @param {Array<number>}array
   */
  setUniformM4 (uniformLocation, array) {
    this.gl.uniformMatrix4fv(uniformLocation, false, array)
  }
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderCompiler; });


/**
 * Represents a WebGL shader object and provides a mechanism to load shaders from HTML
 * script tags.
 */

class ShaderCompiler {
  /**
   * @param {WebGLRenderingContext}gl
   * @param {{type: string, source: string}}script
   * @return {WebGLShader}
   */
  static compile (gl, script) {
    let shader
    // Now figure out what type of shader script we have, based on its MIME type.
    if (script.type === 'x-shader/x-fragment') {
      shader = gl.createShader(gl.FRAGMENT_SHADER)
    } else if (script.type === 'x-shader/x-vertex') {
      shader = gl.createShader(gl.VERTEX_SHADER)
    } else {
      throw new Error('Unknown shader type: ' + script.type)
    }

    // Send the source to the shader object.
    gl.shaderSource(shader, script.source)

    // Compile the shader program.
    gl.compileShader(shader)

    // See if it compiled successfully.
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw new Error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader))
    }

    return shader
  }
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertexQuad", function() { return vertexQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentJpegAlpha", function() { return fragmentJpegAlpha; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentJpeg", function() { return fragmentJpeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentYUVA", function() { return fragmentYUVA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragmentYUV", function() { return fragmentYUV; });


/**
 * @type {{type: string, source: string}}
 */
const vertexQuad = {
  type: 'x-shader/x-vertex',
  source: `
  precision mediump float;

  uniform mat4 u_projection;
  attribute vec2 a_position;
  attribute vec2 a_texCoord;
  varying vec2 v_texCoord;
  void main(){
      v_texCoord = a_texCoord;
      gl_Position = u_projection * vec4(a_position, 0.0, 1.0);
  }
`
}

/**
 * @type {{type: string, source: string}}
 */
const fragmentJpegAlpha = {
  type: 'x-shader/x-fragment',
  source: `
  precision mediump float;
  
  varying vec2 v_texCoord;
  
  uniform sampler2D opaqueTexture;
  uniform sampler2D alphaTexture;

  void main(void) {
   vec4 pix = texture2D(opaqueTexture, v_texCoord);
   vec4 alphaPix = texture2D(alphaTexture, v_texCoord);
   pix.a = alphaPix.r * 1.1644 - 0.07312;
   pix.r = pix.r * 1.1644 - 0.07312;
   pix.g = pix.g * 1.1644 - 0.07312;
   pix.b = pix.b * 1.1644 - 0.07312;
   gl_FragColor = pix;
  }
`
}

/**
 * @type {{type: string, source: string}}
 */
const fragmentJpeg = {
  type: 'x-shader/x-fragment',
  source: `
  precision mediump float;
  
  varying vec2 v_texCoord;
  
  uniform sampler2D opaqueTexture;

  void main(void) {
   gl_FragColor = texture2D(opaqueTexture, v_texCoord);
  }
`
}

/**
 * @type {{type: string, source: string}}
 */
const fragmentYUVA = {
  type: 'x-shader/x-fragment',
  source: `
  precision lowp float;
  
  varying vec2 v_texCoord;
  
  uniform sampler2D yTexture;
  uniform sampler2D uTexture;
  uniform sampler2D vTexture;
  uniform sampler2D alphaYTexture;
    
  const mat4 YUV2RGB = mat4
  (
   1.1643828125,             0, 1.59602734375, -.87078515625,
   1.1643828125, -.39176171875,    -.81296875,     .52959375,
   1.1643828125,   2.017234375,             0,  -1.081390625,
              0,             0,             0,             1
  );

  void main(void) {
   vec4 pix = vec4(texture2D(yTexture,  v_texCoord).x, texture2D(uTexture, v_texCoord).x, texture2D(vTexture, v_texCoord).x, 1) * YUV2RGB;
   pix.w = (vec4(texture2D(alphaYTexture,  v_texCoord).x, 0.5019607843137255, 0.5019607843137255, 1) * YUV2RGB).x;
   gl_FragColor = pix;
  }
`
}

/**
 * @type {{type: string, source: string}}
 */
const fragmentYUV = {
  type: 'x-shader/x-fragment',
  source: `
  precision lowp float;
  
  varying vec2 v_texCoord;
  
  uniform sampler2D yTexture;
  uniform sampler2D uTexture;
  uniform sampler2D vTexture;
    
  const mat4 YUV2RGB = mat4
  (
   1.1643828125,             0, 1.59602734375, -.87078515625,
   1.1643828125, -.39176171875,    -.81296875,     .52959375,
   1.1643828125,   2.017234375,             0,  -1.081390625,
              0,             0,             0,             1
  );

  void main(void) {
   vec4 pix = vec4(texture2D(yTexture,  v_texCoord).x, texture2D(uTexture, v_texCoord).x, texture2D(vTexture, v_texCoord).x, 1) * YUV2RGB;
   pix.w = 1.0;
   // pix.w = 1.0;
   gl_FragColor = pix;
  }
`
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JpegSurfaceShader; });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _ShaderSources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);






class JpegSurfaceShader {
  /**
   *
   * @param {WebGLRenderingContext} gl
   * @returns {JpegSurfaceShader}
   */
  static create (gl) {
    const program = this._initShaders(gl)
    const shaderArgs = this._initShaderArgs(gl, program)
    const vertexBuffer = this._initBuffers(gl)

    return new JpegSurfaceShader(gl, vertexBuffer, shaderArgs, program)
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @return {Program}
   * @private
   */
  static _initShaders (gl) {
    const program = new _Program__WEBPACK_IMPORTED_MODULE_0__["default"](gl)
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["vertexQuad"]))
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["fragmentJpeg"]))
    program.link()
    program.use()

    return program
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @param {Program}program
   * @return {{opaqueTexture:WebGLUniformLocation}}
   * @private
   */
  static _initShaderArgs (gl, program) {
    // find shader arguments
    const shaderArgs = {}
    shaderArgs.opaqueTexture = program.getUniformLocation('opaqueTexture')

    shaderArgs.u_projection = program.getUniformLocation('u_projection')

    shaderArgs.a_position = program.getAttributeLocation('a_position')
    gl.enableVertexAttribArray(shaderArgs.a_position)
    shaderArgs.a_texCoord = program.getAttributeLocation('a_texCoord')
    gl.enableVertexAttribArray(shaderArgs.a_texCoord)

    return shaderArgs
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @return {WebGLBuffer}
   * @private
   */
  static _initBuffers (gl) {
    // Create vertex buffer object.
    return gl.createBuffer()
  }

  /**
   * @param {WebGLRenderingContext}gl
   * @param {WebGLBuffer}vertexBuffer
   * @param shaderArgs
   * @param program
   */
  constructor (gl, vertexBuffer, shaderArgs, program) {
    this.gl = gl
    this.vertexBuffer = vertexBuffer
    this.shaderArgs = shaderArgs
    this.program = program
  }

  /**
   * @param {Texture} textureOpaque
   */
  setTexture (textureOpaque) {
    const gl = this.gl

    gl.uniform1i(this.shaderArgs.opaqueTexture, 0)
    gl.uniform1i(this.shaderArgs.alphaTexture, 1)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, textureOpaque.texture)
  }

  use () {
    this.program.use()
  }

  release () {
    const gl = this.gl
    gl.useProgram(null)
  }

  /**
   * @param {!Size}viewportSize
   */
  updatePerspective (viewportSize) {
    const gl = this.gl
    const {w, h} = viewportSize
    gl.viewport(0, 0, w, h)
    this.program.setUniformM4(this.shaderArgs.u_projection, [
      2.0 / w, 0, 0, 0,
      0, 2.0 / -h, 0, 0,
      0, 0, 1, 0,
      -1, 1, 0, 1
    ])
    gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
    gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
      // top left:
      0, 0, 0, 0,
      // top right:
      w, 0, 1, 0,
      // bottom right:
      w, h, 1, 1,
      // bottom right:
      w, h, 1, 1,
      // bottom left:
      0, h, 0, 1,
      // top left:
      0, 0, 0, 0
    ]), this.gl.DYNAMIC_DRAW)
    gl.vertexAttribPointer(this.shaderArgs.a_position, 2, gl.FLOAT, false, 16, 0)
    gl.vertexAttribPointer(this.shaderArgs.a_texCoord, 2, gl.FLOAT, false, 16, 8)
  }

  draw () {
    const gl = this.gl
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
    gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 6)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return H264RenderState; });
/* harmony import */ var _Texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _RenderState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _H264BufferContentDecoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47);
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);








/**
 * @implements RenderState
 */
class H264RenderState extends _RenderState__WEBPACK_IMPORTED_MODULE_2__["default"] {
  /**
   * @param {!WebGLRenderingContext}gl
   * @returns {!H264RenderState}
   */
  static create (gl) {
    const h264BufferContentDecoder = _H264BufferContentDecoder__WEBPACK_IMPORTED_MODULE_3__["default"].create()
    return new H264RenderState(gl, h264BufferContentDecoder)
  }

  /**
   * Use ViewState.create(..) instead.
   * @param {!WebGLRenderingContext}gl
   * @param {!H264BufferContentDecoder}h264BufferContentDecoder
   * @private
   */
  constructor (gl, h264BufferContentDecoder) {
    super()
    /**
     * @type {!WebGLRenderingContext}
     */
    this.gl = gl
    /**
     * @type {!Texture}
     */
    this.yTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.LUMINANCE)
    /**
     * @type {!Texture}
     */
    this.uTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.LUMINANCE)
    /**
     * @type {!Texture}
     */
    this.vTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.LUMINANCE)
    /**
     * @type {!Texture}
     */
    this.alphaTexture = _Texture__WEBPACK_IMPORTED_MODULE_0__["default"].create(this.gl, this.gl.LUMINANCE)
    /**
     * @type {!Size}
     */
    this.size = _Size__WEBPACK_IMPORTED_MODULE_1__["default"].create(0, 0)
    /**
     * @type {!H264BufferContentDecoder}
     * @private
     */
    this._h264BufferContentDecoder = h264BufferContentDecoder
  }

  /**
   * @param {EncodedFrame}encodedFrame
   * @return {Promise<void>}
   * @override
   */
  async update (encodedFrame) {
    const {alpha, opaque} = await this._h264BufferContentDecoder.decode(encodedFrame)

    // the width & height returned are actually paddded, so we have to use the frame size to get the real image dimension
    // when uploading to texture
    const opaqueBuffer = opaque.buffer
    const opaqueWidth = opaque.width // stride
    const opaqueHeight = opaque.height // padded with filler rows

    const lumaSize = opaqueWidth * opaqueHeight
    const chromaSize = lumaSize >> 2

    const yBuffer = opaqueBuffer.subarray(0, lumaSize)
    const uBuffer = opaqueBuffer.subarray(lumaSize, lumaSize + chromaSize)
    const vBuffer = opaqueBuffer.subarray(lumaSize + chromaSize, lumaSize + (2 * chromaSize))

    const isSubImage = encodedFrame.size.equals(this.size)

    const chromaWidth = encodedFrame.size.w >> 1
    const chromaHeight = encodedFrame.size.h >> 1
    const chromaStride = opaqueWidth >> 1
    if (isSubImage) {
      this.yTexture.subImage2dBuffer(yBuffer, _math_Rect__WEBPACK_IMPORTED_MODULE_4__["default"].create(0, 0, encodedFrame.size.w, encodedFrame.size.h), opaqueWidth)
      this.uTexture.subImage2dBuffer(uBuffer, _math_Rect__WEBPACK_IMPORTED_MODULE_4__["default"].create(0, 0, chromaWidth, chromaHeight), chromaStride)
      this.vTexture.subImage2dBuffer(vBuffer, _math_Rect__WEBPACK_IMPORTED_MODULE_4__["default"].create(0, 0, chromaWidth, chromaHeight), chromaStride)
    } else {
      this.yTexture.image2dBuffer(yBuffer, encodedFrame.size.w, encodedFrame.size.h, opaqueWidth)
      this.uTexture.image2dBuffer(uBuffer, chromaWidth, chromaHeight, chromaStride)
      this.vTexture.image2dBuffer(vBuffer, chromaWidth, chromaHeight, chromaStride)
    }

    if (alpha) {
      const alphaWidth = alpha.width // stride
      const alphaHeight = alpha.height // padded with filler rows
      const alphaLumaSize = alphaWidth * alphaHeight

      const alphaBuffer = alpha.buffer.subarray(0, alphaLumaSize)
      if (isSubImage) {
        this.alphaTexture.subImage2dBuffer(alphaBuffer, _math_Rect__WEBPACK_IMPORTED_MODULE_4__["default"].create(0, 0, encodedFrame.size.w, encodedFrame.size.h), alphaWidth)
      } else {
        this.alphaTexture.image2dBuffer(alphaBuffer, encodedFrame.size.w, encodedFrame.size.h, alphaWidth)
      }
    }
  }

  /**
   * @override
   */
  destroy () {
    this.yTexture.delete()
    this.uTexture.delete()
    this.vTexture.delete()
    this.alphaTexture.delete()
    this._h264BufferContentDecoder.destroy()
  }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return H264BufferContentDecoder; });
/* harmony import */ var _H264NALDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var _EncodingOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);



class H264BufferContentDecoder {
  /**
   * @return {H264BufferContentDecoder}
   */
  static create () {
    return new H264BufferContentDecoder()
  }

  constructor () {
    /**
     * @type {H264NALDecoder}
     * @private
     */
    this._decoder = null
    /**
     * @type {Promise<H264NALDecoder>}
     * @private
     */
    this._decoderFactory = null
    /**
     * @type {number[]}
     * @private
     */
    this._decodingSerialsQueue = []
    /**
     * @type {H264NALDecoder}
     * @private
     */
    this._alphaDecoder = null
    /**
     * @type {Promise<H264NALDecoder>}
     * @private
     */
    this._alphaDecoderFactory = null
    /**
     * @type {number[]}
     * @private
     */
    this._decodingAlphaSerialsQueue = []
    /**
     * @rtype {Object.<number,{serial: number, resolve:Function, state: 'pending'|'pending_opaque'|'pending_alpha'|'complete', result: {opaque: {buffer:Uint8Array, width: number, height:number}, alpha:{buffer:Uint8Array, width: number, height:number}}}>}
     * @private
     */
    this._frameStates = {}
  }

  /**
   * @param {EncodedFrame}bufferContents
   * @return {Promise<{opaque: {buffer:Uint8Array, width: number, height:number}, alpha:{buffer:Uint8Array, width: number, height:number}}>}
   */
  async decode (bufferContents) {
    return new Promise((resolve) => {
      this._frameStates[bufferContents.serial] = {
        serial: bufferContents.serial,
        resolve: resolve,
        state: 'pending',
        result: {
          opaque: null,
          alpha: null
        }
      }

      this._decodeH264(bufferContents)
    })
  }

  /**
   * @param {boolean}hasAlpha
   * @private
   */
  async _ensureH264Decoders (hasAlpha) {
    if (!this._decoder) {
      if (!this._decoderFactory) {
        this._decoderFactory = _H264NALDecoder__WEBPACK_IMPORTED_MODULE_0__["default"].create(H264BufferContentDecoder._nextDecoderId++)
      }
      const decoder = await this._decoderFactory
      decoder.onPicture = (buffer, width, height) => {
        this._onPictureDecoded(buffer, width, height)
      }
      this._decoder = decoder
    }

    if (hasAlpha && !this._alphaDecoder) {
      if (!this._alphaDecoderFactory) {
        this._alphaDecoderFactory = _H264NALDecoder__WEBPACK_IMPORTED_MODULE_0__["default"].create(H264BufferContentDecoder._nextDecoderId++)
      }
      const alphaDecoder = await this._alphaDecoderFactory
      alphaDecoder.onPicture = (buffer, width, height) => {
        this._onAlphaPictureDecoded(buffer, width, height)
      }
      this._alphaDecoder = alphaDecoder
    }

    if (!hasAlpha && this._alphaDecoder) {
      this._alphaDecoder.release()
      this._alphaDecoder = null
      this._alphaDecoderFactory = null
    }
  }

  /**
   * @param {EncodedFrame}bufferContents
   * @return {Promise<void>}
   * @private
   */
  async _decodeH264 (bufferContents) {
    const fullFrame = _EncodingOptions__WEBPACK_IMPORTED_MODULE_1__["default"].fullFrame(bufferContents.encodingOptions)
    if (!fullFrame) {
      throw new Error('h264 encoded buffers must contain the full frame.')
    }
    const hasAlpha = _EncodingOptions__WEBPACK_IMPORTED_MODULE_1__["default"].splitAlpha(bufferContents.encodingOptions)
    await this._ensureH264Decoders(hasAlpha)

    if (hasAlpha) {
      this._decodingAlphaSerialsQueue.push(bufferContents.serial)
      // create a copy of the arraybuffer so we can zero-copy the opaque part (after zero-copying, we can no longer use the underlying array in any way)
      const alphaH264Nal = new Uint8Array(bufferContents.fragments[0].alpha.slice())
      this._alphaDecoder.decode(alphaH264Nal)
    } else {
      this._frameStates[bufferContents.serial].state = 'pending_opaque'
    }

    this._decodingSerialsQueue.push(bufferContents.serial)
    const opaqueH264Nal = new Uint8Array(bufferContents.fragments[0].opaque)
    this._decoder.decode(opaqueH264Nal)
  }

  /**
   * @param {{serial: number, resolve:Function, state: 'pending'|'pending_opaque'|'pending_alpha'|'complete', result: {opaque: {buffer:Uint8Array, width: number, height:number}, alpha:{buffer:Uint8Array, width: number, height:number}}}}frameState
   * @private
   */
  _onComplete (frameState) {
    frameState.state = 'complete'
    delete this._frameStates[frameState.serial]
    frameState.resolve(frameState.result)
  }

  /**
   * @param {Uint8Array}buffer
   * @param {number}width
   * @param {number}height
   * @private
   */
  _onPictureDecoded (buffer, width, height) {
    const frameSerial = this._decodingSerialsQueue.shift()
    const frameState = this._frameStates[frameSerial]
    frameState.result.opaque = {
      buffer: buffer,
      width: width,
      height: height
    }

    if (frameState.state === 'pending_opaque') {
      this._onComplete(frameState)
    } else {
      frameState.state = 'pending_alpha'
    }
  }

  /**
   * @param {Uint8Array}buffer
   * @param {number}width
   * @param {number}height
   * @private
   */
  _onAlphaPictureDecoded (buffer, width, height) {
    const frameSerial = this._decodingAlphaSerialsQueue.shift()
    const frameState = this._frameStates[frameSerial]
    frameState.result.alpha = {
      buffer: buffer,
      width: width,
      height: height
    }

    if (frameState.state === 'pending_alpha') {
      this._onComplete(frameState)
    } else {
      this._frameStates[frameSerial].state = 'pending_opaque'
    }
  }

  destroy () {
    if (this._decoder) {
      this._decoder.release()
      this._decoderFactory = null
      this._decoder = null
    }
    if (this._alphaDecoder) {
      this._alphaDecoder.release()
      this._alphaDecoderFactory = null
      this._alphaDecoder = null
    }
  }
}

/**
 * @type {number}
 * @private
 */
H264BufferContentDecoder._nextDecoderId = 0


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return H264NALDecoder; });


class H264NALDecoder {
  /**
   * @param {number}renderStateId
   * @return {Promise<H264NALDecoder>}
   */
  static async create (renderStateId) {
    const tinyH264Worker = await H264NALDecoder._tinyH264WorkerPromise
    const h264NALDecoder = new H264NALDecoder(tinyH264Worker, renderStateId)
    H264NALDecoder.h264NalDecoders[renderStateId] = h264NALDecoder
    return h264NALDecoder
  }

  /**
   * @param {Worker}tinyH264Worker
   * @param {number}renderStateId
   */
  constructor (tinyH264Worker, renderStateId) {
    this._tinyH264Worker = tinyH264Worker
    this._renderStateId = renderStateId
    this._busy = false
    this._decodeQueue = []
  }

  /**
   * @param {Uint8Array} h264Nal
   */
  decode (h264Nal) {
    if (this._busy) {
      false && console.log('Decoder busy. Queueing h264 NAL')
      this._decodeQueue.push(h264Nal)
      return
    }
    this._tinyH264Worker.postMessage({
      type: 'decode',
      data: h264Nal.buffer,
      renderStateId: this._renderStateId
    }, [h264Nal.buffer])
    this._busy = true
  }

  /**
   * @param {{width:number, height:number, data: ArrayBuffer}}message
   */
  onPictureReady (message) {
    const {width, height, data} = message

    if (this._decodeQueue.length > 0) {
      const h264Nal = this._decodeQueue.shift()
      this._tinyH264Worker.postMessage({
        type: 'decode',
        data: h264Nal.buffer,
        renderStateId: this._renderStateId
      }, [h264Nal.buffer])
    } else {
      this._busy = false
    }
    this.onPicture(new Uint8Array(data), width, height)
  }

  /**
   * @param {Uint8Array}buffer
   * @param {number}width
   * @param {number}height
   */
  onPicture (buffer, width, height) {}

  release () {
    if (this._tinyH264Worker) {
      this._tinyH264Worker.postMessage({type: 'release', renderStateId: this._renderStateId})
      this._tinyH264Worker = null
    }
  }
}

/**
 * @type {Object.<number,H264NALDecoder>}
 */
H264NALDecoder.h264NalDecoders = {}

/**
 * @type {Promise<Worker>}
 * @private
 */
H264NALDecoder._tinyH264WorkerPromise = new Promise((resolve) => {
  /**
   * @type {Worker}
   * @private
   */
  const tinyH264Worker = new window.Worker('TinyH264Worker.js')
  tinyH264Worker.addEventListener('message', (e) => {
    const message = /** @type {{type:string, width:number, height:number, data:ArrayBuffer, renderStateId:number}} */e.data
    switch (message.type) {
      case 'pictureReady':
        H264NALDecoder.h264NalDecoders[message.renderStateId].onPictureReady(message)
        break
      case 'decoderReady':
        resolve(tinyH264Worker)
        break
    }
  })
})


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return YUVASurfaceShader; });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _ShaderSources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);






class YUVASurfaceShader {
  /**
   *
   * @param {WebGLRenderingContext} gl
   * @returns {YUVASurfaceShader}
   */
  static create (gl) {
    const program = this._initShaders(gl)
    const shaderArgs = this._initShaderArgs(gl, program)
    const vertexBuffer = this._initBuffers(gl)

    return new YUVASurfaceShader(gl, vertexBuffer, shaderArgs, program)
  }

  static _initShaders (gl) {
    const program = new _Program__WEBPACK_IMPORTED_MODULE_0__["default"](gl)
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["vertexQuad"]))
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["fragmentYUVA"]))
    program.link()
    program.use()

    return program
  }

  static _initShaderArgs (gl, program) {
    // find shader arguments
    const shaderArgs = {}
    shaderArgs.yTexture = program.getUniformLocation('yTexture')
    shaderArgs.uTexture = program.getUniformLocation('uTexture')
    shaderArgs.vTexture = program.getUniformLocation('vTexture')
    shaderArgs.alphaYTexture = program.getUniformLocation('alphaYTexture')

    shaderArgs.u_projection = program.getUniformLocation('u_projection')

    shaderArgs.a_position = program.getAttributeLocation('a_position')
    gl.enableVertexAttribArray(shaderArgs.a_position)
    shaderArgs.a_texCoord = program.getAttributeLocation('a_texCoord')
    gl.enableVertexAttribArray(shaderArgs.a_texCoord)

    return shaderArgs
  }

  static _initBuffers (gl) {
    // Create vertex buffer object.
    return gl.createBuffer()
  }

  constructor (gl, vertexBuffer, shaderArgs, program) {
    this.gl = gl
    this.vertexBuffer = vertexBuffer
    this.shaderArgs = shaderArgs
    this.program = program
  }

  /**
   *
   * @param {Texture} textureY
   * @param {Texture} textureU
   * @param {Texture} textureV
   * @param {Texture} textureAlphaY
   */
  setTexture (textureY, textureU, textureV, textureAlphaY) {
    const gl = this.gl

    gl.uniform1i(this.shaderArgs.yTexture, 0)
    gl.uniform1i(this.shaderArgs.uTexture, 1)
    gl.uniform1i(this.shaderArgs.vTexture, 2)
    gl.uniform1i(this.shaderArgs.alphaYTexture, 3)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, textureY.texture)

    gl.activeTexture(gl.TEXTURE1)
    gl.bindTexture(gl.TEXTURE_2D, textureU.texture)

    gl.activeTexture(gl.TEXTURE2)
    gl.bindTexture(gl.TEXTURE_2D, textureV.texture)

    gl.activeTexture(gl.TEXTURE3)
    gl.bindTexture(gl.TEXTURE_2D, textureAlphaY.texture)
  }

  use () {
    this.program.use()
  }

  release () {
    const gl = this.gl
    gl.useProgram(null)
  }

  /**
   * @param {!Size}viewportSize
   */
  updatePerspective (viewportSize) {
    const gl = this.gl
    const {w, h} = viewportSize
    gl.viewport(0, 0, w, h)
    this.program.setUniformM4(this.shaderArgs.u_projection, [
      2.0 / w, 0, 0, 0,
      0, 2.0 / -h, 0, 0,
      0, 0, 1, 0,
      -1, 1, 0, 1
    ])
    gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
    gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
      // top left:
      0, 0, 0, 0,
      // top right:
      w, 0, 1, 0,
      // bottom right:
      w, h, 1, 1,
      // bottom right:
      w, h, 1, 1,
      // bottom left:
      0, h, 0, 1,
      // top left:
      0, 0, 0, 0
    ]), this.gl.DYNAMIC_DRAW)
    gl.vertexAttribPointer(this.shaderArgs.a_position, 2, gl.FLOAT, false, 16, 0)
    gl.vertexAttribPointer(this.shaderArgs.a_texCoord, 2, gl.FLOAT, false, 16, 8)
  }

  draw () {
    const gl = this.gl
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
    gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 6)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return YUVSurfaceShader; });
/* harmony import */ var _Program__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _ShaderSources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);






class YUVSurfaceShader {
  /**
   *
   * @param {WebGLRenderingContext} gl
   * @returns {YUVSurfaceShader}
   */
  static create (gl) {
    const program = this._initShaders(gl)
    const shaderArgs = this._initShaderArgs(gl, program)
    const vertexBuffer = this._initBuffers(gl)

    return new YUVSurfaceShader(gl, vertexBuffer, shaderArgs, program)
  }

  static _initShaders (gl) {
    const program = new _Program__WEBPACK_IMPORTED_MODULE_0__["default"](gl)
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["vertexQuad"]))
    program.attach(_ShaderCompiler__WEBPACK_IMPORTED_MODULE_1__["default"].compile(gl, _ShaderSources__WEBPACK_IMPORTED_MODULE_2__["fragmentYUV"]))
    program.link()
    program.use()

    return program
  }

  static _initShaderArgs (gl, program) {
    // find shader arguments
    const shaderArgs = {}
    shaderArgs.yTexture = program.getUniformLocation('yTexture')
    shaderArgs.uTexture = program.getUniformLocation('uTexture')
    shaderArgs.vTexture = program.getUniformLocation('vTexture')

    shaderArgs.u_projection = program.getUniformLocation('u_projection')

    shaderArgs.a_position = program.getAttributeLocation('a_position')
    gl.enableVertexAttribArray(shaderArgs.a_position)
    shaderArgs.a_texCoord = program.getAttributeLocation('a_texCoord')
    gl.enableVertexAttribArray(shaderArgs.a_texCoord)

    return shaderArgs
  }

  static _initBuffers (gl) {
    // Create vertex buffer object.
    return gl.createBuffer()
  }

  constructor (gl, vertexBuffer, shaderArgs, program) {
    this.gl = gl
    this.vertexBuffer = vertexBuffer
    this.shaderArgs = shaderArgs
    this.program = program
  }

  /**
   *
   * @param {Texture} textureY
   * @param {Texture} textureU
   * @param {Texture} textureV
   */
  setTexture (textureY, textureU, textureV) {
    const gl = this.gl

    gl.uniform1i(this.shaderArgs.yTexture, 0)
    gl.uniform1i(this.shaderArgs.uTexture, 1)
    gl.uniform1i(this.shaderArgs.vTexture, 2)

    gl.activeTexture(gl.TEXTURE0)
    gl.bindTexture(gl.TEXTURE_2D, textureY.texture)

    gl.activeTexture(gl.TEXTURE1)
    gl.bindTexture(gl.TEXTURE_2D, textureU.texture)

    gl.activeTexture(gl.TEXTURE2)
    gl.bindTexture(gl.TEXTURE_2D, textureV.texture)
  }

  use () {
    this.program.use()
  }

  release () {
    const gl = this.gl
    gl.useProgram(null)
  }

  /**
   * @param {!Size}viewportSize
   */
  updatePerspective (viewportSize) {
    const gl = this.gl
    const {w, h} = viewportSize
    gl.viewport(0, 0, w, h)
    this.program.setUniformM4(this.shaderArgs.u_projection, [
      2.0 / w, 0, 0, 0,
      0, 2.0 / -h, 0, 0,
      0, 0, 1, 0,
      -1, 1, 0, 1
    ])
    gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
    gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
      // top left:
      0, 0, 0, 0,
      // top right:
      w, 0, 1, 0,
      // bottom right:
      w, h, 1, 1,
      // bottom right:
      w, h, 1, 1,
      // bottom left:
      0, h, 0, 1,
      // top left:
      0, 0, 0, 0
    ]), this.gl.DYNAMIC_DRAW)
    gl.vertexAttribPointer(this.shaderArgs.a_position, 2, gl.FLOAT, false, 16, 0)
    gl.vertexAttribPointer(this.shaderArgs.a_texCoord, 2, gl.FLOAT, false, 16, 8)
  }

  draw () {
    const gl = this.gl
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
    gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 6)
    gl.bindTexture(gl.TEXTURE_2D, null)
  }
}


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Callback; });


/**
 *
 *            Clients can handle the 'done' event to get notified when
 *            the related request is done.
 *
 */
class Callback {
  /**
   * @param {!WlCallbackResource}wlCallbackResource
   * @return {!Callback}
   */
  static create (wlCallbackResource) {
    return new Callback(wlCallbackResource)
  }

  /**
   * @param {!WlCallbackResource}grCallbackResource
   * @private
   */
  constructor (grCallbackResource) {
    /**
     * @type {?WlCallbackResource}
     */
    this.resource = grCallbackResource
  }

  /**
   *
   *                Notify the client when the related request is done.
   *
   *
   * @param {!number} data request-specific data for the callback
   *
   * @since 1
   *
   */
  done (data) {
    if (this.resource) {
      this.resource.done(data)
      this.resource.destroy()
      this.resource = null
    }
  }
}


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NORMAL", function() { return NORMAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_90", function() { return _90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_180", function() { return _180; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_270", function() { return _270; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLIPPED", function() { return FLIPPED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLIPPED_90", function() { return FLIPPED_90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLIPPED_180", function() { return FLIPPED_180; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLIPPED_270", function() { return FLIPPED_270; });
/* harmony import */ var _Mat4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);




const NORMAL = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].IDENTITY()
const _90 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  0, -1, 0, 0,
  1, 0, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const _180 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  -1, 0, 0, 0,
  0, -1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const _270 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  0, 1, 0, 0,
  -1, 0, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const FLIPPED = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  -1, 0, 0, 0,
  0, 1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const FLIPPED_90 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  0, -1, 0, 0,
  -1, 0, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const FLIPPED_180 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  1, 0, 0, 0,
  0, -1, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)
const FLIPPED_270 = _Mat4__WEBPACK_IMPORTED_MODULE_0__["default"].create(
  0, 1, 0, 0,
  1, 0, 0, 0,
  0, 0, 1, 0,
  0, 0, 0, 1
)




/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SurfaceChild; });
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);




class SurfaceChild {
  /**
   * Use surface.SurfaceChildSelf instead.
   * @param {Surface} surface
   * @return {SurfaceChild}
   * @private
   */
  static create (surface) {
    return new SurfaceChild(surface)
  }

  /**
   * @param {Surface} surface
   * @private
   */
  constructor (surface) {
    /**
     * @type {Surface}
     */
    this.surface = surface
    /**
     * @type {Point}
     * @private
     */
    this._position = _math_Point__WEBPACK_IMPORTED_MODULE_0__["default"].create(0, 0)
  }

  /**
   * @param {Point} relativePoint
   */
  set position (relativePoint) {
    this._position = relativePoint
  }

  /**
   * @return {Point}
   */
  get position () {
    return this._position
  }
}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RtcBufferFactory; });
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcBufferFactoryRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _protocol_WlBufferResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _protocol_WlBufferResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlBufferResource__WEBPACK_IMPORTED_MODULE_1__);
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcDcBufferResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _Buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56);
/* harmony import */ var _RtcDcBuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);









/**
 * @implements {RtcBufferFactoryRequests}
 */
class RtcBufferFactory extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcBufferFactoryRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   *
   * @param {!WlBufferResource} wlBufferResource
   * @returns {!RtcDcBuffer}
   */
  static get (wlBufferResource) {
    // TODO do some kind of type check magic and return null if the implementation is not of the expected type
    return wlBufferResource.implementation.rtcDcBuffer
  }

  /**
   * @returns {!RtcBufferFactory}
   */
  static create () {
    return new RtcBufferFactory()
  }

  /**
   * Use DcBufferFactory.create instead.
   * @private
   */
  constructor () {
    super()
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, RtcBufferFactory.name, 1, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global. Subclasses implement this method so they can instantiate a
   * corresponding Resource subtype.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const rtcBufferFactoryResource = new RtcBufferFactory(client, id, version)
    rtcBufferFactoryResource.implementation = this
  }

  /**
   *
   * @param {!RtcBufferFactoryResource} resource
   * @param {!number} id A new generic buffer
   *
   * @since 1
   *
   */
  createBuffer (resource, id) {
    const wlBufferResource = new _protocol_WlBufferResource__WEBPACK_IMPORTED_MODULE_1___default.a(resource.client, id, resource.version)
    _Buffer__WEBPACK_IMPORTED_MODULE_2__["default"].create(wlBufferResource)
  }

  /**
   *
   * @param {!RtcBufferFactoryResource} resource
   * @param {!number} id A new datachannel buffer
   * @param {!GrBlobTransferResource} grBlobTransferResource
   * @param {!WlBufferResource} wlBufferResource The generic buffer that will implement the new datachannel buffer
   *
   * @since 1
   *
   */
  createDcBuffer (resource, id, grBlobTransferResource, wlBufferResource) {
    // TODO try/catch & report error to client
    const rtcBlobTransfer = /** @type {RtcBlobTransfer} */ grBlobTransferResource.implementation
    rtcBlobTransfer.rtcPeerConnection.ensureP2S()

    const rtcDcBufferResource = new !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcDcBufferResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(resource.client, id, resource.version)
    _RtcDcBuffer__WEBPACK_IMPORTED_MODULE_3__["default"].create(wlBufferResource, rtcDcBufferResource, grBlobTransferResource)
  }
}


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A buffer provides the content for a wl_surface. Buffers are
 *      created through factory interfaces such as wl_drm, wl_shm or
 *      similar. It has a width and a height and can be attached to a
 *      wl_surface, but the mechanism by which a client provides and
 *      updates the contents is defined by the buffer factory interface.
 *    
 */
class WlBufferResource extends Resource {

	/**
	 *
	 *	Sent when this wl_buffer is no longer used by the compositor.
	 *	The client is now free to reuse or destroy this buffer and its
	 *	backing storage.
	 *
	 *	If a client receives a release event before the frame callback
	 *	requested in the same wl_surface.commit that attaches this
	 *	wl_buffer to a surface, then the client is immediately free to
	 *	reuse the buffer and its backing storage, and does not need a
	 *	second buffer for the next surface content update. Typically
	 *	this is possible, when the compositor maintains a copy of the
	 *	wl_surface contents, e.g. as a GL texture. This is an important
	 *	optimization for GL(ES) compositors with wl_shm clients.
	 *      
	 * @since 1
	 *
	 */
	release () {
		this.client.marshall(this.id, 0, [])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlBufferRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
}
WlBufferResource.protocolName = 'wl_buffer'

module.exports = WlBufferResource


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/* harmony import */ var _protocol_WlBufferRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _protocol_WlBufferRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlBufferRequests__WEBPACK_IMPORTED_MODULE_0__);




/**
 *
 *            A buffer provides the content for a gr_surface. Buffers are
 *            created through factory interfaces such as gr_drm, gr_shm or
 *            similar. It has a width and a height and can be attached to a
 *            gr_surface, but the mechanism by which a client provides and
 *            updates the contents is defined by the buffer factory interface.
 * @implements WlBufferRequests
 */
class Buffer extends _protocol_WlBufferRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   *
   * @param {!WlBufferResource} wlBufferResource
   * @return {!Buffer}
   */
  static create (wlBufferResource) {
    const buffer = new Buffer(wlBufferResource)
    wlBufferResource.implementation = buffer
    return buffer
  }

  /**
   * Instead use Buffer.create(..)
   * @private
   * @param {!WlBufferResource}wlBufferResource
   */
  constructor (wlBufferResource) {
    super()
    /**
     * @type {!WlBufferResource}
     * @const
     */
    this.resource = wlBufferResource
  }

  /**
   *
   * @param {!WlBufferResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }
}


/***/ }),
/* 57 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlBufferRequests {

	/**
	 *
	 *	Destroy a buffer. If and how you need to release the backing
	 *	storage is defined by the buffer factory interface.
	 *
	 *	For possible side-effects to a surface, see wl_surface.attach.
	 *      
	 *
	 * @param {WlBufferResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}
}

module.exports = WlBufferRequests


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RtcDcBuffer; });
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcDcBufferRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _EncodedFrame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);






/**
 * @implements {RtcDcBufferRequests}
 */
class RtcDcBuffer extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcDcBufferRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   *
   * @param {!WlBufferResource} wlBufferResource
   * @param {!RtcDcBufferResource} rtcDcBufferResource
   * @param {!GrBlobTransferResource} grBlobTransferResource
   * @returns {!RtcDcBuffer}
   */
  static create (wlBufferResource, rtcDcBufferResource, grBlobTransferResource) {
    const rtcDcBuffer = new RtcDcBuffer(rtcDcBufferResource, grBlobTransferResource)

    rtcDcBufferResource.implementation = rtcDcBuffer
    wlBufferResource.implementation.rtcDcBuffer = rtcDcBuffer

    const rtcBlobTransfer = /** @type {RtcBlobTransfer} */grBlobTransferResource.implementation
    rtcBlobTransfer.open().then((dataChannel) => {
      dataChannel.onmessage = rtcDcBuffer._onMessage.bind(rtcDcBuffer)
      dataChannel.onerror = rtcDcBuffer._onError.bind(rtcDcBuffer)
    })

    return rtcDcBuffer
  }

  /**
   * Instead use RtcDcBuffer.create(..)
   *
   * @private
   * @param {!RtcDcBufferResource} rtcDcBufferResource
   * @param {!GrBlobTransferResource} blobTransferResource
   */
  constructor (rtcDcBufferResource, blobTransferResource) {
    super()
    /**
     * @type {!RtcDcBufferResource}
     */
    this.resource = rtcDcBufferResource
    /**
     * @type {GrBlobTransferResource}
     * @private
     */
    this._blobTransferResource = blobTransferResource
    /**
     * @type {!number}
     * @private
     */
    this._syncSerial = 0
    /**
     * @type {!number}
     * @private
     */
    this._lastCompleteSerial = 0
    /**
     * @type {!Object.<number,{completionPromise: Promise, completionResolve: function, completionReject: function, state: string, encodedFrame: EncodedFrame}>}
     * @private
     */
    this._bufferStates = {}
    /**
     * @type {!Object.<number,{completionPromise: Promise, completionResolve: function, completionReject: function, state: string, encodedFrame: EncodedFrame}>}
     * @private
     */
    this._bufferChunks = {}
  }

  /**
   * @param {!number}serial
   * @param {!EncodedFrame}encodedFrame
   * @private
   */
  _onComplete (serial, encodedFrame) {
    if (serial < this._lastCompleteSerial) {
      return
    }
    const bufferState = this._bufferStates[serial]
    bufferState.state = 'complete'
    this._lastCompleteSerial = serial

    // remove old states
    for (const oldSerial in this._bufferStates) {
      if (oldSerial < serial) {
        if (this._bufferStates[serial].state !== 'complete') {
          this._bufferStates[oldSerial].completionReject(new Error('Buffer contents expired ' + oldSerial))
        }
        delete this._bufferStates[oldSerial]
      }
    }

    bufferState.completionResolve(encodedFrame)
  }

  /**
   * @param {!number}syncSerial
   * @return {!{completionPromise: Promise<EncodedFrame>, completionResolve: Function, completionReject: Function, state: string, encodedFrame: (EncodedFrame|null)}}
   * @private
   */
  _newBufferState (syncSerial) {
    /**
     * @type {{completionPromise: Promise<EncodedFrame>, completionResolve: function, completionReject: function, state: string, encodedFrame: EncodedFrame|null}}
     */
    const bufferState = {
      completionPromise: null,
      completionResolve: null,
      completionReject: null,
      state: 'pending', // or 'pending_alpha' or 'pending_opaque' or 'complete'
      encodedFrame: null
    }
    bufferState.completionPromise = new Promise((resolve, reject) => {
      bufferState.completionResolve = resolve
      bufferState.completionReject = reject
    })
    this._bufferStates[syncSerial] = bufferState
    return bufferState
  }

  /**
   * Returns a promise that will resolve as soon as the buffer is in the 'complete' state.
   * @returns {!Promise<EncodedFrame>}
   */
  whenComplete () {
    const bufferState = this._bufferStates[this._syncSerial]
    return bufferState.completionPromise
  }

  /**
   *
   * @param {!RtcDcBufferResource} resource
   * @param {!number} serial Serial of the send buffer contents
   * @since 1
   *
   */
  async syn (resource, serial) {
    if (serial < this._syncSerial) {
      // TODO return an error to the client
      throw new Error('Buffer sync serial was not sequential.')
    }
    this._syncSerial = serial

    if (this._bufferStates[serial] && this._bufferStates[serial].encodedFrame) {
      // state already exists, this means the contents arrived before this call, which means we can now decode it
      this._onComplete(serial, this._bufferStates[serial].encodedFrame)
    } else {
      // state does not exist yet, create a new state and wait for contents to arrive
      this._newBufferState(serial)
    }
  }

  /**
   * @param {!EncodedFrame}encodedFrame
   * @private
   */
  async _checkBufferState (encodedFrame) {
    if (this._bufferStates[encodedFrame.serial]) {
      // state already exists, this means the syn call arrived before this call, which means we can now decode it
      this._bufferStates[encodedFrame.serial].encodedFrame = encodedFrame
      this._onComplete(encodedFrame.serial, encodedFrame)
    } else if (encodedFrame.serial >= this._lastCompleteSerial) {
      // state does not exist yet, create a new state and wait for contents to arrive
      this._newBufferState(encodedFrame.serial).encodedFrame = encodedFrame
    }
  }

  /**
   *
   * @param {!ArrayBuffer}chunk
   * @returns {?ArrayBuffer}
   * @private
   */
  _checkChunk (chunk) {
    // TODO in case of jpeg we could send individual chunks that we can decode immediately as jpeg operates on 8x8 blocks.

    // parse chunk header
    const headerSize = 12
    const chunkHeader = new DataView(chunk, 0, headerSize)
    const synSerial = chunkHeader.getUint32(0, false)
    const nroChunks = chunkHeader.getUint32(4, false)
    const chunkIdx = chunkHeader.getUint32(8, false)

    // assign chunk to an aggregating data structure
    let bufferChunk = this._bufferChunks[synSerial]
    if (!bufferChunk) {
      bufferChunk = {
        chunks: new Array(nroChunks),
        received: 0,
        totalSize: 0
      }
      this._bufferChunks[synSerial] = bufferChunk
    }
    const headerlessChunk = chunk.slice(headerSize)

    if (bufferChunk.chunks[chunkIdx]) {
      return null
    }
    bufferChunk.chunks[chunkIdx] = headerlessChunk
    bufferChunk.received++
    bufferChunk.totalSize += headerlessChunk.byteLength

    // check if we have all required chunks & reconstruct frame buffer if so.
    const chunkSize = 16 * (1024 - 12)
    if (bufferChunk.received === nroChunks) {
      const bufferContents = new Uint8Array(bufferChunk.totalSize)
      bufferChunk.chunks.forEach((chunk, idx) => {
        bufferContents.set(new Uint8Array(chunk), idx * chunkSize)
      })
      delete this._bufferChunks[synSerial]
      return bufferContents.buffer
    } else {
      return null
    }
  }

  /**
   * @param {!MessageEvent}event
   * @private
   */
  async _onMessage (event) {
    try {
      const arrayBuffer = this._checkChunk(event.data)
      if (arrayBuffer) {
        const encodedFrame = _EncodedFrame__WEBPACK_IMPORTED_MODULE_1__["default"].create(arrayBuffer)
        if (this.resource) {
          this.resource.ack(encodedFrame.serial)
        }
        await this._checkBufferState(encodedFrame)
      } // else we haven't received the full frame yet.
    } catch (e) {
      console.error(e)
    }
  }

  /**
   * @param event
   * @private
   */
  _onError (event) {}

  destroy () {
    this._blobTransferResource.release()
    this.resource = null
  }
}


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EncodedFrame; });
/* harmony import */ var _EncodedFrameFragment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);
/* harmony import */ var _EncodingTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _EncodingTypes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_EncodingTypes__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);




class EncodedFrame {
  /**
   * @param {!ArrayBuffer}buffer
   * @return {!EncodedFrame}
   */
  static create (buffer) {
    const dataView = new DataView(buffer)
    let offset = 0

    const serial = dataView.getUint32(offset, true)
    offset += 4

    const encodingType = _EncodingTypes__WEBPACK_IMPORTED_MODULE_1___default.a[dataView.getUint16(offset, true)]
    offset += 2

    const encodingOptions = dataView.getUint16(offset, true) // unused for now
    offset += 2

    const width = dataView.getUint16(offset, true)
    offset += 2

    const height = dataView.getUint16(offset, true)
    offset += 2

    const encodedFragmentElements = dataView.getUint32(offset, true)
    offset += 4

    const encodedFragments = []
    for (let i = 0; i < encodedFragmentElements; i++) {
      const fragmentX = dataView.getUint16(offset, true)
      offset += 2
      const fragmentY = dataView.getUint16(offset, true)
      offset += 2
      const fragmentWidth = dataView.getUint16(offset, true)
      offset += 2
      const fragmentHeight = dataView.getUint16(offset, true)
      offset += 2
      const opaqueLength = dataView.getUint32(offset, true)
      offset += 4
      const opaque = new Uint8Array(buffer, offset, opaqueLength)
      offset += opaqueLength
      const alphaLength = dataView.getUint32(offset, true)
      offset += 4
      const alpha = new Uint8Array(buffer, offset, alphaLength)
      offset += alphaLength

      encodedFragments.push(_EncodedFrameFragment__WEBPACK_IMPORTED_MODULE_0__["default"].create(encodingType, fragmentX, fragmentY, fragmentWidth, fragmentHeight, opaque, alpha))
    }
    return new EncodedFrame(serial, encodingType, encodingOptions, _Size__WEBPACK_IMPORTED_MODULE_2__["default"].create(width, height), encodedFragments)
  }

  /**
   * @private
   * @param {!number}serial
   * @param {!string}encodingType
   * @param {!number}encodingOptions
   * @param {!Size}size
   * @param {!Array<EncodedFrameFragment>}fragments
   */
  constructor (serial, encodingType, encodingOptions, size, fragments) {
    /**
     * @type {number}
     * @const
     */
    this.serial = serial
    /**
     * @type {string}
     * @const
     */
    this.encodingType = encodingType
    /**
     * @type {number}
     * @const
     */
    this.encodingOptions = encodingOptions
    /**
     * @type {Size}
     * @const
     */
    this.size = size
    /**
     * @type {Array<EncodedFrameFragment>}
     * @const
     */
    this.fragments = fragments
  }
}


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EncodedFrameFragment; });
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);


class EncodedFrameFragment {
  /**
   * @param {!string}encodingType
   * @param {!number}fragmentX
   * @param {!number}fragmentY
   * @param {!number}fragmentWidth
   * @param {!number}fragmentHeight
   * @param {!Uint8Array}opaque
   * @param {!Uint8Array}alpha
   * @return {!EncodedFrameFragment}
   */
  static create (encodingType, fragmentX, fragmentY, fragmentWidth, fragmentHeight, opaque, alpha) {
    const geo = _math_Rect__WEBPACK_IMPORTED_MODULE_0__["default"].create(fragmentX, fragmentY, fragmentX + fragmentWidth, fragmentY + fragmentHeight)
    return new EncodedFrameFragment(encodingType, geo, opaque, alpha)
  }

  /**
   * @param {!string}encodingType
   * @param {!Rect}geo
   * @param {!Uint8Array}opaque
   * @param {!Uint8Array}alpha
   * @private
   */
  constructor (encodingType, geo, opaque, alpha) {
    /**
     * @type {!string}
     * @const
     */
    this.encodingType = encodingType
    /**
     * @type {!Rect}
     * @const
     */
    this.geo = geo
    /**
     * @type {!Uint8Array}
     * @const
     */
    this.opaque = opaque
    /**
     * @type {!Uint8Array}
     * @const
     */
    this.alpha = alpha
  }
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @type {!{'0': string, '1': string, '2': string}}
 */
module.exports = {
  /**
   * @type {string}
   * @const
   */
  0: 'video/h264',
  /**
   * @type {string}
   * @const
   */
  1: 'image/png',
  /**
   * @type {string}
   * @const
   */
  2: 'image/jpeg'
}


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
let Module = function (Module) {
  const FS = null
  const ERRNO_CODES = null
  Module = Module || {}

  var Module = typeof Module !== 'undefined' ? Module : {}
  Module['ENVIRONMENT'] = 'WEB'
  let moduleOverrides = {}
  let key
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key]
    }
  }
  Module['arguments'] = []
  Module['thisProgram'] = './this.program'
  Module['quit'] = (function (status, toThrow) {
    throw toThrow
  })
  Module['preRun'] = []
  Module['postRun'] = []
  let ENVIRONMENT_IS_WEB = false
  let ENVIRONMENT_IS_WORKER = false
  if (Module['ENVIRONMENT']) {
    if (Module['ENVIRONMENT'] === 'WEB') {
      ENVIRONMENT_IS_WEB = true
    } else if (Module['ENVIRONMENT'] === 'WORKER') {
      ENVIRONMENT_IS_WORKER = true
    } else {
      throw new Error('Module[\'ENVIRONMENT\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.')
    }
  } else {
    ENVIRONMENT_IS_WEB = typeof window === 'object'
    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function'
  }
  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    Module['read'] = function shell_read (url) {
      const xhr = new XMLHttpRequest
      xhr.open('GET', url, false)
      xhr.send(null)
      return xhr.responseText
    }
    if (ENVIRONMENT_IS_WORKER) {
      Module['readBinary'] = function readBinary (url) {
        const xhr = new XMLHttpRequest
        xhr.open('GET', url, false)
        xhr.responseType = 'arraybuffer'
        xhr.send(null)
        return new Uint8Array(xhr.response)
      }
    }
    Module['readAsync'] = function readAsync (url, onload, onerror) {
      const xhr = new XMLHttpRequest
      xhr.open('GET', url, true)
      xhr.responseType = 'arraybuffer'
      xhr.onload = function xhr_onload () {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response)
          return
        }
        onerror()
      }
      xhr.onerror = onerror
      xhr.send(null)
    }
    if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments
    }
    Module['setWindowTitle'] = (function (title) {
      document.title = title
    })
  }
  Module['print'] = console.log.bind(console)
  Module['printErr'] = console.warn.bind(console) || Module['print']
  Module.print = Module['print']
  Module.printErr = Module['printErr']
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key]
    }
  }
  moduleOverrides = undefined
  const STACK_ALIGN = 16

  function staticAlloc (size) {
    assert(!staticSealed)
    const ret = STATICTOP
    STATICTOP = STATICTOP + size + 15 & -16
    return ret
  }

  function alignMemory (size, factor) {
    if (!factor) factor = STACK_ALIGN
    const ret = size = Math.ceil(size / factor) * factor
    return ret
  }

  const functionPointers = new Array(0)
  const GLOBAL_BASE = 1024
  let ABORT = 0
  let EXITSTATUS = 0

  function assert (condition, text) {
    if (!condition) {
      abort('Assertion failed: ' + text)
    }
  }

  function Pointer_stringify (ptr, length) {
    if (length === 0 || !ptr) return ''
    let hasUtf = 0
    let t
    let i = 0
    while (1) {
      t = HEAPU8[ptr + i >> 0]
      hasUtf |= t
      if (t == 0 && !length) break
      i++
      if (length && i == length) break
    }
    if (!length) length = i
    let ret = ''
    if (hasUtf < 128) {
      const MAX_CHUNK = 1024
      let curr
      while (length > 0) {
        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)))
        ret = ret ? ret + curr : curr
        ptr += MAX_CHUNK
        length -= MAX_CHUNK
      }
      return ret
    }
    return UTF8ToString(ptr)
  }

  const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined

  function UTF8ArrayToString (u8Array, idx) {
    let endPtr = idx
    while (u8Array[endPtr]) ++endPtr
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr))
    } else {
      let u0, u1, u2, u3, u4, u5
      let str = ''
      while (1) {
        u0 = u8Array[idx++]
        if (!u0) return str
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0)
          continue
        }
        u1 = u8Array[idx++] & 63
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1)
          continue
        }
        u2 = u8Array[idx++] & 63
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2
        } else {
          u3 = u8Array[idx++] & 63
          if ((u0 & 248) == 240) {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3
          } else {
            u4 = u8Array[idx++] & 63
            if ((u0 & 252) == 248) {
              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4
            } else {
              u5 = u8Array[idx++] & 63
              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5
            }
          }
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0)
        } else {
          const ch = u0 - 65536
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023)
        }
      }
    }
  }

  function UTF8ToString (ptr) {
    return UTF8ArrayToString(HEAPU8, ptr)
  }

  function stringToUTF8Array (str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) return 0
    const startIdx = outIdx
    const endIdx = outIdx + maxBytesToWrite - 1
    for (let i = 0; i < str.length; ++i) {
      let u = str.charCodeAt(i)
      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023
      if (u <= 127) {
        if (outIdx >= endIdx) break
        outU8Array[outIdx++] = u
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx) break
        outU8Array[outIdx++] = 192 | u >> 6
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx) break
        outU8Array[outIdx++] = 224 | u >> 12
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 2097151) {
        if (outIdx + 3 >= endIdx) break
        outU8Array[outIdx++] = 240 | u >> 18
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else if (u <= 67108863) {
        if (outIdx + 4 >= endIdx) break
        outU8Array[outIdx++] = 248 | u >> 24
        outU8Array[outIdx++] = 128 | u >> 18 & 63
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      } else {
        if (outIdx + 5 >= endIdx) break
        outU8Array[outIdx++] = 252 | u >> 30
        outU8Array[outIdx++] = 128 | u >> 24 & 63
        outU8Array[outIdx++] = 128 | u >> 18 & 63
        outU8Array[outIdx++] = 128 | u >> 12 & 63
        outU8Array[outIdx++] = 128 | u >> 6 & 63
        outU8Array[outIdx++] = 128 | u & 63
      }
    }
    outU8Array[outIdx] = 0
    return outIdx - startIdx
  }

  function stringToUTF8 (str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite)
  }

  function lengthBytesUTF8 (str) {
    let len = 0
    for (let i = 0; i < str.length; ++i) {
      let u = str.charCodeAt(i)
      if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023
      if (u <= 127) {
        ++len
      } else if (u <= 2047) {
        len += 2
      } else if (u <= 65535) {
        len += 3
      } else if (u <= 2097151) {
        len += 4
      } else if (u <= 67108863) {
        len += 5
      } else {
        len += 6
      }
    }
    return len
  }

  const UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined

  function allocateUTF8 (str) {
    const size = lengthBytesUTF8(str) + 1
    const ret = _malloc(size)
    if (ret) stringToUTF8Array(str, HEAP8, ret, size)
    return ret
  }

  const PAGE_SIZE = 16384
  const WASM_PAGE_SIZE = 65536
  const ASMJS_PAGE_SIZE = 16777216

  function alignUp (x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple
    }
    return x
  }

  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64

  function updateGlobalBuffer (buf) {
    Module['buffer'] = buffer = buf
  }

  function updateGlobalBufferViews () {
    Module['HEAP8'] = HEAP8 = new Int8Array(buffer)
    Module['HEAP16'] = HEAP16 = new Int16Array(buffer)
    Module['HEAP32'] = HEAP32 = new Int32Array(buffer)
    Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer)
    Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer)
    Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer)
    Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer)
    Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer)
  }

  var STATIC_BASE, STATICTOP, staticSealed
  let STACK_BASE, STACKTOP, STACK_MAX
  let DYNAMIC_BASE, DYNAMICTOP_PTR
  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0
  staticSealed = false

  function abortOnCannotGrowMemory () {
    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ')
  }

  function enlargeMemory () {
    abortOnCannotGrowMemory()
  }

  const TOTAL_STACK = Module['TOTAL_STACK'] || 5242880
  var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216
  if (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')')
  if (Module['buffer']) {
    buffer = Module['buffer']
  } else {
    if (typeof window.WebAssembly === 'object' && typeof window.WebAssembly.Memory === 'function') {
      Module['wasmMemory'] = new window.WebAssembly.Memory({
        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,
        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE
      })
      buffer = Module['wasmMemory'].buffer
    } else {
      buffer = new ArrayBuffer(TOTAL_MEMORY)
    }
    Module['buffer'] = buffer
  }
  updateGlobalBufferViews()

  function getTotalMemory () {
    return TOTAL_MEMORY
  }

  HEAP32[0] = 1668509029
  HEAP16[1] = 25459
  if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99) throw 'Runtime error: expected the system to be little-endian!'

  function callRuntimeCallbacks (callbacks) {
    while (callbacks.length > 0) {
      let callback = callbacks.shift()
      if (typeof callback == 'function') {
        callback()
        continue
      }
      let func = callback.func
      if (typeof func === 'number') {
        if (callback.arg === undefined) {
          Module['dynCall_v'](func)
        } else {
          Module['dynCall_vi'](func, callback.arg)
        }
      } else {
        func(callback.arg === undefined ? null : callback.arg)
      }
    }
  }

  const __ATPRERUN__ = []
  const __ATINIT__ = []
  const __ATMAIN__ = []
  const __ATEXIT__ = []
  const __ATPOSTRUN__ = []
  let runtimeInitialized = false
  let runtimeExited = false

  function preRun () {
    if (Module['preRun']) {
      if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']]
      while (Module['preRun'].length) {
        addOnPreRun(Module['preRun'].shift())
      }
    }
    callRuntimeCallbacks(__ATPRERUN__)
  }

  function ensureInitRuntime () {
    if (runtimeInitialized) return
    runtimeInitialized = true
    callRuntimeCallbacks(__ATINIT__)
  }

  function preMain () {
    callRuntimeCallbacks(__ATMAIN__)
  }

  function exitRuntime () {
    callRuntimeCallbacks(__ATEXIT__)
    runtimeExited = true
  }

  function postRun () {
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']]
      while (Module['postRun'].length) {
        addOnPostRun(Module['postRun'].shift())
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__)
  }

  function addOnPreRun (cb) {
    __ATPRERUN__.unshift(cb)
  }

  function addOnPostRun (cb) {
    __ATPOSTRUN__.unshift(cb)
  }

  function writeAsciiToMemory (str, buffer, dontAddNull) {
    for (let i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i)
    }
    if (!dontAddNull) HEAP8[buffer >> 0] = 0
  }

  const Math_abs = Math.abs
  const Math_cos = Math.cos
  const Math_sin = Math.sin
  const Math_tan = Math.tan
  const Math_acos = Math.acos
  const Math_asin = Math.asin
  const Math_atan = Math.atan
  const Math_atan2 = Math.atan2
  const Math_exp = Math.exp
  const Math_log = Math.log
  const Math_sqrt = Math.sqrt
  const Math_ceil = Math.ceil
  const Math_floor = Math.floor
  const Math_pow = Math.pow
  const Math_imul = Math.imul
  const Math_fround = Math.fround
  const Math_round = Math.round
  const Math_min = Math.min
  const Math_max = Math.max
  const Math_clz32 = Math.clz32
  const Math_trunc = Math.trunc
  let runDependencies = 0
  let runDependencyWatcher = null
  let dependenciesFulfilled = null

  function addRunDependency (id) {
    runDependencies++
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies)
    }
  }

  function removeRunDependency (id) {
    runDependencies--
    if (Module['monitorRunDependencies']) {
      Module['monitorRunDependencies'](runDependencies)
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher)
        runDependencyWatcher = null
      }
      if (dependenciesFulfilled) {
        const callback = dependenciesFulfilled
        dependenciesFulfilled = null
        callback()
      }
    }
  }

  Module['preloadedImages'] = {}
  Module['preloadedAudios'] = {}
  const dataURIPrefix = 'data:application/octet-stream;base64,'

  function isDataURI (filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0
  }

  function integrateWasmJS () {
    let wasmTextFile = 'libxkbcommon.wast'
    let wasmBinaryFile = 'libxkbcommon.wasm'
    let asmjsCodeFile = 'libxkbcommon.temp.asm.js'
    if (typeof Module['locateFile'] === 'function') {
      if (!isDataURI(wasmTextFile)) {
        wasmTextFile = Module['locateFile'](wasmTextFile)
      }
      if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = Module['locateFile'](wasmBinaryFile)
      }
      if (!isDataURI(asmjsCodeFile)) {
        asmjsCodeFile = Module['locateFile'](asmjsCodeFile)
      }
    }
    const wasmPageSize = 64 * 1024
    const info = {
      'global': null,
      'env': null,
      'asm2wasm': {
        'f64-rem': (function (x, y) {
          return x % y
        }),
        'debugger': (function () {
          debugger
        })
      },
      'parent': Module
    }
    let exports = null

    function mergeMemory (newBuffer) {
      const oldBuffer = Module['buffer']
      if (newBuffer.byteLength < oldBuffer.byteLength) {
        Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here')
      }
      const oldView = new Int8Array(oldBuffer)
      const newView = new Int8Array(newBuffer)
      newView.set(oldView)
      updateGlobalBuffer(newBuffer)
      updateGlobalBufferViews()
    }

    function fixImports (imports) {
      return imports
    }

    function getBinary () {
      try {
        if (Module['wasmBinary']) {
          return new Uint8Array(Module['wasmBinary'])
        }
        if (Module['readBinary']) {
          return Module['readBinary'](wasmBinaryFile)
        } else {
          throw 'on the web, we need the wasm binary to be preloaded and set on Module[\'wasmBinary\']. emcc.py will do that for you when generating HTML (but not JS)'
        }
      } catch (err) {
        abort(err)
      }
    }

    function getBinaryPromise () {
      if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
        return fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }).then((function (response) {
          if (!response['ok']) {
            throw 'failed to load wasm binary file at \'' + wasmBinaryFile + '\''
          }
          return response['arrayBuffer']()
        })).catch((function () {
          return getBinary()
        }))
      }
      return new Promise((function (resolve, reject) {
        resolve(getBinary())
      }))
    }

    function doNativeWasm (global, env, providedBuffer) {
      if (typeof window.WebAssembly !== 'object') {
        Module['printErr']('no native wasm support detected')
        return false
      }
      if (!(Module['wasmMemory'] instanceof window.WebAssembly.Memory)) {
        Module['printErr']('no native wasm Memory in use')
        return false
      }
      env['memory'] = Module['wasmMemory']
      info['global'] = {
        'NaN': NaN,
        'Infinity': Infinity
      }
      info['global.Math'] = Math
      info['env'] = env

      function receiveInstance (instance, module) {
        exports = instance.exports
        if (exports.memory) mergeMemory(exports.memory)
        Module['asm'] = exports
        Module['usingWasm'] = true
        removeRunDependency('wasm-instantiate')
      }

      addRunDependency('wasm-instantiate')
      if (Module['instantiateWasm']) {
        try {
          return Module['instantiateWasm'](info, receiveInstance)
        } catch (e) {
          Module['printErr']('Module.instantiateWasm callback failed with error: ' + e)
          return false
        }
      }

      function receiveInstantiatedSource (output) {
        receiveInstance(output['instance'], output['module'])
      }

      function instantiateArrayBuffer (receiver) {
        getBinaryPromise().then((function (binary) {
          return window.WebAssembly.instantiate(binary, info)
        })).then(receiver).catch((function (reason) {
          Module['printErr']('failed to asynchronously prepare wasm: ' + reason)
          abort(reason)
        }))
      }

      if (!Module['wasmBinary'] && typeof window.WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {
        window.WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {
          credentials: 'same-origin'
        }), info).then(receiveInstantiatedSource).catch((function (reason) {
          Module['printErr']('wasm streaming compile failed: ' + reason)
          Module['printErr']('falling back to ArrayBuffer instantiation')
          instantiateArrayBuffer(receiveInstantiatedSource)
        }))
      } else {
        instantiateArrayBuffer(receiveInstantiatedSource)
      }
      return {}
    }

    Module['asmPreload'] = Module['asm']
    const asmjsReallocBuffer = Module['reallocBuffer']
    const wasmReallocBuffer = (function (size) {
      const PAGE_MULTIPLE = Module['usingWasm'] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE
      size = alignUp(size, PAGE_MULTIPLE)
      const old = Module['buffer']
      const oldSize = old.byteLength
      if (Module['usingWasm']) {
        try {
          const result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize)
          if (result !== (-1 | 0)) {
            return Module['buffer'] = Module['wasmMemory'].buffer
          } else {
            return null
          }
        } catch (e) {
          return null
        }
      }
    })
    Module['reallocBuffer'] = (function (size) {
      if (finalMethod === 'asmjs') {
        return asmjsReallocBuffer(size)
      } else {
        return wasmReallocBuffer(size)
      }
    })
    var finalMethod = ''
    Module['asm'] = (function (global, env, providedBuffer) {
      env = fixImports(env)
      if (!env['table']) {
        let TABLE_SIZE = Module['wasmTableSize']
        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024
        const MAX_TABLE_SIZE = Module['wasmMaxTableSize']
        if (typeof window.WebAssembly === 'object' && typeof window.WebAssembly.Table === 'function') {
          if (MAX_TABLE_SIZE !== undefined) {
            env['table'] = new window.WebAssembly.Table({
              'initial': TABLE_SIZE,
              'maximum': MAX_TABLE_SIZE,
              'element': 'anyfunc'
            })
          } else {
            env['table'] = new window.WebAssembly.Table({
              'initial': TABLE_SIZE,
              element: 'anyfunc'
            })
          }
        } else {
          env['table'] = new Array(TABLE_SIZE)
        }
        Module['wasmTable'] = env['table']
      }
      if (!env['memoryBase']) {
        env['memoryBase'] = Module['STATIC_BASE']
      }
      if (!env['tableBase']) {
        env['tableBase'] = 0
      }
      let exports
      exports = doNativeWasm(global, env, providedBuffer)
      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods')
      return exports
    })
  }

  integrateWasmJS()
  STATIC_BASE = GLOBAL_BASE
  STATICTOP = STATIC_BASE + 101600
  __ATINIT__.push()
  const STATIC_BUMP = 101600
  Module['STATIC_BASE'] = STATIC_BASE
  Module['STATIC_BUMP'] = STATIC_BUMP
  STATICTOP += 16

  function ___assert_fail (condition, filename, line, func) {
    abort('Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'])
  }

  function ___lock () {}

  const SYSCALLS = {
    varargs: 0,
    get: (function (varargs) {
      SYSCALLS.varargs += 4
      const ret = HEAP32[SYSCALLS.varargs - 4 >> 2]
      return ret
    }),
    getStr: (function () {
      const ret = Pointer_stringify(SYSCALLS.get())
      return ret
    }),
    get64: (function () {
      const low = SYSCALLS.get(), high = SYSCALLS.get()
      if (low >= 0) assert(high === 0)
      else assert(high === -1)
      return low
    }),
    getZero: (function () {
      assert(SYSCALLS.get() === 0)
    })
  }

  function ___syscall140 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(),
        result = SYSCALLS.get(), whence = SYSCALLS.get()
      const offset = offset_low
      FS.llseek(stream, offset, whence)
      HEAP32[result >> 2] = stream.position
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall145 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get()
      return SYSCALLS.doReadv(stream, iov, iovcnt)
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall146 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get()
      let ret = 0
      if (!___syscall146.buffers) {
        ___syscall146.buffers = [null, [], []]
        ___syscall146.printChar = (function (stream, curr) {
          const buffer = ___syscall146.buffers[stream]
          assert(buffer)
          if (curr === 0 || curr === 10) {
            (stream === 1 ? Module['print'] : Module['printErr'])(UTF8ArrayToString(buffer, 0))
            buffer.length = 0
          } else {
            buffer.push(curr)
          }
        })
      }
      for (let i = 0; i < iovcnt; i++) {
        const ptr = HEAP32[iov + i * 8 >> 2]
        const len = HEAP32[iov + (i * 8 + 4) >> 2]
        for (let j = 0; j < len; j++) {
          ___syscall146.printChar(stream, HEAPU8[ptr + j])
        }
        ret += len
      }
      return ret
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall192 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const addr = SYSCALLS.get(), len = SYSCALLS.get(), prot = SYSCALLS.get(), flags = SYSCALLS.get(),
        fd = SYSCALLS.get()
      let off = SYSCALLS.get()
      off <<= 12
      let ptr
      let allocated = false
      if (fd === -1) {
        ptr = _memalign(PAGE_SIZE, len)
        if (!ptr) return -ERRNO_CODES.ENOMEM
        _memset(ptr, 0, len)
        allocated = true
      } else {
        let info = FS.getStream(fd)
        if (!info) return -ERRNO_CODES.EBADF
        const res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags)
        ptr = res.ptr
        allocated = res.allocated
      }
      SYSCALLS.mappings[ptr] = {
        malloc: ptr,
        len: len,
        allocated: allocated,
        fd: fd,
        flags: flags
      }
      return ptr
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall195 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const path = SYSCALLS.getStr(), buf = SYSCALLS.get()
      return SYSCALLS.doStat(FS.stat, path, buf)
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall197 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get()
      return SYSCALLS.doStat(FS.stat, stream.path, buf)
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___setErrNo (value) {
    if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value
    return value
  }

  function ___syscall221 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall5 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get()
      const stream = FS.open(pathname, flags, mode)
      return stream.fd
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall54 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall6 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const stream = SYSCALLS.getStreamFromFD()
      FS.close(stream)
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___syscall91 (which, varargs) {
    SYSCALLS.varargs = varargs
    try {
      const addr = SYSCALLS.get(), len = SYSCALLS.get()
      let info = SYSCALLS.mappings[addr]
      if (!info) return 0
      if (len === info.len) {
        const stream = FS.getStream(info.fd)
        SYSCALLS.doMsync(addr, stream, len, info.flags)
        FS.munmap(stream)
        SYSCALLS.mappings[addr] = null
        if (info.allocated) {
          _free(info.malloc)
        }
      }
      return 0
    } catch (e) {
      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e)
      return -e.errno
    }
  }

  function ___unlock () {}

  function _abort () {
    Module['abort']()
  }

  const _environ = STATICTOP
  STATICTOP += 16

  function ___buildEnvironment (env) {
    const MAX_ENV_VALUES = 64
    const TOTAL_ENV_SIZE = 1024
    let poolPtr
    let envPtr
    if (!___buildEnvironment.called) {
      ___buildEnvironment.called = true
      ENV['USER'] = ENV['LOGNAME'] = 'web_user'
      ENV['PATH'] = '/'
      ENV['PWD'] = '/'
      ENV['HOME'] = '/home/web_user'
      ENV['LANG'] = 'C.UTF-8'
      ENV['_'] = Module['thisProgram']
      poolPtr = staticAlloc(TOTAL_ENV_SIZE)
      envPtr = staticAlloc(MAX_ENV_VALUES * 4)
      HEAP32[envPtr >> 2] = poolPtr
      HEAP32[_environ >> 2] = envPtr
    } else {
      envPtr = HEAP32[_environ >> 2]
      poolPtr = HEAP32[envPtr >> 2]
    }
    const strings = []
    let totalSize = 0
    for (let key in env) {
      if (typeof env[key] === 'string') {
        var line = key + '=' + env[key]
        strings.push(line)
        totalSize += line.length
      }
    }
    if (totalSize > TOTAL_ENV_SIZE) {
      throw new Error('Environment size exceeded TOTAL_ENV_SIZE!')
    }
    const ptrSize = 4
    for (let i = 0; i < strings.length; i++) {
      var line = strings[i]
      writeAsciiToMemory(line, poolPtr)
      HEAP32[envPtr + i * ptrSize >> 2] = poolPtr
      poolPtr += line.length + 1
    }
    HEAP32[envPtr + strings.length * ptrSize >> 2] = 0
  }

  var ENV = {}

  function _getenv (name) {
    if (name === 0) return 0
    name = Pointer_stringify(name)
    if (!ENV.hasOwnProperty(name)) return 0
    if (_getenv.ret) _free(_getenv.ret)
    _getenv.ret = allocateUTF8(ENV[name])
    return _getenv.ret
  }

  function _emscripten_memcpy_big (dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest)
    return dest
  }

  ___buildEnvironment(ENV)
  DYNAMICTOP_PTR = staticAlloc(4)
  STACK_BASE = STACKTOP = alignMemory(STATICTOP)
  STACK_MAX = STACK_BASE + TOTAL_STACK
  DYNAMIC_BASE = alignMemory(STACK_MAX)
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE
  staticSealed = true
  Module['wasmTableSize'] = 58
  Module['wasmMaxTableSize'] = 58
  Module.asmGlobalArg = {}
  Module.asmLibraryArg = {
    'abort': abort,
    'enlargeMemory': enlargeMemory,
    'getTotalMemory': getTotalMemory,
    'abortOnCannotGrowMemory': abortOnCannotGrowMemory,
    '___assert_fail': ___assert_fail,
    '___lock': ___lock,
    '___setErrNo': ___setErrNo,
    '___syscall140': ___syscall140,
    '___syscall145': ___syscall145,
    '___syscall146': ___syscall146,
    '___syscall192': ___syscall192,
    '___syscall195': ___syscall195,
    '___syscall197': ___syscall197,
    '___syscall221': ___syscall221,
    '___syscall5': ___syscall5,
    '___syscall54': ___syscall54,
    '___syscall6': ___syscall6,
    '___syscall91': ___syscall91,
    '___unlock': ___unlock,
    '_abort': _abort,
    '_emscripten_memcpy_big': _emscripten_memcpy_big,
    '_getenv': _getenv,
    'DYNAMICTOP_PTR': DYNAMICTOP_PTR,
    'STACKTOP': STACKTOP
  }
  const asm = Module['asm'](Module.asmGlobalArg, Module.asmLibraryArg, buffer)
  Module['asm'] = asm
  var _free = Module['_free'] = (function () {
    return Module['asm']['_free'].apply(null, arguments)
  })
  var _malloc = Module['_malloc'] = (function () {
    return Module['asm']['_malloc'].apply(null, arguments)
  })
  var _memalign = Module['_memalign'] = (function () {
    return Module['asm']['_memalign'].apply(null, arguments)
  })
  var _memset = Module['_memset'] = (function () {
    return Module['asm']['_memset'].apply(null, arguments)
  })
  const _xkb_context_new = Module['_xkb_context_new'] = (function () {
    return Module['asm']['_xkb_context_new'].apply(null, arguments)
  })
  const _xkb_keymap_get_as_string = Module['_xkb_keymap_get_as_string'] = (function () {
    return Module['asm']['_xkb_keymap_get_as_string'].apply(null, arguments)
  })
  const _xkb_keymap_new_from_string = Module['_xkb_keymap_new_from_string'] = (function () {
    return Module['asm']['_xkb_keymap_new_from_string'].apply(null, arguments)
  })
  const _xkb_state_new = Module['_xkb_state_new'] = (function () {
    return Module['asm']['_xkb_state_new'].apply(null, arguments)
  })
  const _xkb_state_serialize_layout = Module['_xkb_state_serialize_layout'] = (function () {
    return Module['asm']['_xkb_state_serialize_layout'].apply(null, arguments)
  })
  const _xkb_state_serialize_mods = Module['_xkb_state_serialize_mods'] = (function () {
    return Module['asm']['_xkb_state_serialize_mods'].apply(null, arguments)
  })
  const _xkb_state_update_key = Module['_xkb_state_update_key'] = (function () {
    return Module['asm']['_xkb_state_update_key'].apply(null, arguments)
  })
  Module['asm'] = asm
  Module['Pointer_stringify'] = Pointer_stringify
  Module['stringToUTF8'] = stringToUTF8
  Module['lengthBytesUTF8'] = lengthBytesUTF8
  Module['then'] = (function (func) {
    if (Module['calledRun']) {
      func(Module)
    } else {
      const old = Module['onRuntimeInitialized']
      Module['onRuntimeInitialized'] = (function () {
        if (old) old()
        func(Module)
      })
    }
    return Module
  })

  function ExitStatus (status) {
    this.name = 'ExitStatus'
    this.message = 'Program terminated with exit(' + status + ')'
    this.status = status
  }

  ExitStatus.prototype = new Error
  ExitStatus.prototype.constructor = ExitStatus
  let initialStackTop
  dependenciesFulfilled = function runCaller () {
    if (!Module['calledRun']) run()
    if (!Module['calledRun']) dependenciesFulfilled = runCaller
  }

  function run (args) {
    args = args || Module['arguments']
    if (runDependencies > 0) {
      return
    }
    preRun()
    if (runDependencies > 0) return
    if (Module['calledRun']) return

    function doRun () {
      if (Module['calledRun']) return
      Module['calledRun'] = true
      if (ABORT) return
      ensureInitRuntime()
      preMain()
      if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']()
      postRun()
    }

    if (Module['setStatus']) {
      Module['setStatus']('Running...')
      setTimeout((function () {
        setTimeout((function () {
          Module['setStatus']('')
        }), 1)
        doRun()
      }), 1)
    } else {
      doRun()
    }
  }

  Module['run'] = run

  function exit (status, implicit) {
    if (implicit && Module['noExitRuntime'] && status === 0) {
      return
    }
    if (Module['noExitRuntime']) {} else {
      ABORT = true
      EXITSTATUS = status
      STACKTOP = initialStackTop
      exitRuntime()
      if (Module['onExit']) Module['onExit'](status)
    }
    Module['quit'](status, new ExitStatus(status))
  }

  Module['exit'] = exit

  function abort (what) {
    if (Module['onAbort']) {
      Module['onAbort'](what)
    }
    if (what !== undefined) {
      Module.print(what)
      Module.printErr(what)
      what = JSON.stringify(what)
    } else {
      what = ''
    }
    ABORT = true
    EXITSTATUS = 1
    throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.'
  }

  Module['abort'] = abort
  if (Module['preInit']) {
    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']]
    while (Module['preInit'].length > 0) {
      Module['preInit'].pop()()
    }
  }
  Module['noExitRuntime'] = true
  run()

  return Module
}
/* harmony default export */ __webpack_exports__["default"] = (Module());


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RtcPeerConnectionFactory; });
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionFactoryRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionFactoryResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _RtcPeerConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);








/**
 * @implements RtcPeerConnectionFactoryRequests
 */
class RtcPeerConnectionFactory extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionFactoryRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   * @return {RtcPeerConnectionFactory}
   */
  static create () {
    return new RtcPeerConnectionFactory()
  }

  constructor () {
    super()
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionFactoryResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()).name, 1, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global. Subclasses implement this method so they can instantiate a
   * corresponding Resource subtype.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const rtcPeerConnectionFactoryResource = new RtcPeerConnectionFactory(client, id, version)
    rtcPeerConnectionFactoryResource.implementation = this
  }

  /**
   * @param {RtcPeerConnectionFactoryResource}resource
   * @param {number}id
   */
  createRtcPeerConnection (resource, id) {
    const rtcPeerConnectionResource = new !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(resource.client, id, resource.version)
    _RtcPeerConnection__WEBPACK_IMPORTED_MODULE_1__["default"].create(rtcPeerConnectionResource)
  }
}


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RtcPeerConnection; });
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrBlobTransferResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/* harmony import */ var _RtcBlobTransfer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);







/**
 * @interface {RtcPeerConnectionRequests}
 */
class RtcPeerConnection extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/RtcPeerConnectionRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   * @param {!RtcPeerConnectionResource}rtcPeerConnectionResource
   * @returns {!RtcPeerConnection}
   */
  static create (rtcPeerConnectionResource) {
    const rtcPeerConnection = new RtcPeerConnection(rtcPeerConnectionResource)
    rtcPeerConnectionResource.implementation = rtcPeerConnection
    return rtcPeerConnection
  }

  /**
   * Use RtcPeerConnection.create(..)
   * @param {!RtcPeerConnectionResource}rtcPeerConnectionResource
   * @private
   */
  constructor (rtcPeerConnectionResource) {
    super()
    /**
     * @type {!RtcPeerConnectionResource}
     * @const
     */
    this.rtcPeerConnectionResource = rtcPeerConnectionResource
    /**
     * @type {?{_peerConnection:window.RTCPeerConnection, clientIceCandidates:function, clientSdpReply:function, clientSdpOffer: function}}
     * @private
     */
    this._delegate = null
    /**
     * @type {?function}
     * @private
     */
    this._peerConnectionResolve = null
    /**
     * @type {!Promise}
     * @private
     */
    this._peerConnectionPromise = new Promise((resolve) => {
      this._peerConnectionResolve = resolve
    })
  }

  /**
   *
   * @param {!RtcPeerConnectionResource} resource
   * @param {!number} id Returns new blob transfer object who's data will be send over the given rtc peer connection
   * @param {!string} descriptor blob transfer descriptor
   *
   * @since 1
   *
   */
  createBlobTransfer (resource, id, descriptor) {
    // TODO check if the descriptor label matches one we send out earlier and notify whoever created that descriptor
    // that there is now a blob transfer object available
    const blobTransferResource = new !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrBlobTransferResource'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(resource.client, id, resource.version)
    _RtcBlobTransfer__WEBPACK_IMPORTED_MODULE_1__["default"]._create(blobTransferResource, descriptor, this)
  }

  /**
   * @return {!Promise<RTCPeerConnection>}
   */
  onPeerConnection () {
    return this._peerConnectionPromise
  }

  /**
   * Setup the peer connection for client (local) to server (browser) communication.
   */
  async ensureP2S () {
    if (this._delegate && this._delegate._peerConnection) {
      // already initialized as p2s, return early.
      return
    } else if (this._delegate && !this._delegate._peerConnection) {
      // TODO we probably want to report this error to the client.
      throw new Error('Rtc peer connection already initialized in P2P mode.')
    }

    this._delegate = {
      _peerConnection: new window.RTCPeerConnection(
        {
          'iceServers': [
            {
              'urls': 'turn:badger.pfoe.be?transport=tcp',
              'username': 'greenfield',
              'credential': 'water'
            },
            {
              'urls': 'stun:stun.l.google.com:19302'
            }
          ]
        }
      ),

      clientIceCandidates: async (resource, description) => {
        try {
          const signal = JSON.parse(description)
          false && console.log(`webrtc received remote ice candidate`)
          await this._delegate._peerConnection.addIceCandidate(new window.RTCIceCandidate(signal.candidate))
        } catch (error) {
          console.error(error, error.stack)
        }
      },

      clientSdpReply: async (resource, description) => {
        try {
          const signal = JSON.parse(description)
          false && console.log(`webrtc received remote sdp answer`)
          await this._delegate._peerConnection.setRemoteDescription(new window.RTCSessionDescription(signal.sdp))
        } catch (error) {
          console.error(error, error.stack)
        }
      },

      clientSdpOffer: async (resource, description) => {
        try {
          const signal = JSON.parse(description)
          false && console.log(`webrtc received remote sdp offer`)
          await this._delegate._peerConnection.setRemoteDescription(new window.RTCSessionDescription(signal.sdp))
          const desc = await this._delegate._peerConnection.createAnswer()
          await this._delegate._peerConnection.setLocalDescription(desc)
          false && console.log(`Child ${process.pid} webrtc sending local sdp answer`)
          await this.rtcPeerConnectionResource.serverSdpReply(JSON.stringify({'sdp': this._delegate._peerConnection.localDescription}))
        } catch (error) {
          console.error(error, error.stack)
        }
      }
    }

    false && console.log(`webrtc created new peer connection with connection state: ${this._delegate._peerConnection.connectionState}`)
    this._delegate._peerConnection.onconnectionstatechange = () => {
      false && console.log(`webrtc peer connection connection state changed to: ${this._delegate._peerConnection.connectionState}`)
    }

    this._delegate._peerConnection.onicecandidate = (evt) => {
      if (evt.candidate !== null) {
        false && console.log(`webrtc sending local ice candide`)
        this.rtcPeerConnectionResource.serverIceCandidates(JSON.stringify({'candidate': evt.candidate}))
      }
    }
    this._delegate._peerConnection.onnegotiationneeded = () => {
      false && console.log(`webrtc negotiation needed`)
      this._sendOffer()
    }

    this._peerConnectionResolve(this._delegate._peerConnection)
  }

  /**
   * @return {Promise<void>}
   * @private
   */
  async _sendOffer () {
    try {
      const desc = await this._delegate._peerConnection.createOffer({
        offerToReceiveAudio: false,
        offerToReceiveVideo: false,
        voiceActivityDetection: false,
        iceRestart: false
      })
      await this._delegate._peerConnection.setLocalDescription(desc)
      false && console.log(`webrtc sending local sdp offer`)
      this.rtcPeerConnectionResource.serverSdpOffer(JSON.stringify({'sdp': this._delegate._peerConnection.localDescription}))
    } catch (error) {
      console.error(error, error.stack)
    }
  }

  /**
   * Setup the peer connection for client (local) to client (local) communication.
   * @param otherRtcPeerConnectionResource
   */
  ensureP2P (otherRtcPeerConnectionResource) {
    if (this._delegate && this._delegate._peerConnection) {
      // TODO we probably want to report this error to the client.
      throw new Error('Rtc peer connection already initialized in P2S mode.')
    } else if (this._delegate && this._delegate.otherRtcPeerConnectionResource !== otherRtcPeerConnectionResource) {
      // TODO we probably want to report this error to the client.
      throw new Error('Rtc peer connection already initialized with another peer.')
    } else if (this._delegate && this._delegate.otherRtcPeerConnectionResource === otherRtcPeerConnectionResource) {
      return
    }

    // TODO keep track in which mode the connection is initialized
    this._delegate = {
      otherRtcPeerConnectionResource: otherRtcPeerConnectionResource,
      clientIceCandidates: (resource, description) => {
        this._delegate.otherRtcPeerConnectionResource.serverIceCandidates(description)
      },

      clientSdpReply: (resource, description) => {
        this._delegate.otherRtcPeerConnectionResource.serverSdpReply(description)
      },

      clientSdpOffer: (resource, description) => {
        this._delegate.otherRtcPeerConnectionResource.serverSdpOffer(description)
      }
    }

    this.rtcPeerConnectionResource.init()
    // in the p2p case, we will never have a peer connection as it is the client peer connections that will be linked
  }

  /**
   * @param {!RtcPeerConnectionResource} resource
   * @param {!string}description
   */
  clientIceCandidates (resource, description) {
    this._delegate.clientIceCandidates(resource, description)
  }

  /**
   * @param {!RtcPeerConnectionResource} resource
   * @param {!string}description
   */
  clientSdpReply (resource, description) {
    this._delegate.clientSdpReply(resource, description)
  }

  /**
   * @param {!RtcPeerConnectionResource} resource
   * @param {!string}description
   */
  clientSdpOffer (resource, description) {
    this._delegate.clientSdpOffer(resource, description)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(65)))

/***/ }),
/* 65 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RtcBlobTransfer; });
!(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrBlobTransferRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());




/**
 *
 *            Clients and compositor can send out-of-band data using a blob transfer object. Data is
 *            effectively transferred asynchronous using an implementation specific mechanism. A blob transfer object
 *            acts as a hook into an implementation specific mechanism to send and get the actual blob data.
 * @implements {GrBlobTransferRequests}
 */
class RtcBlobTransfer extends !(function webpackMissingModule() { var e = new Error("Cannot find module './protocol/GrBlobTransferRequests'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()) {
  /**
   * Called by the parent rtc peer connection when a client creates a new blob transfer.
   * @private
   * @param {!GrBlobTransferResource}resource
   * @param {!string}blobDescriptor
   * @param {!RtcPeerConnectionResource}rtcPeerConnection
   * @return {!RtcBlobTransfer}
   */
  static _create (resource, blobDescriptor, rtcPeerConnection) {
    const descriptorObj = JSON.parse(blobDescriptor)
    const rtcBlobTransfer = new RtcBlobTransfer(resource, descriptorObj, rtcPeerConnection)
    resource.implementation = rtcBlobTransfer

    const blobTransferEntry = this._blobTransferEntries[descriptorObj.label]
    if (blobTransferEntry) {
      blobTransferEntry.resolve(rtcBlobTransfer)
    }

    return rtcBlobTransfer
  }

  /**
   * @return {!string}
   * @private
   */
  static _uuidv4 () {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    )
  }

  /**
   * Returns a promise that will resolve to a RtcBlobTransfer as soon as the client has setup their end of the
   * blob transfer using this descriptor.
   * @param {!string}blobDescriptor
   * @return {Promise<RtcBlobTransfer>|null}
   */
  static get (blobDescriptor) {
    const descriptorObj = JSON.parse(blobDescriptor)
    // entries are created when a descriptor is created through createDescriptor
    const blobTransferEntry = this._blobTransferEntries[descriptorObj.label]
    return blobTransferEntry ? blobTransferEntry.promise : null
  }

  /**
   * Create a blob transfer descriptor that can be send to a client. The client in turn can use the descriptor to create
   * the actual blob transfer. After the descriptor is send, the server can use the descriptor to find the matching
   * blob transfer with RtcBlobTransfer.get(blobDescriptor).
   * @param {!boolean}reliable
   * @param {!string}binaryType data type of the content ('string', 'arraybuffer', 'blob')
   * @return {!string} a blob transfer descriptor
   */
  static createDescriptor (reliable, binaryType) {
    const label = this._uuidv4()
    const blobTransferEntry = {
      promise: null,
      resolve: null
    }
    blobTransferEntry.promise = new Promise((resolve) => {
      blobTransferEntry.resolve = resolve
    })
    this._blobTransferEntries[label] = blobTransferEntry

    // descriptor object somewhat corresponds to rtc data channel config dictionary
    return JSON.stringify({
      negotiated: true,
      maxRetransmits: reliable ? null : 0,
      id: -1, // the id is filled in by the client
      ordered: reliable, // making the channel ordered initiates it as a tcp connection, thus making it reliable.
      label: label, // not part of rtc data channel config dictionary
      binaryType: binaryType // not part of rtc data channel config dictionary
    })
  }

  /**
   * @private
   * @param {!GrBlobTransferResource}resource
   * @param {!string}descriptorObj
   * @param {!RtcPeerConnectionResource}rtcPeerConnection
   */
  constructor (resource, descriptorObj, rtcPeerConnection) {
    super()
    /**
     * @type {GrBlobTransferResource}
     */
    this.resource = resource
    /**
     * @type {!string}
     * @const
     * @private
     */
    this._descriptorObj = descriptorObj
    /**
     * @type {!RtcPeerConnectionResource}
     * @const
     */
    this.rtcPeerConnection = rtcPeerConnection
    /**
     * @type {?RTCDataChannel}
     * @private
     */
    this._dataChannel = null
    /**
     * @type {?Function}
     * @private
     */
    this._dataChannelResolve = null
    /**
     * @type {?Function}
     * @private
     */
    this._dataChannelReject = null
    /**
     * @type {Promise<RTCDataChannel>}
     * @private
     */
    this._dataChannelPromise = new Promise((resolve, reject) => {
      this._dataChannelResolve = resolve
      this._dataChannelReject = reject
    })
    /**
     * @type {?Promise<RTCPeerConnection>}
     * @private
     */
    this._peerConnectionPromise = null
  }

  /**
   * Setup this blob transfer so it can begin receiving and sending data. The behavior of the resulting rtc data channel
   * depends on the descriptor that was used to create the blob transfer. Opening the blob transfer multiple times will
   * return the same rtc data channel promise. After a blob transfer is closed, calls to open will return null.
   * @return {!Promise<RTCDataChannel>}
   */
  open () {
    if (!this._peerConnectionPromise) {
      this._peerConnectionPromise = this.rtcPeerConnection.onPeerConnection()
      this._peerConnectionPromise.then((peerConnection) => {
        const dataChannelInitDict = Object.assign({}, this._descriptorObj)
        const label = dataChannelInitDict.label
        const binaryType = dataChannelInitDict.binaryType
        delete dataChannelInitDict.label
        delete dataChannelInitDict.binaryType
        this._dataChannel = peerConnection.createDataChannel(label, dataChannelInitDict)
        this._dataChannel.binaryType = binaryType
        this._dataChannel.onopen = () => {
          this._dataChannelResolve(this._dataChannel)
        }
      }).catch((error) => {
        this._dataChannelReject(error)
      })
    }

    return this._dataChannelPromise
  }

  /**
   * Close and seal this blob transfer. A closed blob transfer can no longer be opened. Closing a blob transfer that
   * was not opened has no effect. Closing blob transfer multiple times has no effect.
   */
  closeAndSeal () {
    if (this._dataChannelPromise) {
      this._dataChannelPromise = null
    }
    if (this.resource) {
      this.resource.release()
      this.resource = null
    }
    if (this._dataChannel) {
      this._dataChannel.close()
      this._dataChannel = null
    }
  }

  /**
   * @param {!GrBlobTransferResource}resource
   */
  close (resource) {
    this.closeAndSeal()
  }
}
RtcBlobTransfer._blobTransferEntries = {}


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Shell; });
/* harmony import */ var _protocol_WlShellRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);
/* harmony import */ var _protocol_WlShellRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlShellRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
/* harmony import */ var _protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ShellSurface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);








/**
 *
 *            This interface is implemented by servers that provide
 *            desktop-style user interfaces.
 *
 *            It allows clients to associate a wl_shell_surface with
 *            a basic surface.
 * @implements {WlShellRequests}
 */
class Shell extends _protocol_WlShellRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {Session} session
   * @param {UserShell}userShell
   * @return {Shell}
   */
  static create (session, userShell) {
    return new Shell(session, userShell)
  }

  /**
   * Use Shell.create(..)
   * @param {Session} session
   * @param {UserShell}userShell
   * @private
   */
  constructor (session, userShell) {
    super()
    /**
     * @type {Session}
     */
    this.session = session
    /**
     * @type {UserShell}
     */
    this.userShell = userShell
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const wlShellResource = new _protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    wlShellResource.implementation = this
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1___default.a.name, 1, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   *                Create a shell surface for an existing surface. This gives
   *                the wl_surface the role of a shell surface. If the wl_surface
   *                already has another role, it raises a protocol error.
   *
   *                Only one shell surface can be associated with a given surface.
   *
   *
   * @param {WlShellResource} resource
   * @param {number} id shell surface to create
   * @param {WlSurfaceResource} surface surface to be given the shell surface role
   *
   * @since 1
   * @override
   */
  getShellSurface (resource, id, surface) {
    if (surface.implementation.role) {
      resource.postError(_protocol_WlShellResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.role, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role.')
      return
    }

    const wlShellSurfaceResource = new _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    _ShellSurface__WEBPACK_IMPORTED_MODULE_3__["default"].create(wlShellSurfaceResource, surface, this.session, this.userShell)
  }
}


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlShellRequests {

	/**
	 *
	 *	Create a shell surface for an existing surface. This gives
	 *	the wl_surface the role of a shell surface. If the wl_surface
	 *	already has another role, it raises a protocol error.
	 *
	 *	Only one shell surface can be associated with a given surface.
	 *      
	 *
	 * @param {WlShellResource} resource 
	 * @param {number} id shell surface to create 
	 * @param {*} surface surface to be given the shell surface role 
	 *
	 * @since 1
	 *
	 */
	getShellSurface(resource, id, surface) {}
}

module.exports = WlShellRequests


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      This interface is implemented by servers that provide
 *      desktop-style user interfaces.
 *
 *      It allows clients to associate a wl_shell_surface with
 *      a basic surface.
 *    
 */
class WlShellResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlShellRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'no')
		await this.implementation.getShellSurface(this, ...args)
	}
}
WlShellResource.protocolName = 'wl_shell'

WlShellResource.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

module.exports = WlShellResource


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      An interface that may be implemented by a wl_surface, for
 *      implementations that provide a desktop-style user interface.
 *
 *      It provides requests to treat surfaces like toplevel, fullscreen
 *      or popup windows, move, resize or maximize them, associate
 *      metadata like title and class, etc.
 *
 *      On the server side the object is automatically destroyed when
 *      the related wl_surface is destroyed. On the client side,
 *      wl_shell_surface_destroy() must be called before destroying
 *      the wl_surface object.
 *    
 */
class WlShellSurfaceResource extends Resource {

	/**
	 *
	 *	Ping a client to check if it is receiving events and sending
	 *	requests. A client is expected to reply with a pong request.
	 *      
	 *
	 * @param {number} serial serial number of the ping 
	 *
	 * @since 1
	 *
	 */
	ping (serial) {
		this.client.marshall(this.id, 0, [uint(serial)])
	}

	/**
	 *
	 *	The configure event asks the client to resize its surface.
	 *
	 *	The size is a hint, in the sense that the client is free to
	 *	ignore it if it doesn't resize, pick a smaller size (to
	 *	satisfy aspect ratio or resize in steps of NxM pixels).
	 *
	 *	The edges parameter provides a hint about how the surface
	 *	was resized. The client may use this information to decide
	 *	how to adjust its content to the new size (e.g. a scrolling
	 *	area might adjust its content position to leave the viewable
	 *	content unmoved).
	 *
	 *	The client is free to dismiss all but the last configure
	 *	event it received.
	 *
	 *	The width and height arguments specify the size of the window
	 *	in surface-local coordinates.
	 *      
	 *
	 * @param {number} edges how the surface was resized 
	 * @param {number} width new width of the surface 
	 * @param {number} height new height of the surface 
	 *
	 * @since 1
	 *
	 */
	configure (edges, width, height) {
		this.client.marshall(this.id, 1, [uint(edges), int(width), int(height)])
	}

	/**
	 *
	 *	The popup_done event is sent out when a popup grab is broken,
	 *	that is, when the user clicks a surface that doesn't belong
	 *	to the client owning the popup surface.
	 *      
	 * @since 1
	 *
	 */
	popupDone () {
		this.client.marshall(this.id, 2, [])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlShellSurfaceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.pong(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'ou')
		await this.implementation.move(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'ouu')
		await this.implementation.resize(this, ...args)
	}
	async [3] (message) {
		await this.implementation.setToplevel(this)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'oiiu')
		await this.implementation.setTransient(this, ...args)
	}
	async [5] (message) {
		const args = this.client._unmarshallArgs(message,'uu?o')
		await this.implementation.setFullscreen(this, ...args)
	}
	async [6] (message) {
		const args = this.client._unmarshallArgs(message,'ouoiiu')
		await this.implementation.setPopup(this, ...args)
	}
	async [7] (message) {
		const args = this.client._unmarshallArgs(message,'?o')
		await this.implementation.setMaximized(this, ...args)
	}
	async [8] (message) {
		const args = this.client._unmarshallArgs(message,'s')
		await this.implementation.setTitle(this, ...args)
	}
	async [9] (message) {
		const args = this.client._unmarshallArgs(message,'s')
		await this.implementation.setClass(this, ...args)
	}
}
WlShellSurfaceResource.protocolName = 'wl_shell_surface'

WlShellSurfaceResource.Resize = {
  /**
   * no edge
   */
  none: 0,
  /**
   * top edge
   */
  top: 1,
  /**
   * bottom edge
   */
  bottom: 2,
  /**
   * left edge
   */
  left: 4,
  /**
   * top and left edges
   */
  topLeft: 5,
  /**
   * bottom and left edges
   */
  bottomLeft: 6,
  /**
   * right edge
   */
  right: 8,
  /**
   * top and right edges
   */
  topRight: 9,
  /**
   * bottom and right edges
   */
  bottomRight: 10
}

WlShellSurfaceResource.Transient = {
  /**
   * do not set keyboard focus
   */
  inactive: 0x1
}

WlShellSurfaceResource.FullscreenMethod = {
  /**
   * no preference, apply default policy
   */
  default: 0,
  /**
   * scale, preserve the surface's aspect ratio and center on output
   */
  scale: 1,
  /**
   * switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
   */
  driver: 2,
  /**
   * no upscaling, center on output and add black borders to compensate size mismatch
   */
  fill: 3
}

module.exports = WlShellSurfaceResource


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShellSurface; });
/* harmony import */ var _protocol_WlShellSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72);
/* harmony import */ var _protocol_WlShellSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlShellSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);








const {bottom, bottomLeft, bottomRight, left, none, right, top, topLeft, topRight} = _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_1___default.a.Resize
const {inactive} = _protocol_WlShellSurfaceResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transient

const SurfaceStates = {
  MAXIMIZED: 'maximized',
  FULLSCREEN: 'fullscreen',
  POPUP: 'popup',
  TRANSIENT: 'transient',
  TOP_LEVEL: 'top_level'
}

/**
 *
 *            An interface that may be implemented by a wl_surface, for
 *            implementations that provide a desktop-style user interface.
 *
 *            It provides requests to treat surfaces like toplevel, fullscreen
 *            or popup windows, move, resize or maximize them, associate
 *            metadata like title and class, etc.
 *
 *            On the server side the object is automatically destroyed when
 *            the related wl_surface is destroyed. On the client side,
 *            wl_shell_surface_destroy() must be called before destroying
 *            the wl_surface object.
 *
 *  @implements {SurfaceRole}
 *  @implements {WlShellSurfaceRequests}
 *
 */
class ShellSurface extends _protocol_WlShellSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {WlShellSurfaceResource}wlShellSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {Session} session
   * @param {UserShell}userShell
   * @return {ShellSurface}
   */
  static create (wlShellSurfaceResource, wlSurfaceResource, session, userShell) {
    const shellSurface = new ShellSurface(wlShellSurfaceResource, wlSurfaceResource, session, userShell)
    wlShellSurfaceResource.implementation = shellSurface

    // destroy the shell-surface if the surface is destroyed.
    wlSurfaceResource.onDestroy().then(() => {
      wlShellSurfaceResource.destroy()
    })

    wlSurfaceResource.implementation.role = shellSurface
    shellSurface._doPing(wlShellSurfaceResource)

    wlShellSurfaceResource.onDestroy().then(() => {
      shellSurface._unmap()
      shellSurface._userShellSurface.destroy()
    })

    return shellSurface
  }

  /**
   * @private
   * @param {WlShellSurfaceResource}wlShellSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {Session} session
   * @param {UserShell}userShell
   */
  constructor (wlShellSurfaceResource, wlSurfaceResource, session, userShell) {
    super()
    /**
     * @type {WlShellSurfaceResource}
     */
    this.resource = wlShellSurfaceResource
    /**
     * @type {WlSurfaceResource}
     */
    this.wlSurfaceResource = wlSurfaceResource
    /**
     * @type {string}
     * @private
     */
    this._title = ''
    /**
     * @type {string}
     * @private
     */
    this._clazz = ''
    /**
     * @type {string}
     */
    this.state = null
    /**
     * @type {Session}
     */
    this.session = session
    /**
     * @type {UserShell}
     * @private
     */
    this._userShell = userShell
    /**
     * @type {boolean}
     * @private
     */
    this._pingTimeoutActive = false
    /**
     * @type {UserShellSurface}
     * @private
     */
    this._userShellSurface = null
    /**
     * @type {number}
     * @private
     */
    this._timeoutTimer = 0
    /**
     * @type {boolean}
     * @private
     */
    this._mapped = false
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @return {Promise<void>}
   * @override
   */
  async onCommit (surface, renderFrame, newState) {
    const oldPosition = surface.surfaceChildSelf.position
    surface.surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(oldPosition.x + newState.dx, oldPosition.y + newState.dy)

    if (newState.bufferContents) {
      if (!this._mapped) {
        this._map()
      }
    } else {
      if (this._mapped) {
        this._unmap()
      }
    }

    await surface.render(renderFrame, newState)
    renderFrame.fire()
    await renderFrame
    this.session.flush()
  }

  /**
   * @private
   */
  _map () {
    this._mapped = true
    if (this._userShellSurface) {
      this._userShellSurface.mapped = true
    }
  }

  /**
   * @private
   */
  _unmap () {
    this._mapped = false
    if (this._userShellSurface) {
      this._userShellSurface.mapped = false
    }
  }

  /**
   *
   *                A client must respond to a ping event with a pong request or
   *                the client may be deemed unresponsive.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {Number} serial serial number of the ping event
   *
   * @since 1
   * @override
   */
  pong (resource, serial) {
    if (this._pingTimeoutActive) {
      this._removeClassRecursively(/** @type {Surface} */this.wlSurfaceResource.implementation, 'fadeToUnresponsive')
      this._pingTimeoutActive = false
    }
    window.clearTimeout(this._timeoutTimer)
    const doPingTimer = window.setTimeout(() => {
      this._doPing(resource)
    }, 1000)
    this.wlSurfaceResource.onDestroy().then(() => {
      window.clearTimeout(doPingTimer)
    })
  }

  /**
   * @param {WlShellSurfaceResource} resource
   * @private
   */
  _doPing (resource) {
    this._timeoutTimer = window.setTimeout(() => {
      if (!this._pingTimeoutActive) {
        // ping timed out, make view gray
        this._pingTimeoutActive = true
        this._addClassRecursively(this.wlSurfaceResource.implementation, 'fadeToUnresponsive')
      }
    }, 3000)
    this.wlSurfaceResource.onDestroy().then(() => {
      window.clearTimeout(this._timeoutTimer)
    })
    resource.ping(0)
    this.session.flush()
  }

  /**
   * @param {Surface}surface
   * @param {string}cssClass
   * @private
   */
  _removeClassRecursively (surface, cssClass) {
    surface.views.forEach((view) => {
      view.bufferedCanvas.removeCssClass(cssClass)
    })
    surface.children.forEach((surfaceChild) => {
      if (surfaceChild.surface !== surface) {
        this._removeClassRecursively(surfaceChild.surface, cssClass)
      }
    })
  }

  /**
   * @param {Surface}surface
   * @param {string}cssClass
   * @private
   */
  _addClassRecursively (surface, cssClass) {
    surface.views.forEach((view) => {
      view.bufferedCanvas.addCssClass(cssClass)
    })
    surface.children.forEach((surfaceChild) => {
      if (surfaceChild.surface !== surface) {
        this._addClassRecursively(surfaceChild.surface, cssClass)
      }
    })
  }

  /**
   *
   *                Start a pointer-driven move of the surface.
   *
   *                This request must be used in response to a button press event.
   *                The server may ignore move requests depending on the state of
   *                the surface (e.g. fullscreen or maximized).
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {WlSeatResource} wlSeatResource seat whose pointer is used
   * @param {number} serial serial number of the implicit grab on the pointer
   *
   * @since 1
   * @override
   */
  move (resource, wlSeatResource, serial) {
    const seat = /** @type {Seat} */wlSeatResource.implementation

    if (!seat.isValidInputSerial(serial)) {
      false && console.log('move serial mismatch. Ignoring.')
      return
    }

    if (this.state === SurfaceStates.FULLSCREEN || this.state === SurfaceStates.MAXIMIZED) {
      return
    }
    const pointer = seat.pointer
    const surface = this.wlSurfaceResource.implementation
    const surfaceChildSelf = surface.surfaceChildSelf
    const origPosition = surfaceChildSelf.position

    const pointerX = pointer.x
    const pointerY = pointer.y

    const moveListener = () => {
      const deltaX = pointer.x - pointerX
      const deltaY = pointer.y - pointerY

      // TODO we could try to be smart, and only apply the latest move, depending on how often the render frame fires.
      surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(origPosition.x + deltaX, origPosition.y + deltaY)

      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_3__["default"].createRenderFrame()
      surface.views.forEach((view) => {
        view.applyTransformations(renderFrame)
      })
      renderFrame.fire()
    }

    pointer.onButtonRelease().then(() => {
      pointer.removeMouseMoveListener(moveListener)
    })
    pointer.addMouseMoveListener(moveListener)
  }

  /**
   *
   *                Start a pointer-driven resizing of the surface.
   *
   *                This request must be used in response to a button press event.
   *                The server may ignore resize requests depending on the state of
   *                the surface (e.g. fullscreen or maximized).
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {WlSeatResource} wlSeatResource seat whose pointer is used
   * @param {number} serial serial number of the implicit grab on the pointer
   * @param {number} edges which edge or corner is being dragged
   *
   * @since 1
   * @override
   */
  resize (resource, wlSeatResource, serial, edges) {
    const seat = /** @type {Seat} */wlSeatResource.implementation
    if (!seat.isValidInputSerial(serial)) {
      false && console.log('resize serial mismatch. Ignoring.')
      return
    }

    if (this.state === SurfaceStates.FULLSCREEN || this.state === SurfaceStates.MAXIMIZED) {
      return
    }

    const pointer = seat.pointer
    // assigned in switch statement
    let sizeAdjustment = (width, height, deltaX, deltaY) => {}

    switch (edges) {
      case bottomRight: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height + deltaY}
        }
        break
      }
      case top: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height - deltaY}
        }
        break
      }
      case bottom: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height + deltaY}
        }
        break
      }
      case left: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height}
        }
        break
      }
      case topLeft: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height - deltaY}
        }
        break
      }
      case bottomLeft: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height + deltaY}
        }
        break
      }
      case right: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height}
        }
        break
      }
      case topRight: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height - deltaY}
        }
        break
      }
      case none:
      default: {
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height}
        }
        break
      }
    }

    const pointerX = pointer.x
    const pointerY = pointer.y
    const {w: surfaceWidth, h: surfaceHeight} = this.wlSurfaceResource.implementation.size

    const resizeListener = () => {
      const deltaX = pointer.x - pointerX
      const deltaY = pointer.y - pointerY

      const size = sizeAdjustment(surfaceWidth, surfaceHeight, deltaX, deltaY)
      this.resource.configure(edges, size.w, size.h)
    }
    pointer.onButtonRelease().then(() => {
      pointer.removeMouseMoveListener(resizeListener)
    })
    pointer.addMouseMoveListener(resizeListener)
  }

  /**
   * @private
   */
  _createUserShellSurface () {
    this._userShellSurface = this._userShell.manage(/** @type {Surface} */this.wlSurfaceResource.implementation)
    this._userShellSurface.onActivationRequest = () => {
      this._userShellSurface.activationAck()
    }
    this._userShellSurface.onInactive = () => {
      // I don't think we need to do something here?
    }
    this._userShellSurface.title = this._title
    this._userShellSurface.appId = this._clazz
    this._userShellSurface.mapped = this._mapped
  }

  /**
   *
   *                Map the surface as a toplevel surface.
   *
   *                A toplevel surface is not fullscreen, maximized or transient.
   *
   *
   * @param {WlShellSurfaceResource} resource
   *
   * @since 1
   * @override
   */
  setToplevel (resource) {
    if (this.state === SurfaceStates.POPUP || this.state === SurfaceStates.TRANSIENT) {
      return
    }

    if (!this._userShellSurface) {
      this._createUserShellSurface()
    }
    this.state = SurfaceStates.TOP_LEVEL
  }

  /**
   *
   *                Map the surface relative to an existing surface.
   *
   *                The x and y arguments specify the location of the upper left
   *                corner of the surface relative to the upper left corner of the
   *                parent surface, in surface-local coordinates.
   *
   *                The flags argument controls details of the transient behaviour.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {WlSurfaceResource} parent parent surface
   * @param {number} x surface-local x coordinate
   * @param {number} y surface-local y coordinate
   * @param {number} flags transient surface behavior
   *
   * @since 1
   * @override
   */
  setTransient (resource, parent, x, y, flags) {
    if (this.state === SurfaceStates.POPUP || this.state === SurfaceStates.TOP_LEVEL) {
      return
    }

    const parentPosition = parent.implementation.surfaceChildSelf.position

    const surface = this.wlSurfaceResource.implementation
    const surfaceChild = surface.surfaceChildSelf
    // FIXME we probably want to provide a method to translate from (abstract) surface space to global space
    surfaceChild.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(parentPosition.x + x, parentPosition.y + y)

    this.wlSurfaceResource.implementation.hasKeyboardInput = (flags & inactive) === 0

    if (!this._userShellSurface) {
      this._createUserShellSurface()
    }
    this.state = SurfaceStates.TRANSIENT
  }

  /**
   *
   *                Map the surface as a fullscreen surface.
   *
   *                If an output parameter is given then the surface will be made
   *                fullscreen on that output. If the client does not specify the
   *                output then the compositor will apply its policy - usually
   *                choosing the output on which the surface has the biggest surface
   *                area.
   *
   *                The client may specify a method to resolve a size conflict
   *                between the output size and the surface size - this is provided
   *                through the method parameter.
   *
   *                The framerate parameter is used only when the method is set
   *                to "driver", to indicate the preferred framerate. A value of 0
   *                indicates that the client does not care about framerate.  The
   *                framerate is specified in mHz, that is framerate of 60000 is 60Hz.
   *
   *                A method of "scale" or "driver" implies a scaling operation of
   *                the surface, either via a direct scaling operation or a change of
   *                the output mode. This will override any kind of output scaling, so
   *                that mapping a surface with a buffer size equal to the mode can
   *                fill the screen independent of buffer_scale.
   *
   *                A method of "fill" means we don't scale up the buffer, however
   *                any output scale is applied. This means that you may run into
   *                an edge case where the application maps a buffer with the same
   *                size of the output mode but buffer_scale 1 (thus making a
   *                surface larger than the output). In this case it is allowed to
   *                downscale the results to fit the screen.
   *
   *                The compositor must reply to this request with a configure event
   *                with the dimensions for the output on which the surface will
   *                be made fullscreen.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {number} method method for resolving size conflict
   * @param {number} framerate framerate in mHz
   * @param {WlOutputResource|null} output output on which the surface is to be fullscreen
   *
   * @since 1
   * @override
   */
  setFullscreen (resource, method, framerate, output) {
    this.state = SurfaceStates.FULLSCREEN
    const surface = this.wlSurfaceResource.implementation
    // TODO get proper size in surface coordinates instead of assume surface space === global space
    surface.surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(0, 0)
    this.resource.configure(none, window.innerWidth, window.innerHeight)
  }

  /**
   *
   *                Map the surface as a popup.
   *
   *                A popup surface is a transient surface with an added pointer
   *                grab.
   *
   *                An existing implicit grab will be changed to owner-events mode,
   *                and the popup grab will continue after the implicit grab ends
   *                (i.e. releasing the mouse button does not cause the popup to
   *                be unmapped).
   *
   *                The popup grab continues until the window is destroyed or a
   *                mouse button is pressed in any other client's window. A click
   *                in any of the client's surfaces is reported as normal, however,
   *                clicks in other clients' surfaces will be discarded and trigger
   *                the callback.
   *
   *                The x and y arguments specify the location of the upper left
   *                corner of the surface relative to the upper left corner of the
   *                parent surface, in surface-local coordinates.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {WlSeatResource} wlSeatResource seat whose pointer is used
   * @param {number} serial serial number of the implicit grab on the pointer
   * @param {WlSurfaceResource} parent parent surface
   * @param {number} x surface-local x coordinate
   * @param {number} y surface-local y coordinate
   * @param {number} flags transient surface behavior
   *
   * @since 1
   * @override
   */
  async setPopup (resource, wlSeatResource, serial, parent, x, y, flags) {
    const seat = /** @type {Seat} */wlSeatResource.implementation
    // FIXME we can receive an older serial in case a popup is triggered from an older mouse down + mouse move
    // if (serial !== seat.inputSerial) {
    //   this._dismiss()
    //   DEBUG && console.log('Popup grab input serial mismatch. Ignoring.')
    //   return
    // }

    if (this.state) { return }

    const pointer = seat.pointer
    this.state = SurfaceStates.POPUP
    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation
    const surfaceChild = surface.surfaceChildSelf
    surfaceChild.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(x, y)
    const onNewView = (view) => {
      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_3__["default"].createRenderFrame()
      view.applyTransformations(renderFrame)
      renderFrame.fire()
      view.onDestroy().then(() => {
        view.detach()
      })
    }
    // having added this shell-surface to a parent will have it create a view for each parent view
    const views = parent.implementation.addChild(surfaceChild)
    views.forEach(onNewView)
    // this handles the case where a view is created later on (ie if a new parent view is created)
    surface.onViewCreated = onNewView

    surface.hasKeyboardInput = (flags & inactive) === 0

    // handle popup window grab
    await pointer.popupGrab(this.wlSurfaceResource)
    resource.popupDone()
  }

  /**
   *
   *                Map the surface as a maximized surface.
   *
   *                If an output parameter is given then the surface will be
   *                maximized on that output. If the client does not specify the
   *                output then the compositor will apply its policy - usually
   *                choosing the output on which the surface has the biggest surface
   *                area.
   *
   *                The compositor will reply with a configure event telling
   *                the expected new surface size. The operation is completed
   *                on the next buffer attach to this surface.
   *
   *                A maximized surface typically fills the entire output it is
   *                bound to, except for desktop elements such as panels. This is
   *                the main difference between a maximized shell surface and a
   *                fullscreen shell surface.
   *
   *                The details depend on the compositor implementation.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {?*} output output on which the surface is to be maximized
   *
   * @since 1
   * @override
   */
  setMaximized (resource, output) {
    this.state = SurfaceStates.MAXIMIZED
    const surface = this.wlSurfaceResource.implementation

    // TODO get proper size in surface coordinates instead of assume surface space === global space
    const x = 0
    const {height: y} = this._userShell.panel.getBoundingClientRect()
    const {width, height} = this._userShell.workspace.getBoundingClientRect()

    surface.surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(x, y)
    this.resource.configure(none, width, height)
  }

  /**
   *
   *                Set a short title for the surface.
   *
   *                This string may be used to identify the surface in a task bar,
   *                window list, or other user interface elements provided by the
   *                compositor.
   *
   *                The string must be encoded in UTF-8.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {string} title surface title
   *
   * @since 1
   * @override
   */
  setTitle (resource, title) {
    this._title = title
    if (this._userShellSurface) {
      this._userShellSurface.title = title
    }
  }

  /**
   *
   *                Set a class for the surface.
   *
   *                The surface class identifies the general class of applications
   *                to which the surface belongs. A common convention is to use the
   *                file name (or the full path if it is a non-standard location) of
   *                the application's .desktop file as the class.
   *
   *
   * @param {WlShellSurfaceResource} resource
   * @param {string} clazz surface class
   *
   * @since 1
   * @override
   */
  setClass (resource, clazz) {
    this._clazz = clazz
    if (this._userShellSurface) {
      this._userShellSurface.appId = clazz
    }
  }

  /**
   * @override
   */
  captureRoleState () {}

  /**
   * @param roleState
   * @override
   */
  setRoleState (roleState) {}
}


/***/ }),
/* 72 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlShellSurfaceRequests {

	/**
	 *
	 *	A client must respond to a ping event with a pong request or
	 *	the client may be deemed unresponsive.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {number} serial serial number of the ping event 
	 *
	 * @since 1
	 *
	 */
	pong(resource, serial) {}

	/**
	 *
	 *	Start a pointer-driven move of the surface.
	 *
	 *	This request must be used in response to a button press event.
	 *	The server may ignore move requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 *
	 * @since 1
	 *
	 */
	move(resource, seat, serial) {}

	/**
	 *
	 *	Start a pointer-driven resizing of the surface.
	 *
	 *	This request must be used in response to a button press event.
	 *	The server may ignore resize requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 * @param {number} edges which edge or corner is being dragged 
	 *
	 * @since 1
	 *
	 */
	resize(resource, seat, serial, edges) {}

	/**
	 *
	 *	Map the surface as a toplevel surface.
	 *
	 *	A toplevel surface is not fullscreen, maximized or transient.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	setToplevel(resource) {}

	/**
	 *
	 *	Map the surface relative to an existing surface.
	 *
	 *	The x and y arguments specify the location of the upper left
	 *	corner of the surface relative to the upper left corner of the
	 *	parent surface, in surface-local coordinates.
	 *
	 *	The flags argument controls details of the transient behaviour.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {*} parent parent surface 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} flags transient surface behavior 
	 *
	 * @since 1
	 *
	 */
	setTransient(resource, parent, x, y, flags) {}

	/**
	 *
	 *	Map the surface as a fullscreen surface.
	 *
	 *	If an output parameter is given then the surface will be made
	 *	fullscreen on that output. If the client does not specify the
	 *	output then the compositor will apply its policy - usually
	 *	choosing the output on which the surface has the biggest surface
	 *	area.
	 *
	 *	The client may specify a method to resolve a size conflict
	 *	between the output size and the surface size - this is provided
	 *	through the method parameter.
	 *
	 *	The framerate parameter is used only when the method is set
	 *	to "driver", to indicate the preferred framerate. A value of 0
	 *	indicates that the client does not care about framerate.  The
	 *	framerate is specified in mHz, that is framerate of 60000 is 60Hz.
	 *
	 *	A method of "scale" or "driver" implies a scaling operation of
	 *	the surface, either via a direct scaling operation or a change of
	 *	the output mode. This will override any kind of output scaling, so
	 *	that mapping a surface with a buffer size equal to the mode can
	 *	fill the screen independent of buffer_scale.
	 *
	 *	A method of "fill" means we don't scale up the buffer, however
	 *	any output scale is applied. This means that you may run into
	 *	an edge case where the application maps a buffer with the same
	 *	size of the output mode but buffer_scale 1 (thus making a
	 *	surface larger than the output). In this case it is allowed to
	 *	downscale the results to fit the screen.
	 *
	 *	The compositor must reply to this request with a configure event
	 *	with the dimensions for the output on which the surface will
	 *	be made fullscreen.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {number} method method for resolving size conflict 
	 * @param {number} framerate framerate in mHz 
	 * @param {?*} output output on which the surface is to be fullscreen 
	 *
	 * @since 1
	 *
	 */
	setFullscreen(resource, method, framerate, output) {}

	/**
	 *
	 *	Map the surface as a popup.
	 *
	 *	A popup surface is a transient surface with an added pointer
	 *	grab.
	 *
	 *	An existing implicit grab will be changed to owner-events mode,
	 *	and the popup grab will continue after the implicit grab ends
	 *	(i.e. releasing the mouse button does not cause the popup to
	 *	be unmapped).
	 *
	 *	The popup grab continues until the window is destroyed or a
	 *	mouse button is pressed in any other client's window. A click
	 *	in any of the client's surfaces is reported as normal, however,
	 *	clicks in other clients' surfaces will be discarded and trigger
	 *	the callback.
	 *
	 *	The x and y arguments specify the location of the upper left
	 *	corner of the surface relative to the upper left corner of the
	 *	parent surface, in surface-local coordinates.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 * @param {*} parent parent surface 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} flags transient surface behavior 
	 *
	 * @since 1
	 *
	 */
	setPopup(resource, seat, serial, parent, x, y, flags) {}

	/**
	 *
	 *	Map the surface as a maximized surface.
	 *
	 *	If an output parameter is given then the surface will be
	 *	maximized on that output. If the client does not specify the
	 *	output then the compositor will apply its policy - usually
	 *	choosing the output on which the surface has the biggest surface
	 *	area.
	 *
	 *	The compositor will reply with a configure event telling
	 *	the expected new surface size. The operation is completed
	 *	on the next buffer attach to this surface.
	 *
	 *	A maximized surface typically fills the entire output it is
	 *	bound to, except for desktop elements such as panels. This is
	 *	the main difference between a maximized shell surface and a
	 *	fullscreen shell surface.
	 *
	 *	The details depend on the compositor implementation.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {?*} output output on which the surface is to be maximized 
	 *
	 * @since 1
	 *
	 */
	setMaximized(resource, output) {}

	/**
	 *
	 *	Set a short title for the surface.
	 *
	 *	This string may be used to identify the surface in a task bar,
	 *	window list, or other user interface elements provided by the
	 *	compositor.
	 *
	 *	The string must be encoded in UTF-8.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {string} title surface title 
	 *
	 * @since 1
	 *
	 */
	setTitle(resource, title) {}

	/**
	 *
	 *	Set a class for the surface.
	 *
	 *	The surface class identifies the general class of applications
	 *	to which the surface belongs. A common convention is to use the
	 *	file name (or the full path if it is a non-standard location) of
	 *	the application's .desktop file as the class.
	 *      
	 *
	 * @param {WlShellSurfaceResource} resource 
	 * @param {string} clazz surface class 
	 *
	 * @since 1
	 *
	 */
	setClass(resource, clazz) {}
}

module.exports = WlShellSurfaceRequests


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _protocol_WlSeatRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _protocol_WlSeatRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSeatRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75);
/* harmony import */ var _protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/* harmony import */ var _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _protocol_WlTouchResource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(78);
/* harmony import */ var _protocol_WlTouchResource__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlTouchResource__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(79);
/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(81);
/* harmony import */ var _Touch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(84);
/* harmony import */ var _DataDevice__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(85);













const {keyboard, pointer, touch} = _protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1___default.a.Capability

/**
 *
 *            A seat is a group of keyboards, pointer and touch devices. This
 *            object is published as a global during start up, or when such a
 *            device is hot plugged.  A seat typically has a pointer and
 *            maintains a keyboard focus and a pointer focus.
 *
 */
class Seat extends _protocol_WlSeatRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {Session} session
   * @returns {Seat}
   */
  static create (session) {
    const dataDevice = _DataDevice__WEBPACK_IMPORTED_MODULE_8__["default"].create()
    const keyboard = _Keyboard__WEBPACK_IMPORTED_MODULE_6__["default"].create(session, dataDevice)
    const pointer = _Pointer__WEBPACK_IMPORTED_MODULE_5__["default"].create(session, dataDevice)
    const touch = _Touch__WEBPACK_IMPORTED_MODULE_7__["default"].create()
    const hasTouch = 'ontouchstart' in document.documentElement

    const seat = new Seat(dataDevice, pointer, keyboard, touch, hasTouch)
    dataDevice.seat = seat

    keyboard.seat = seat
    pointer.seat = seat
    touch.seat = seat

    return seat
  }

  /**
   * @param {!DataDevice} dataDevice
   * @param {Pointer} pointer
   * @param {Keyboard} keyboard
   * @param {Touch} touch
   * @param {boolean} hasTouch
   * @private
   */
  constructor (dataDevice, pointer, keyboard, touch, hasTouch) {
    super()
    /**
     * @type {!DataDevice}
     * @const
     */
    this.dataDevice = dataDevice
    /**
     * @type {!Pointer}
     * @const
     */
    this.pointer = pointer
    /**
     * @type {!Keyboard}
     * @const
     */
    this.keyboard = keyboard
    /**
     * @type {!Touch}
     * @const
     */
    this.touch = touch
    /**
     * @type {boolean}
     */
    this.hasTouch = hasTouch
    /**
     * @type {Global}
     * @private
     */
    this._global = null
    /**
     * @type {string}
     * @private
     * @const
     */
    this._seatName = 'browser-seat0'
    /**
     * @type {number}
     */
    this.serial = 0

    /**
     * @type {number}
     */
    this.buttonPressSerial = 0
    /**
     * @type {number}
     */
    this.buttonReleaseSerial = 0
    /**
     * @type {number}
     */
    this.keyPressSerial = 0
    /**
     * @type {number}
     */
    this.keyReleaseSerial = 0
    /**
     * @type {number}
     */
    this.touchDownSerial = 0
    /**
     * @type {number}
     */
    this.touchUpSerial = 0
    /**
     * @type {number}
     */
    this.enterSerial = 0
    /**
     * @type {Array<function(WlKeyboardResource):void>}
     * @private
     */
    this._keyboardResourceListeners = []
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1___default.a.name, 6, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  bindClient (client, id, version) {
    const wlSeatResource = new _protocol_WlSeatResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    wlSeatResource.implementation = this
    this._boundResources.push(wlSeatResource)

    wlSeatResource.onDestroy().then((resource) => {
      const index = this._boundResources.indexOf(resource)
      this._boundResources.splice(index, 1)
    })

    this._emitCapabilities(wlSeatResource)
    this._emitName(wlSeatResource)
  }

  /**
   * @param {WlSeatResource}wlSeatResource
   * @private
   */
  _emitCapabilities (wlSeatResource) {
    let caps = pointer | keyboard
    if (this.hasTouch) {
      caps |= touch
    }
    wlSeatResource.capabilities(caps)
  }

  /**
   * @param {WlSeatResource}wlSeatResource
   * @private
   */
  _emitName (wlSeatResource) {
    if (wlSeatResource.version >= 2) {
      wlSeatResource.name(this._seatName)
    }
  }

  /**
   * @return {number}
   */
  nextSerial () {
    this.serial++
    if (this.serial & (1 << 29)) {
      this.serial = 0
    }
    return this.serial
  }

  /**
   * @param {number}serial
   * @return {boolean}
   */
  isValidInputSerial (serial) {
    return serial === this.buttonPressSerial || serial === this.buttonReleaseSerial || serial === this.keyPressSerial ||
      serial === this.keyReleaseSerial || serial === this.touchDownSerial || serial === this.touchUpSerial
  }

  /**
   * @return {number}
   */
  nextEnterSerial () {
    this.enterSerial = this.nextSerial()
    return this.enterSerial
  }

  /**
   * @param {boolean}down
   * @return {number}
   */
  nextButtonSerial (down) {
    if (down) {
      const mask = 1 << 29
      this.buttonPressSerial = this.nextSerial() | mask
      return this.buttonPressSerial
    } else {
      const mask = 2 << 29
      this.buttonReleaseSerial = this.nextSerial() | mask
      return this.buttonReleaseSerial
    }
  }

  /**
   * @param {boolean}down
   * @return {number}
   */
  nextKeySerial (down) {
    if (down) {
      const mask = 3 << 29
      this.keyPressSerial = this.nextSerial() | mask
      return this.keyPressSerial
    } else {
      const mask = 4 << 29
      this.keyReleaseSerial = this.nextSerial() | mask
      return this.keyReleaseSerial
    }
  }

  /**
   * @param {boolean}down
   * @return {number}
   */
  nextTouchSerial (down) {
    if (down) {
      const mask = 5 << 29
      this.touchDownSerial = this.nextSerial() | mask
      return this.touchDownSerial
    } else {
      const mask = 6 << 29
      this.touchUpSerial = this.nextSerial() | mask
      return this.touchUpSerial
    }
  }

  /**
   *
   *                The ID provided will be initialized to the wl_pointer interface
   *                for this seat.
   *
   *                This request only takes effect if the seat has the pointer
   *                capability, or has had the pointer capability in the past.
   *                It is a protocol violation to issue this request on a seat that has
   *                never had the pointer capability.
   *
   *
   * @param {WlSeatResource} resource
   * @param {number} id seat pointer
   *
   * @since 1
   * @override
   */
  getPointer (resource, id) {
    const wlPointerResource = new _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    wlPointerResource.implementation = this.pointer
    this.pointer.resources.push(wlPointerResource)
    wlPointerResource.onDestroy().then(() => {
      const idx = this.pointer.resources.indexOf(wlPointerResource)
      if (idx > -1) {
        this.pointer.resources.splice(idx, 1)
      }
    })
  }

  /**
   *
   *                The ID provided will be initialized to the wl_keyboard interface
   *                for this seat.
   *
   *                This request only takes effect if the seat has the keyboard
   *                capability, or has had the keyboard capability in the past.
   *                It is a protocol violation to issue this request on a seat that has
   *                never had the keyboard capability.
   *
   *
   * @param {WlSeatResource} resource
   * @param {number} id seat keyboard
   *
   * @since 1
   * @override
   */
  getKeyboard (resource, id) {
    const wlKeyboardResource = new _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_3___default.a(resource.client, id, resource.version)
    wlKeyboardResource.implementation = this.keyboard
    this.keyboard.resources.push(wlKeyboardResource)
    wlKeyboardResource.onDestroy().then(() => {
      const idx = this.keyboard.resources.indexOf(wlKeyboardResource)
      if (idx > -1) {
        this.keyboard.resources.splice(idx, 1)
      }
    })

    this.keyboard.emitKeymap(wlKeyboardResource)
    this.keyboard.emitKeyRepeatInfo(wlKeyboardResource)
    this._keyboardResourceListeners.forEach((listener) => listener(wlKeyboardResource))
  }

  /**
   * @param {function(WlKeyboardResource):void}listener
   */
  addKeyboardResourceListener (listener) {
    this._keyboardResourceListeners.push(listener)
  }

  /**
   * @param {function(WlKeyboardResource):void}listener
   */
  removeKeyboardResourceListener (listener) {
    const idx = this._keyboardResourceListeners.indexOf(listener)
    if (idx > -1) {
      this._keyboardResourceListeners.splice(idx, 1)
    }
  }

  /**
   *
   *                The ID provided will be initialized to the wl_touch interface
   *                for this seat.
   *
   *                This request only takes effect if the seat has the touch
   *                capability, or has had the touch capability in the past.
   *                It is a protocol violation to issue this request on a seat that has
   *                never had the touch capability.
   *
   *
   * @param {WlSeatResource} resource
   * @param {number} id seat touch interface
   *
   * @since 1
   * @override
   */
  getTouch (resource, id) {
    const wlTouchResource = new _protocol_WlTouchResource__WEBPACK_IMPORTED_MODULE_4___default.a(resource.client, id, resource.version)
    this.touch.resources.push(wlTouchResource)

    if (this.hasTouch) {
      wlTouchResource.implementation = this.touch
    }
  }

  /**
   *
   *                Using this request a client can tell the server that it is not going to
   *                use the seat object anymore.
   *
   *
   * @param {WlSeatResource} resource
   *
   * @since 5
   * @override
   */
  release (resource) {
    resource.destroy()
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Seat);


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSeatRequests {

	/**
	 *
	 *	The ID provided will be initialized to the wl_pointer interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the pointer
	 *	capability, or has had the pointer capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the pointer capability.
	 *      
	 *
	 * @param {WlSeatResource} resource 
	 * @param {number} id seat pointer 
	 *
	 * @since 1
	 *
	 */
	getPointer(resource, id) {}

	/**
	 *
	 *	The ID provided will be initialized to the wl_keyboard interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the keyboard
	 *	capability, or has had the keyboard capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the keyboard capability.
	 *      
	 *
	 * @param {WlSeatResource} resource 
	 * @param {number} id seat keyboard 
	 *
	 * @since 1
	 *
	 */
	getKeyboard(resource, id) {}

	/**
	 *
	 *	The ID provided will be initialized to the wl_touch interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the touch
	 *	capability, or has had the touch capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the touch capability.
	 *      
	 *
	 * @param {WlSeatResource} resource 
	 * @param {number} id seat touch interface 
	 *
	 * @since 1
	 *
	 */
	getTouch(resource, id) {}

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the seat object anymore.
	 *      
	 *
	 * @param {WlSeatResource} resource 
	 *
	 * @since 5
	 *
	 */
	release(resource) {}
}

module.exports = WlSeatRequests


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A seat is a group of keyboards, pointer and touch devices. This
 *      object is published as a global during start up, or when such a
 *      device is hot plugged.  A seat typically has a pointer and
 *      maintains a keyboard focus and a pointer focus.
 *    
 */
class WlSeatResource extends Resource {

	/**
	 *
	 *	This is emitted whenever a seat gains or loses the pointer,
	 *	keyboard or touch capabilities.  The argument is a capability
	 *	enum containing the complete set of capabilities this seat has.
	 *
	 *	When the pointer capability is added, a client may create a
	 *	wl_pointer object using the wl_seat.get_pointer request. This object
	 *	will receive pointer events until the capability is removed in the
	 *	future.
	 *
	 *	When the pointer capability is removed, a client should destroy the
	 *	wl_pointer objects associated with the seat where the capability was
	 *	removed, using the wl_pointer.release request. No further pointer
	 *	events will be received on these objects.
	 *
	 *	In some compositors, if a seat regains the pointer capability and a
	 *	client has a previously obtained wl_pointer object of version 4 or
	 *	less, that object may start sending pointer events again. This
	 *	behavior is considered a misinterpretation of the intended behavior
	 *	and must not be relied upon by the client. wl_pointer objects of
	 *	version 5 or later must not send events if created before the most
	 *	recent event notifying the client of an added pointer capability.
	 *
	 *	The above behavior also applies to wl_keyboard and wl_touch with the
	 *	keyboard and touch capabilities, respectively.
	 *      
	 *
	 * @param {number} capabilities capabilities of the seat 
	 *
	 * @since 1
	 *
	 */
	capabilities (capabilities) {
		this.client.marshall(this.id, 0, [uint(capabilities)])
	}

	/**
	 *
	 *	In a multiseat configuration this can be used by the client to help
	 *	identify which physical devices the seat represents. Based on
	 *	the seat configuration used by the compositor.
	 *      
	 *
	 * @param {string} name seat identifier 
	 *
	 * @since 2
	 *
	 */
	name (name) {
		this.client.marshall(this.id, 1, [string(name)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlSeatRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.getPointer(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.getKeyboard(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.getTouch(this, ...args)
	}
	async [3] (message) {
		await this.implementation.release(this)
	}
}
WlSeatResource.protocolName = 'wl_seat'

WlSeatResource.Capability = {
  /**
   * the seat has pointer devices
   */
  pointer: 1,
  /**
   * the seat has one or more keyboards
   */
  keyboard: 2,
  /**
   * the seat has touch devices
   */
  touch: 4
}

module.exports = WlSeatResource


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The wl_pointer interface represents one or more input devices,
 *      such as mice, which control the pointer location and pointer_focus
 *      of a seat.
 *
 *      The wl_pointer interface generates motion, enter and leave
 *      events for the surfaces that the pointer is located over,
 *      and button and axis events for button presses, button releases
 *      and scrolling.
 *    
 */
class WlPointerResource extends Resource {

	/**
	 *
	 *	Notification that this seat's pointer is focused on a certain
	 *	surface.
	 *
	 *	When a seat's focus enters a surface, the pointer image
	 *	is undefined and a client should respond to this event by setting
	 *	an appropriate pointer image with the set_cursor request.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface surface entered by the pointer 
	 * @param {Fixed} surfaceX surface-local x coordinate 
	 * @param {Fixed} surfaceY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	enter (serial, surface, surfaceX, surfaceY) {
		this.client.marshall(this.id, 0, [uint(serial), object(surface), fixed(surfaceX), fixed(surfaceY)])
	}

	/**
	 *
	 *	Notification that this seat's pointer is no longer focused on
	 *	a certain surface.
	 *
	 *	The leave notification is sent before the enter notification
	 *	for the new focus.
	 *      
	 *
	 * @param {number} serial serial number of the leave event 
	 * @param {*} surface surface left by the pointer 
	 *
	 * @since 1
	 *
	 */
	leave (serial, surface) {
		this.client.marshall(this.id, 1, [uint(serial), object(surface)])
	}

	/**
	 *
	 *	Notification of pointer location change. The arguments
	 *	surface_x and surface_y are the location relative to the
	 *	focused surface.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {Fixed} surfaceX surface-local x coordinate 
	 * @param {Fixed} surfaceY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion (time, surfaceX, surfaceY) {
		this.client.marshall(this.id, 2, [uint(time), fixed(surfaceX), fixed(surfaceY)])
	}

	/**
	 *
	 *	Mouse button click and release notifications.
	 *
	 *	The location of the click is given by the last motion or
	 *	enter event.
	 *	The time argument is a timestamp with millisecond
	 *	granularity, with an undefined base.
	 *
	 *	The button is a button code as defined in the Linux kernel's
	 *	linux/input-event-codes.h header file, e.g. BTN_LEFT.
	 *
	 *	Any 16-bit button code value is reserved for future additions to the
	 *	kernel's event code list. All other button codes above 0xFFFF are
	 *	currently undefined but may be used in future versions of this
	 *	protocol.
	 *      
	 *
	 * @param {number} serial serial number of the button event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} button button that produced the event 
	 * @param {number} state physical state of the button 
	 *
	 * @since 1
	 *
	 */
	button (serial, time, button, state) {
		this.client.marshall(this.id, 3, [uint(serial), uint(time), uint(button), uint(state)])
	}

	/**
	 *
	 *	Scroll and other axis notifications.
	 *
	 *	For scroll events (vertical and horizontal scroll axes), the
	 *	value parameter is the length of a vector along the specified
	 *	axis in a coordinate space identical to those of motion events,
	 *	representing a relative movement along the specified axis.
	 *
	 *	For devices that support movements non-parallel to axes multiple
	 *	axis events will be emitted.
	 *
	 *	When applicable, for example for touch pads, the server can
	 *	choose to emit scroll events where the motion vector is
	 *	equivalent to a motion event vector.
	 *
	 *	When applicable, a client can transform its content relative to the
	 *	scroll distance.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} axis axis type 
	 * @param {Fixed} value length of vector in surface-local coordinate space 
	 *
	 * @since 1
	 *
	 */
	axis (time, axis, value) {
		this.client.marshall(this.id, 4, [uint(time), uint(axis), fixed(value)])
	}

	/**
	 *
	 *	Indicates the end of a set of events that logically belong together.
	 *	A client is expected to accumulate the data in all events within the
	 *	frame before proceeding.
	 *
	 *	All wl_pointer events before a wl_pointer.frame event belong
	 *	logically together. For example, in a diagonal scroll motion the
	 *	compositor will send an optional wl_pointer.axis_source event, two
	 *	wl_pointer.axis events (horizontal and vertical) and finally a
	 *	wl_pointer.frame event. The client may use this information to
	 *	calculate a diagonal vector for scrolling.
	 *
	 *	When multiple wl_pointer.axis events occur within the same frame,
	 *	the motion vector is the combined motion of all events.
	 *	When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
	 *	the same frame, this indicates that axis movement in one axis has
	 *	stopped but continues in the other axis.
	 *	When multiple wl_pointer.axis_stop events occur within the same
	 *	frame, this indicates that these axes stopped in the same instance.
	 *
	 *	A wl_pointer.frame event is sent for every logical event group,
	 *	even if the group only contains a single wl_pointer event.
	 *	Specifically, a client may get a sequence: motion, frame, button,
	 *	frame, axis, frame, axis_stop, frame.
	 *
	 *	The wl_pointer.enter and wl_pointer.leave events are logical events
	 *	generated by the compositor and not the hardware. These events are
	 *	also grouped by a wl_pointer.frame. When a pointer moves from one
	 *	surface to another, a compositor should group the
	 *	wl_pointer.leave event within the same wl_pointer.frame.
	 *	However, a client must not rely on wl_pointer.leave and
	 *	wl_pointer.enter being in the same wl_pointer.frame.
	 *	Compositor-specific policies may require the wl_pointer.leave and
	 *	wl_pointer.enter event being split across multiple wl_pointer.frame
	 *	groups.
	 *      
	 * @since 5
	 *
	 */
	frame () {
		this.client.marshall(this.id, 5, [])
	}

	/**
	 *
	 *	Source information for scroll and other axes.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_pointer.frame event and carries the source information for
	 *	all events within that frame.
	 *
	 *	The source specifies how this event was generated. If the source is
	 *	wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
	 *	sent when the user lifts the finger off the device.
	 *
	 *	If the source is wl_pointer.axis_source.wheel,
	 *	wl_pointer.axis_source.wheel_tilt or
	 *	wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
	 *	or may not be sent. Whether a compositor sends an axis_stop event
	 *	for these sources is hardware-specific and implementation-dependent;
	 *	clients must not rely on receiving an axis_stop event for these
	 *	scroll sources and should treat scroll sequences from these scroll
	 *	sources as unterminated by default.
	 *
	 *	This event is optional. If the source is unknown for a particular
	 *	axis event sequence, no event is sent.
	 *	Only one wl_pointer.axis_source event is permitted per frame.
	 *
	 *	The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
	 *	not guaranteed.
	 *      
	 *
	 * @param {number} axisSource source of the axis event 
	 *
	 * @since 5
	 *
	 */
	axisSource (axisSource) {
		this.client.marshall(this.id, 6, [uint(axisSource)])
	}

	/**
	 *
	 *	Stop notification for scroll and other axes.
	 *
	 *	For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
	 *	is sent to notify a client that the axis sequence has terminated.
	 *	This enables the client to implement kinetic scrolling.
	 *	See the wl_pointer.axis_source documentation for information on when
	 *	this event may be generated.
	 *
	 *	Any wl_pointer.axis events with the same axis_source after this
	 *	event should be considered as the start of a new axis motion.
	 *
	 *	The timestamp is to be interpreted identical to the timestamp in the
	 *	wl_pointer.axis event. The timestamp value may be the same as a
	 *	preceding wl_pointer.axis event.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} axis the axis stopped with this event 
	 *
	 * @since 5
	 *
	 */
	axisStop (time, axis) {
		this.client.marshall(this.id, 7, [uint(time), uint(axis)])
	}

	/**
	 *
	 *	Discrete step information for scroll and other axes.
	 *
	 *	This event carries the axis value of the wl_pointer.axis event in
	 *	discrete steps (e.g. mouse wheel clicks).
	 *
	 *	This event does not occur on its own, it is coupled with a
	 *	wl_pointer.axis event that represents this axis value on a
	 *	continuous scale. The protocol guarantees that each axis_discrete
	 *	event is always followed by exactly one axis event with the same
	 *	axis number within the same wl_pointer.frame. Note that the protocol
	 *	allows for other events to occur between the axis_discrete and
	 *	its coupled axis event, including other axis_discrete or axis
	 *	events.
	 *
	 *	This event is optional; continuous scrolling devices
	 *	like two-finger scrolling on touchpads do not have discrete
	 *	steps and do not generate this event.
	 *
	 *	The discrete value carries the directional information. e.g. a value
	 *	of -2 is two steps towards the negative direction of this axis.
	 *
	 *	The axis number is identical to the axis number in the associated
	 *	axis event.
	 *
	 *	The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
	 *	not guaranteed.
	 *      
	 *
	 * @param {number} axis axis type 
	 * @param {number} discrete number of steps 
	 *
	 * @since 5
	 *
	 */
	axisDiscrete (axis, discrete) {
		this.client.marshall(this.id, 8, [uint(axis), int(discrete)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlPointerRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'u?oii')
		await this.implementation.setCursor(this, ...args)
	}
	async [1] (message) {
		await this.implementation.release(this)
	}
}
WlPointerResource.protocolName = 'wl_pointer'

WlPointerResource.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

WlPointerResource.ButtonState = {
  /**
   * the button is not pressed
   */
  released: 0,
  /**
   * the button is pressed
   */
  pressed: 1
}

WlPointerResource.Axis = {
  /**
   * vertical axis
   */
  verticalScroll: 0,
  /**
   * horizontal axis
   */
  horizontalScroll: 1
}

WlPointerResource.AxisSource = {
  /**
   * a physical wheel rotation
   */
  wheel: 0,
  /**
   * finger on a touch surface
   */
  finger: 1,
  /**
   * continuous coordinate space
   */
  continuous: 2,
  /**
   * a physical wheel tilt
   */
  wheelTilt: 3
}

module.exports = WlPointerResource


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The wl_keyboard interface represents one or more keyboards
 *      associated with a seat.
 *    
 */
class WlKeyboardResource extends Resource {

	/**
	 *
	 *	This event provides a file descriptor to the client which can be
	 *	memory-mapped to provide a keyboard mapping description.
	 *      
	 *
	 * @param {number} format keymap format 
	 * @param {number} fd keymap file descriptor 
	 * @param {number} size keymap size, in bytes 
	 *
	 * @since 1
	 *
	 */
	keymap (format, fd, size) {
		this.client.marshall(this.id, 0, [uint(format), fileDescriptor(fd), uint(size)])
	}

	/**
	 *
	 *	Notification that this seat's keyboard focus is on a certain
	 *	surface.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface surface gaining keyboard focus 
	 * @param {TypedArray} keys the currently pressed keys 
	 *
	 * @since 1
	 *
	 */
	enter (serial, surface, keys) {
		this.client.marshall(this.id, 1, [uint(serial), object(surface), array(keys)])
	}

	/**
	 *
	 *	Notification that this seat's keyboard focus is no longer on
	 *	a certain surface.
	 *
	 *	The leave notification is sent before the enter notification
	 *	for the new focus.
	 *      
	 *
	 * @param {number} serial serial number of the leave event 
	 * @param {*} surface surface that lost keyboard focus 
	 *
	 * @since 1
	 *
	 */
	leave (serial, surface) {
		this.client.marshall(this.id, 2, [uint(serial), object(surface)])
	}

	/**
	 *
	 *	A key was pressed or released.
	 *	The time argument is a timestamp with millisecond
	 *	granularity, with an undefined base.
	 *      
	 *
	 * @param {number} serial serial number of the key event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} key key that produced the event 
	 * @param {number} state physical state of the key 
	 *
	 * @since 1
	 *
	 */
	key (serial, time, key, state) {
		this.client.marshall(this.id, 3, [uint(serial), uint(time), uint(key), uint(state)])
	}

	/**
	 *
	 *	Notifies clients that the modifier and/or group state has
	 *	changed, and it should update its local state.
	 *      
	 *
	 * @param {number} serial serial number of the modifiers event 
	 * @param {number} modsDepressed depressed modifiers 
	 * @param {number} modsLatched latched modifiers 
	 * @param {number} modsLocked locked modifiers 
	 * @param {number} group keyboard layout 
	 *
	 * @since 1
	 *
	 */
	modifiers (serial, modsDepressed, modsLatched, modsLocked, group) {
		this.client.marshall(this.id, 4, [uint(serial), uint(modsDepressed), uint(modsLatched), uint(modsLocked), uint(group)])
	}

	/**
	 *
	 *	Informs the client about the keyboard's repeat rate and delay.
	 *
	 *	This event is sent as soon as the wl_keyboard object has been created,
	 *	and is guaranteed to be received by the client before any key press
	 *	event.
	 *
	 *	Negative values for either rate or delay are illegal. A rate of zero
	 *	will disable any repeating (regardless of the value of delay).
	 *
	 *	This event can be sent later on as well with a new value if necessary,
	 *	so clients should continue listening for the event past the creation
	 *	of wl_keyboard.
	 *      
	 *
	 * @param {number} rate the rate of repeating keys in characters per second 
	 * @param {number} delay delay in milliseconds since key down until repeating starts 
	 *
	 * @since 4
	 *
	 */
	repeatInfo (rate, delay) {
		this.client.marshall(this.id, 5, [int(rate), int(delay)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlKeyboardRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.release(this)
	}
}
WlKeyboardResource.protocolName = 'wl_keyboard'

WlKeyboardResource.KeymapFormat = {
  /**
   * no keymap; client must understand how to interpret the raw keycode
   */
  noKeymap: 0,
  /**
   * libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
   */
  xkbV1: 1
}

WlKeyboardResource.KeyState = {
  /**
   * key is not pressed
   */
  released: 0,
  /**
   * key is pressed
   */
  pressed: 1
}

module.exports = WlKeyboardResource


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The wl_touch interface represents a touchscreen
 *      associated with a seat.
 *
 *      Touch interactions can consist of one or more contacts.
 *      For each contact, a series of events is generated, starting
 *      with a down event, followed by zero or more motion events,
 *      and ending with an up event. Events relating to the same
 *      contact point can be identified by the ID of the sequence.
 *    
 */
class WlTouchResource extends Resource {

	/**
	 *
	 *	A new touch point has appeared on the surface. This touch point is
	 *	assigned a unique ID. Future events from this touch point reference
	 *	this ID. The ID ceases to be valid after a touch up event and may be
	 *	reused in the future.
	 *      
	 *
	 * @param {number} serial serial number of the touch down event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {*} surface surface touched 
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	down (serial, time, surface, id, x, y) {
		this.client.marshall(this.id, 0, [uint(serial), uint(time), object(surface), int(id), fixed(x), fixed(y)])
	}

	/**
	 *
	 *	The touch point has disappeared. No further events will be sent for
	 *	this touch point and the touch point's ID is released and may be
	 *	reused in a future touch down event.
	 *      
	 *
	 * @param {number} serial serial number of the touch up event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} id the unique ID of this touch point 
	 *
	 * @since 1
	 *
	 */
	up (serial, time, id) {
		this.client.marshall(this.id, 1, [uint(serial), uint(time), int(id)])
	}

	/**
	 *
	 *	A touch point has changed coordinates.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion (time, id, x, y) {
		this.client.marshall(this.id, 2, [uint(time), int(id), fixed(x), fixed(y)])
	}

	/**
	 *
	 *	Indicates the end of a set of events that logically belong together.
	 *	A client is expected to accumulate the data in all events within the
	 *	frame before proceeding.
	 *
	 *	A wl_touch.frame terminates at least one event but otherwise no
	 *	guarantee is provided about the set of events within a frame. A client
	 *	must assume that any state not updated in a frame is unchanged from the
	 *	previously known state.
	 *      
	 * @since 1
	 *
	 */
	frame () {
		this.client.marshall(this.id, 3, [])
	}

	/**
	 *
	 *	Sent if the compositor decides the touch stream is a global
	 *	gesture. No further events are sent to the clients from that
	 *	particular gesture. Touch cancellation applies to all touch points
	 *	currently active on this client's surface. The client is
	 *	responsible for finalizing the touch points, future touch points on
	 *	this surface may reuse the touch point ID.
	 *      
	 * @since 1
	 *
	 */
	cancel () {
		this.client.marshall(this.id, 4, [])
	}

	/**
	 *
	 *	Sent when a touchpoint has changed its shape.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_touch.frame event and carries the new shape information for
	 *	any previously reported, or new touch points of that frame.
	 *
	 *	Other events describing the touch point such as wl_touch.down,
	 *	wl_touch.motion or wl_touch.orientation may be sent within the
	 *	same wl_touch.frame. A client should treat these events as a single
	 *	logical touch point update. The order of wl_touch.shape,
	 *	wl_touch.orientation and wl_touch.motion is not guaranteed.
	 *	A wl_touch.down event is guaranteed to occur before the first
	 *	wl_touch.shape event for this touch ID but both events may occur within
	 *	the same wl_touch.frame.
	 *
	 *	A touchpoint shape is approximated by an ellipse through the major and
	 *	minor axis length. The major axis length describes the longer diameter
	 *	of the ellipse, while the minor axis length describes the shorter
	 *	diameter. Major and minor are orthogonal and both are specified in
	 *	surface-local coordinates. The center of the ellipse is always at the
	 *	touchpoint location as reported by wl_touch.down or wl_touch.move.
	 *
	 *	This event is only sent by the compositor if the touch device supports
	 *	shape reports. The client has to make reasonable assumptions about the
	 *	shape if it did not receive this event.
	 *      
	 *
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} major length of the major axis in surface-local coordinates 
	 * @param {Fixed} minor length of the minor axis in surface-local coordinates 
	 *
	 * @since 6
	 *
	 */
	shape (id, major, minor) {
		this.client.marshall(this.id, 5, [int(id), fixed(major), fixed(minor)])
	}

	/**
	 *
	 *	Sent when a touchpoint has changed its orientation.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_touch.frame event and carries the new shape information for
	 *	any previously reported, or new touch points of that frame.
	 *
	 *	Other events describing the touch point such as wl_touch.down,
	 *	wl_touch.motion or wl_touch.shape may be sent within the
	 *	same wl_touch.frame. A client should treat these events as a single
	 *	logical touch point update. The order of wl_touch.shape,
	 *	wl_touch.orientation and wl_touch.motion is not guaranteed.
	 *	A wl_touch.down event is guaranteed to occur before the first
	 *	wl_touch.orientation event for this touch ID but both events may occur
	 *	within the same wl_touch.frame.
	 *
	 *	The orientation describes the clockwise angle of a touchpoint's major
	 *	axis to the positive surface y-axis and is normalized to the -180 to
	 *	+180 degree range. The granularity of orientation depends on the touch
	 *	device, some devices only support binary rotation values between 0 and
	 *	90 degrees.
	 *
	 *	This event is only sent by the compositor if the touch device supports
	 *	orientation reports.
	 *      
	 *
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} orientation angle between major axis and positive surface y-axis in degrees 
	 *
	 * @since 6
	 *
	 */
	orientation (id, orientation) {
		this.client.marshall(this.id, 6, [int(id), fixed(orientation)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlTouchRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.release(this)
	}
}
WlTouchResource.protocolName = 'wl_touch'

module.exports = WlTouchResource


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pointer; });
/* harmony import */ var _protocol_WlPointerRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _protocol_WlPointerRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlPointerRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _EncodingOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _Region__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);










const {pressed, released} = _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1___default.a.ButtonState
const {horizontalScroll, verticalScroll} = _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1___default.a.Axis
const {wheel} = _protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1___default.a.AxisSource

// translates between browser button codes & kernel code as expected by wayland protocol
const linuxInput = {
  // left
  0: 0x110,
  // middle
  1: 0x112,
  // right
  2: 0x111,
  // browser back
  3: 0x116,
  // browser forward
  4: 0x115
}

/**
 *
 *            The wl_pointer interface represents one or more input devices,
 *            such as mice, which control the pointer location and pointer_focus
 *            of a seat.
 *
 *            The wl_pointer interface generates motion, enter and leave
 *            events for the surfaces that the pointer is located over,
 *            and button and axis events for button presses, button releases
 *            and scrolling.
 *            @implements {SurfaceRole}
 *            @implements {WlPointerRequests}
 *
 */
class Pointer extends _protocol_WlPointerRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {!Session} session
   * @param {!DataDevice} dataDevice
   * @returns {!Pointer}
   */
  static create (session, dataDevice) {
    const pointer = new Pointer(dataDevice)
    document.addEventListener('mousemove', (event) => {
      const mouseEvent = /** @type {MouseEvent} */ event
      if (pointer._handleMouseMove(mouseEvent)) {
        mouseEvent.preventDefault()
        mouseEvent.stopPropagation()
        session.flush()
      }
    })
    document.addEventListener('mouseup', (event) => {
      const mouseEvent = /** @type {MouseEvent} */ event
      if (pointer._handleMouseUp(mouseEvent)) {
        mouseEvent.preventDefault()
        mouseEvent.stopPropagation()
        session.flush()
      }
    })
    document.addEventListener('mousedown', (event) => {
      const mouseEvent = /** @type {MouseEvent} */ event
      if (pointer._handleMouseDown(mouseEvent)) {
        mouseEvent.preventDefault()
        mouseEvent.stopPropagation()
        session.flush()
      }
    })
    document.addEventListener('wheel', (event) => {
      const wheelEvent = /** @type {WheelEvent} */ event
      if (pointer._handleWheel(wheelEvent)) {
        wheelEvent.preventDefault()
        wheelEvent.stopPropagation()
        session.flush()
      }
    })
    // other mouse events are set in the surface view class
    return pointer
  }

  /**
   * Use Pointer.create(..) instead.
   * @private
   * @param {!DataDevice} dataDevice
   */
  constructor (dataDevice) {
    super()
    /**
     * @type {!DataDevice}
     * @const
     * @private
     */
    this._dataDevice = dataDevice
    /**
     * @type {!Array<WlPointerResource>}
     */
    this.resources = []
    /**
     * @type {?View}
     */
    this.focus = null
    /**
     * Currently active surface grab (if any)
     * @type {?View}
     */
    this.grab = null
    /**
     * @type {!Array<{popup: WlSurfaceResource, resolve: function():void, promise: Promise<void>}>}
     * @private
     */
    this._popupStack = []
    /**
     * @type {!number}
     */
    this.x = 0
    /**
     * @type {!number}
     */
    this.y = 0
    /**
     * @type {?WlSurfaceResource}
     * @private
     */
    this._cursorSurface = null
    /**
     * @type {?View}
     * @private
     */
    this._view = null
    /**
     * @type {!function():void}
     * @private
     */
    this._cursorDestroyListener = () => {
      this._cursorSurface = null
      this.setDefaultCursor()
    }
    /**
     * @type {!number}
     * @private
     */
    this._btnDwnCount = 0
    /**
     * @type {!Array<function>}
     * @private
     */
    this._mouseMoveListeners = []
    /**
     * @type {!number}
     */
    this.hotspotX = 0
    /**
     * @type {!number}
     */
    this.hotspotY = 0
    /**
     * @type {?Promise}
     * @private
     */
    this._buttonPressPromise = null
    /**
     * @type {?function(MouseEvent):void}
     * @private
     */
    this._buttonPressResolve = null
    /**
     * @type {?Promise}
     * @private
     */
    this._buttonReleasePromise = null
    /**
     * @type {?function(MouseEvent):void}
     * @private
     */
    this._buttonReleaseResolve = null
    /**
     * @type {?Seat}
     */
    this.seat = null
  }

  onButtonPress () {
    if (!this._buttonPressPromise) {
      this._buttonPressPromise = new Promise((resolve) => {
        this._buttonPressResolve = resolve
      }).then(() => {
        this._buttonPressPromise = null
        this._buttonPressResolve = null
      })
    }
    return this._buttonPressPromise
  }

  onButtonRelease () {
    if (!this._buttonReleasePromise) {
      this._buttonReleasePromise = new Promise((resolve) => {
        this._buttonReleaseResolve = resolve
      }).then(() => {
        this._buttonReleasePromise = null
        this._buttonReleaseResolve = null
      })
    }
    return this._buttonReleasePromise
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @return {Promise<void>}
   * @override
   */
  async onCommit (surface, renderFrame, newState) {
    this.hotspotX -= newState.dx
    this.hotspotY -= newState.dy

    const hotspotX = this.hotspotX
    const hotspotY = this.hotspotY

    if (this._cursorSurface && this._cursorSurface.implementation === surface) {
      if (newState.bufferContents) {
        const fullFrame = _EncodingOptions__WEBPACK_IMPORTED_MODULE_4__["default"].fullFrame(newState.bufferContents.encodingOptions)
        const splitAlpha = _EncodingOptions__WEBPACK_IMPORTED_MODULE_4__["default"].splitAlpha(newState.bufferContents.encodingOptions)
        if (fullFrame && !splitAlpha) {
          await surface.render(renderFrame, newState, true)
          const imageBlob = new Blob([newState.bufferContents.fragments[0].opaque], {'type': newState.bufferContents.encodingType})
          window.document.body.style.cursor = `url("${URL.createObjectURL(imageBlob)}") ${hotspotX} ${hotspotY}, pointer`

          renderFrame.fire()
          await renderFrame
        } else {
          await surface.render(renderFrame, newState)

          const dataURL = this._view.bufferedCanvas.frontContext.canvas.toDataURL()
          window.document.body.style.cursor = `url("${dataURL}") ${hotspotX} ${hotspotY}, pointer`

          renderFrame.fire()
          await renderFrame
        }
      }
    }

    surface.session.flush()
  }

  /**
   *
   *                Set the pointer surface, i.e., the surface that contains the
   *                pointer image (cursor). This request gives the surface the role
   *                of a cursor. If the surface already has another role, it raises
   *                a protocol error.
   *
   *                The cursor actually changes only if the pointer
   *                focus for this device is one of the requesting client's surfaces
   *                or the surface parameter is the current pointer surface. If
   *                there was a previous surface set with this request it is
   *                replaced. If surface is NULL, the pointer image is hidden.
   *
   *                The parameters hotspot_x and hotspot_y define the position of
   *                the pointer surface relative to the pointer location. Its
   *                top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
   *                where (x, y) are the coordinates of the pointer location, in
   *                surface-local coordinates.
   *
   *                On surface.attach requests to the pointer surface, hotspot_x
   *                and hotspot_y are decremented by the x and y parameters
   *                passed to the request. Attach must be confirmed by
   *                wl_surface.commit as usual.
   *
   *                The hotspot can also be updated by passing the currently set
   *                pointer surface to this request with new values for hotspot_x
   *                and hotspot_y.
   *
   *                The current and pending input regions of the wl_surface are
   *                cleared, and wl_surface.set_input_region is ignored until the
   *                wl_surface is no longer used as the cursor. When the use as a
   *                cursor ends, the current and pending input regions become
   *                undefined, and the wl_surface is unmapped.
   *
   *
   * @param {WlPointerResource} resource
   * @param {number} serial serial number of the enter event
   * @param {WlSurfaceResource|null} surfaceResource pointer surface
   * @param {number} hotspotX surface-local x coordinate
   * @param {number} hotspotY surface-local y coordinate
   *
   * @since 1
   *
   */
  setCursor (resource, serial, surfaceResource, hotspotX, hotspotY) {
    const surface = /** @type {Surface} */surfaceResource.implementation
    if (surface.role && surface.role !== this) {
      resource.postError(_protocol_WlPointerResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.role, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role')
      return
    }

    if (this._dataDevice.dndSourceClient) {
      return
    }
    if (serial !== this.seat.enterSerial) {
      return
    }
    this.setCursorInternal(surfaceResource, hotspotX, hotspotY)
  }

  /**
   * @param {WlSurfaceResource}popup
   * @return {Promise<void>}
   */
  popupGrab (popup) {
    // check if there already is an existing grab
    let popupGrab = this.findPopupGrab(popup)
    if (this.findPopupGrab(popup)) {
      // TODO return null instead? (grabbing something already grabbed is smelly)
      return popupGrab.promise
    }

    let popupGrabEndResolve = null
    let popupGrabEndPromise = new Promise((resolve) => {
      popup.onDestroy().then(() => {
        resolve()
      })
      popupGrabEndResolve = resolve
    })

    popupGrab = {
      popup: popup,
      resolve: popupGrabEndResolve,
      promise: popupGrabEndPromise
    }
    this._popupStack.push(popupGrab)

    popupGrabEndPromise.then(() => {
      const popupGrabIdx = this._popupStack.indexOf(popupGrab)
      if (popupGrabIdx > -1) {
        const nestedPopupGrabs = this._popupStack.slice(popupGrabIdx)
        // all nested popup grabs above the resolved popup grab also need to be removed
        this._popupStack.splice(popupGrabIdx)
        // nested array includes the already closed popup, shift will remove it from the array
        nestedPopupGrabs.shift()
        nestedPopupGrabs.reverse().forEach((nestedPopupGrab) => {
          nestedPopupGrab.resolve()
        })
      }
    })

    // clear any pointer button press grab
    this.grab = null
    this._btnDwnCount = 0

    return popupGrabEndPromise
  }

  /**
   * @param {WlSurfaceResource}popup
   * @return {{popup: WlSurfaceResource, resolve: Function, promise: Promise} | null}
   */
  findPopupGrab (popup) {
    const popupGrab = this._popupStack.find((popupGrab) => {
      return popupGrab.popup === popup
    })
    // do the OR, else we're returning 'undefined'
    return popupGrab || null
  }

  /**
   * @param {?WlSurfaceResource}surfaceResource
   * @param {number} hotspotX surface-local x coordinate
   * @param {number} hotspotY surface-local y coordinate
   */
  setCursorInternal (surfaceResource, hotspotX, hotspotY) {
    this.hotspotX = hotspotX
    this.hotspotY = hotspotY

    if (this._cursorSurface) {
      this._cursorSurface.removeDestroyListener(this._cursorDestroyListener)
      this._cursorSurface.implementation.role = null
    }
    this._cursorSurface = surfaceResource

    if (surfaceResource) {
      const surface = /** @type {Surface} */surfaceResource.implementation
      if (this._view) {
        this._view.destroy()
      }
      this._view = surface.createView()
      surface.resource.addDestroyListener(this._cursorDestroyListener)
      surface.role = this
      surface.state.inputPixmanRegion = _Region__WEBPACK_IMPORTED_MODULE_5__["default"].createPixmanRegion()
      surface._pendingInputRegion = _Region__WEBPACK_IMPORTED_MODULE_5__["default"].createPixmanRegion()
    } else {
      window.document.body.style.cursor = 'none'
    }
  }

  /**
   *
   *                Using this request a client can tell the server that it is not going to
   *                use the pointer object anymore.
   *
   *                This request destroys the pointer proxy object, so clients must not call
   *                wl_pointer_destroy() after using this request.
   *
   *
   * @param {WlPointerResource} resource
   *
   * @since 3
   *
   */
  release (resource) {
    resource.destroy()
    const index = this.resources.indexOf(resource)
    if (index > -1) {
      this.resources.splice(index, 1)
    }
  }

  /**
   * @param {function}func
   */
  addMouseMoveListener (func) {
    this._mouseMoveListeners.push(func)
  }

  /**
   * @param {function}func
   */
  removeMouseMoveListener (func) {
    const index = this._mouseMoveListeners.indexOf(func)
    if (index > -1) {
      this._mouseMoveListeners.splice(index, 1)
    }
  }

  /**
   * @param {MouseEvent}event
   */
  _focusFromEvent (event) {
    const focusCandidate = event.target

    if (focusCandidate.view &&
      !focusCandidate.view.destroyed &&
      focusCandidate.view.surface &&
      focusCandidate.view.surface.hasPointerInput) {
      return focusCandidate.view
    }

    return null
  }

  /**
   * @param {MouseEvent}event
   * @return {boolean}
   * @private
   */
  _handleMouseMove (event) {
    let consumed = false
    this.x = event.clientX < 0 ? 0 : event.clientX
    this.y = event.clientY < 0 ? 0 : event.clientY

    let currentFocus = this._focusFromEvent(event)

    const nroPopups = this._popupStack.length
    if (nroPopups && currentFocus &&
      currentFocus.surface.resource.client !== this._popupStack[nroPopups - 1].popup.client) {
      currentFocus = null
    }

    if (this._dataDevice.dndSourceClient) {
      this._dataDevice.onMouseMotion(currentFocus)
      return true
    }

    // if we don't have a grab, update the focus
    if (!this.grab) {
      if (currentFocus !== this.focus) {
        this.unsetFocus()
        if (currentFocus) {
          this.setFocus(currentFocus)
        } else {
          this.setDefaultCursor()
        }
      }
    }

    this._mouseMoveListeners.forEach(listener => listener(this.focus))

    if (this.focus && this.focus.surface) {
      consumed = true
      const surfacePoint = this._calculateSurfacePoint(this.focus)
      const surfaceResource = this.focus.surface.resource
      this._doPointerEventFor(surfaceResource, (pointerResource) => {
        pointerResource.motion(event.timeStamp, westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2___default.a.parseFixed(surfacePoint.x), westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2___default.a.parseFixed(surfacePoint.y))
        if (pointerResource.version >= 5) {
          pointerResource.frame()
        }
      })
    }

    return consumed
  }

  /**
   * @param {WlSurfaceResource} surfaceResource
   * @param {Function}action
   * @private
   */
  _doPointerEventFor (surfaceResource, action) {
    this.resources.forEach(pointerResource => {
      if (pointerResource.client === surfaceResource.client) {
        action(pointerResource)
      }
    })
  }

  /**
   * @param {MouseEvent}event
   * @return {boolean}
   * @private
   */
  _handleMouseUp (event) {
    let consumed = false
    if (this._dataDevice.dndSourceClient) {
      this._dataDevice.onMouseUp()
      return true
    }

    const nroPopups = this._popupStack.length

    if (this.focus && this.focus.surface) {
      consumed = true

      if (this.grab || nroPopups) {
        const surfaceResource = this.focus.surface.resource
        this._doPointerEventFor(surfaceResource, (pointerResource) => {
          pointerResource.button(this.seat.nextButtonSerial(false), event.timeStamp, linuxInput[event.button], released)
          if (pointerResource.version >= 5) {
            pointerResource.frame()
          }
        })
      }

      if (this.grab) {
        this._btnDwnCount--
        if (this._btnDwnCount === 0) {
          this.grab = null
        }
      }
    } else if (nroPopups) {
      const focus = this._focusFromEvent(event)
      // popup grab ends when user has clicked on another client's surface
      const popupGrab = this._popupStack[nroPopups - 1]
      if (!focus || (popupGrab.popup.implementation.state.bufferContents && focus.surface.resource.client !== popupGrab.popup.client)) {
        popupGrab.resolve()
      }
    }

    if (this._buttonReleaseResolve) {
      this._buttonReleaseResolve(event)
    }

    return consumed
  }

  /**
   * @param {MouseEvent}event
   * @return {boolean}
   * @private
   */
  _handleMouseDown (event) {
    let consumed = this._handleMouseMove(event)

    if (this.focus && this.focus.surface) {
      consumed = true
      if (this.grab === null && this._popupStack.length === 0) {
        this.grab = this.focus
      }

      if (!this._popupStack.length) {
        this._btnDwnCount++
      }

      const surfaceResource = this.focus.surface.resource
      this._doPointerEventFor(surfaceResource, (pointerResource) => {
        pointerResource.button(this.seat.nextButtonSerial(true), event.timeStamp, linuxInput[event.button], pressed)
        if (pointerResource.version >= 5) {
          pointerResource.frame()
        }
      })
    }

    if (this._buttonPressResolve) {
      this._buttonPressResolve(event)
    }

    return consumed
  }

  /**
   * @param {View}view
   * @return {Point}
   * @private
   */
  _calculateSurfacePoint (view) {
    const mousePoint = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(this.x, this.y)
    return view.toSurfaceSpace(mousePoint)
  }

  /**
   * @param {HTMLCanvasElement}canvas
   * @return {Boolean}
   * @private
   */
  _isPointerWithinInputRegion (canvas) {
    if (canvas.view) {
      const view = canvas.view
      const surfacePoint = this._calculateSurfacePoint(view)
      return view.surface.isWithinInputRegion(surfacePoint)
    } else {
      return false
    }
  }

  /**
   * @return {View | null}
   */
  calculateFocus () {
    const focusCandidates = window.document.elementsFromPoint(this.x, this.y)

    let zOrder = -1
    let focus = {view: null}
    focusCandidates.forEach(focusCandidate => {
      if (focusCandidate.view &&
        !focusCandidate.view.destroyed &&
        focusCandidate.view.surface &&
        focusCandidate.view.surface.hasPointerInput &&
        this._isPointerWithinInputRegion(focusCandidate) &&
        window.parseInt(focusCandidate.style.zIndex) > zOrder) {
        zOrder = focusCandidate.style.zIndex
        focus = focusCandidate
      }
    })

    return focus.view
  }

  /**
   * @param {View}newFocus
   */
  setFocus (newFocus) {
    this.focus = newFocus
    const surfaceResource = this.focus.surface.resource
    newFocus.onDestroy().then(() => {
      if (!this.focus) {
        return
      }
      if (newFocus !== this.focus) {
        return
      }
      // recalculate focus and consequently enter event
      const focus = this.calculateFocus()
      if (focus) {
        this.setFocus(focus)
      } else {
        this.unsetFocus()
        this.setDefaultCursor()
      }
    })

    const surfacePoint = this._calculateSurfacePoint(newFocus)
    this._doPointerEventFor(surfaceResource, (pointerResource) => {
      pointerResource.enter(this.seat.nextEnterSerial(), surfaceResource, westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2___default.a.parseFixed(surfacePoint.x), westfield_runtime_server__WEBPACK_IMPORTED_MODULE_2___default.a.parseFixed(surfacePoint.y))
    })
  }

  unsetFocus () {
    if (this.focus && !this.focus.destroyed && this.focus.surface) {
      const surfaceResource = this.focus.surface.resource
      this._doPointerEventFor(surfaceResource, (pointerResource) => {
        pointerResource.leave(this.seat.nextSerial(), surfaceResource)
        if (pointerResource.version >= 5) {
          pointerResource.frame()
        }
      })
    }

    this.focus = null
    this.grab = null
    this.view = null
    this._btnDwnCount = 0
    if (this._cursorSurface) {
      this._cursorSurface.implementation.role = null
      this._cursorSurface = null
    }
  }

  setDefaultCursor () {
    window.document.body.style.cursor = 'auto'
  }

  /**
   * @param {WheelEvent}event
   * @return {boolean}
   */
  _handleWheel (event) {
    let consumed = false
    if (this.focus && this.focus.surface) {
      consumed = true
      // TODO configure the scoll transform through the config menu
      /**
       * @type{Function}
       */
      let deltaTransform
      switch (event.deltaMode) {
        case event.DOM_DELTA_LINE: {
          /**
           * @param {number}delta
           * @return {number}
           */
          deltaTransform = (delta) => { return delta * 18 } // FIXME We hard code line height.
          break
        }
        case event.DOM_DELTA_PAGE: {
          /**
           * @param {number}delta
           * @param {number}axis
           * @return {number}
           */
          deltaTransform = (delta, axis) => {
            if (axis === verticalScroll) {
              return delta * this.focus.surface.size.h
            } else { // horizontalScroll
              return delta * this.focus.surface.size.w
            }
          }
          break
        }
        case event.DOM_DELTA_PIXEL:
        default: {
          /**
           * @param {number}delta
           * @return {number}
           */
          deltaTransform = (delta) => { return delta }
          break
        }
      }

      const surfaceResource = this.focus.surface.resource
      this._doPointerEventFor(surfaceResource, (pointerResource) => {
        const deltaX = event.deltaX
        if (deltaX) {
          const xAxis = horizontalScroll
          if (pointerResource.version >= 5) {
            pointerResource.axisDiscrete(xAxis, deltaX)
          }
          const scrollAmount = deltaTransform(deltaX, xAxis)
          pointerResource.axis(event.timeStamp, xAxis, parseFixed(scrollAmount))
        }
        const deltaY = event.deltaY
        if (deltaY) {
          const yAxis = verticalScroll
          if (pointerResource.version >= 5) {
            pointerResource.axisDiscrete(yAxis, deltaY)
          }
          const scrollAmount = deltaTransform(deltaY, yAxis)
          pointerResource.axis(event.timeStamp, yAxis, parseFixed(scrollAmount))
        }
        if (pointerResource.version >= 5) {
          pointerResource.axisSource(wheel)
          pointerResource.frame()
        }
      })
    }
    return consumed
  }

  /**
   * @override
   */
  captureRoleState () {
    // NO-OP
  }

  /**
   * @param roleState
   * @override
   */
  setRoleState (roleState) {
    // NO-OP
  }
}


/***/ }),
/* 80 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlPointerRequests {

	/**
	 *
	 *	Set the pointer surface, i.e., the surface that contains the
	 *	pointer image (cursor). This request gives the surface the role
	 *	of a cursor. If the surface already has another role, it raises
	 *	a protocol error.
	 *
	 *	The cursor actually changes only if the pointer
	 *	focus for this device is one of the requesting client's surfaces
	 *	or the surface parameter is the current pointer surface. If
	 *	there was a previous surface set with this request it is
	 *	replaced. If surface is NULL, the pointer image is hidden.
	 *
	 *	The parameters hotspot_x and hotspot_y define the position of
	 *	the pointer surface relative to the pointer location. Its
	 *	top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
	 *	where (x, y) are the coordinates of the pointer location, in
	 *	surface-local coordinates.
	 *
	 *	On surface.attach requests to the pointer surface, hotspot_x
	 *	and hotspot_y are decremented by the x and y parameters
	 *	passed to the request. Attach must be confirmed by
	 *	wl_surface.commit as usual.
	 *
	 *	The hotspot can also be updated by passing the currently set
	 *	pointer surface to this request with new values for hotspot_x
	 *	and hotspot_y.
	 *
	 *	The current and pending input regions of the wl_surface are
	 *	cleared, and wl_surface.set_input_region is ignored until the
	 *	wl_surface is no longer used as the cursor. When the use as a
	 *	cursor ends, the current and pending input regions become
	 *	undefined, and the wl_surface is unmapped.
	 *      
	 *
	 * @param {WlPointerResource} resource 
	 * @param {number} serial serial number of the enter event 
	 * @param {?*} surface pointer surface 
	 * @param {number} hotspotX surface-local x coordinate 
	 * @param {number} hotspotY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	setCursor(resource, serial, surface, hotspotX, hotspotY) {}

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the pointer object anymore.
	 *
	 *	This request destroys the pointer proxy object, so clients must not call
	 *	wl_pointer_destroy() after using this request.
	 *      
	 *
	 * @param {WlPointerResource} resource 
	 *
	 * @since 3
	 *
	 */
	release(resource) {}
}

module.exports = WlPointerRequests


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Keyboard; });
/* harmony import */ var _protocol_WlKeyboardRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82);
/* harmony import */ var _protocol_WlKeyboardRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlKeyboardRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Xkb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
/* harmony import */ var _RtcBlobTransfer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);








const {pressed, released} = _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_1___default.a.KeyState
const {xkbV1} = _protocol_WlKeyboardResource__WEBPACK_IMPORTED_MODULE_1___default.a.KeymapFormat

/**
 *
 *            The wl_keyboard interface represents one or more keyboards
 *            associated with a seat.
 * @implements WlKeyboardRequests
 */
class Keyboard extends _protocol_WlKeyboardRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {!Session}session
   * @param {!DataDevice} dataDevice
   * @return {!Keyboard}
   */
  static create (session, dataDevice) {
    const keyboard = new Keyboard(dataDevice)
    // TODO get the keymap from some config source
    // TODO make available in config menu
    keyboard.updateKeymap('qwerty.xkb')

    document.addEventListener('keyup', (event) => {
      const keyboardEvent = /** @type {KeyboardEvent} */ event
      if (keyboard._handleKey(keyboardEvent, false)) {
        keyboardEvent.preventDefault()
        keyboardEvent.stopPropagation()
        session.flush()
      }
    })
    document.addEventListener('keydown', (event) => {
      const keyboardEvent = /** @type {KeyboardEvent} */ event
      if (keyboard._handleKey(keyboardEvent, true)) {
        keyboardEvent.preventDefault()
        keyboardEvent.stopPropagation()
        session.flush()
      }
    })

    return keyboard
  }

  /**
   * Use Keyboard.create(..) instead.
   * @private
   * @param {!DataDevice} dataDevice
   */
  constructor (dataDevice) {
    super()
    /**
     * @type {!DataDevice}
     * @const
     * @private
     */
    this._dataDevice = dataDevice
    /**
     * @type {!Array<WlKeyboardResource>}
     */
    this.resources = []
    /**
     * @type {?Xkb}
     * @private
     */
    this._xkb = null
    /**
     * @type {?Surface}
     */
    this._focus = null
    /**
     * @type {?Array<number>}
     * @private
     */
    this._keys = []
    /**
     * @type {?Array<function():void>}
     * @private
     */
    this._keyboardFocusListeners = []
    /**
     * @type {?function():void|null}
     * @private
     */
    this._keyboardFocusResolve = null
    /**
     * @type {?Promise<void>}
     * @private
     */
    this._keyboardFocusPromise = null
    /**
     * @type {?Seat}
     */
    this.seat = null
  }

  /**
   * @param {!function():void}listener
   */
  addKeyboardFocusListener (listener) {
    this._keyboardFocusListeners.push(listener)
  }

  /**
   * @param {!function():void}listener
   */
  removeKeyboardFocusListener (listener) {
    const idx = this._keyboardFocusListeners.indexOf(listener)
    if (idx > 0) {
      this._keyboardFocusListeners.splice(idx, 1)
    }
  }

  /**
   * @return {Promise<void>}
   */
  onKeyboardFocusChanged () {
    if (!this._keyboardFocusPromise) {
      this._keyboardFocusPromise = new Promise((resolve) => {
        this._keyboardFocusResolve = resolve
      }).then(() => {
        this._keyboardFocusPromise = null
        this._keyboardFocusResolve = null
      })
    }

    return this._keyboardFocusPromise
  }

  /**
   *
   * @param {!WlKeyboard} resource
   *
   * @since 3
   *
   */
  release (resource) {
    resource.destroy()
    const index = this.resources.indexOf(resource)
    if (index > -1) {
      this.resources.splice(index, 1)
    }
  }

  /**
   * @param {!string}keymapFileName
   */
  async updateKeymap (keymapFileName) {
    const xkb = await _Xkb__WEBPACK_IMPORTED_MODULE_2__["default"].createFromResource(keymapFileName)
    if (this._xkb) {
      // TODO cleanup previous keymap state
    }
    this._xkb = xkb
    this.resources.forEach(async (resource) => {
      await this.emitKeymap(resource)
    })
  }

  /**
   * @param {!WlKeyboardResource}resource
   */
  async emitKeymap (resource) {
    const keymapString = this._xkb.asString()
    const textEncoder = new TextEncoder('utf-8')
    const keymapBuffer = textEncoder.encode(keymapString)
    const keymapBufferLength = keymapBuffer.buffer.byteLength
    const blobDescriptor = _RtcBlobTransfer__WEBPACK_IMPORTED_MODULE_3__["default"].createDescriptor(true, 'arraybuffer')
    resource.keymap(xkbV1, blobDescriptor, keymapBufferLength)

    // cleanup of the blob transfer is initiated at the other end.
    const rtcBlobTransfer = await _RtcBlobTransfer__WEBPACK_IMPORTED_MODULE_3__["default"].get(blobDescriptor)
    rtcBlobTransfer.rtcPeerConnection.ensureP2S()
    const rtcDataChannel = await rtcBlobTransfer.open()
    // chrome doesn't like chunks > 16KB
    const maxChunkSize = 16 * 1000 // 1000 instead of 1024 to be on the safe side.

    if (keymapBufferLength > maxChunkSize) {
      const nroChunks = Math.ceil(keymapBufferLength / maxChunkSize)
      for (let i = 0; i < nroChunks; i++) {
        const chunk = keymapBuffer.slice(i * maxChunkSize, (i + 1) * maxChunkSize)
        rtcDataChannel.send(chunk.buffer)
      }
    } else {
      rtcDataChannel.send(keymapBuffer.buffer)
    }
  }

  /**
   * @param {!Surface}focus
   */
  focusGained (focus) {
    if (!focus.hasKeyboardInput || this.focus === focus) {
      return
    }
    if (this.focus) {
      this.focusLost()
    }

    if (focus) {
      this.focus = focus
      this._dataDevice.onKeyboardFocusGained(focus)

      focus.resource.onDestroy().then(() => {
        if (this.focus === focus) {
          this.focus = null
        }
      })

      const serial = this.seat.nextSerial()
      const surface = this.focus.resource
      const keys = new Uint8Array(this._keys).buffer

      this.resources.filter((resource) => {
        return resource.client === this.focus.resource.client
      }).forEach((resource) => {
        resource.enter(serial, surface, keys)
      })
      if (this._keyboardFocusResolve) {
        this._keyboardFocusResolve()
      }
      this._keyboardFocusListeners.forEach((listener) => {
        listener()
      })
    }
  }

  focusLost () {
    if (this.focus) {
      const serial = this.seat.nextSerial()
      const surface = this.focus.resource

      this.resources.filter((resource) => {
        return resource.client === this.focus.resource.client
      }).forEach((resource) => {
        resource.leave(serial, surface)
      })

      this.focus = null
    }
  }

  /**
   * @param {?Surface}surface
   */
  set focus (surface) {
    this._focus = surface
    if (this._keyboardFocusResolve) {
      this._keyboardFocusResolve()
    }
    this._keyboardFocusListeners.forEach((listener) => {
      listener()
    })
  }

  /**
   * @return {?Surface}
   */
  get focus () {
    return this._focus
  }

  /**
   *
   * @param {!KeyboardEvent}event
   * @param {!boolean}down
   * @return {!boolean}
   */
  _handleKey (event, down) {
    let consumed = false
    const keyCode = event.code
    const linuxKeyCode = _Xkb__WEBPACK_IMPORTED_MODULE_2__["default"].linuxKeycode[keyCode]
    if (down && this._keys.includes(linuxKeyCode)) {
      // prevent key repeat from browser
      return false
    }

    const modsUpdate = down ? this._xkb.keyDown(linuxKeyCode) : this._xkb.keyUp(linuxKeyCode)
    if (down) {
      this._keys.push(linuxKeyCode)
    } else {
      const index = this._keys.indexOf(linuxKeyCode)
      if (index > -1) {
        this._keys.splice(index, 1)
      }
    }

    if (this.focus) {
      consumed = true
      const time = event.timeStamp
      const evdevKeyCode = linuxKeyCode - 8
      const state = down ? pressed : released
      const serial = this.seat.nextKeySerial(down)

      const modsDepressed = this._xkb.modsDepressed
      const modsLatched = this._xkb.modsLatched
      const modsLocked = this._xkb.modsLocked
      const group = this._xkb.group

      this.resources.filter((resource) => {
        return resource.client === this.focus.resource.client
      }).forEach((resource) => {
        resource.key(serial, time, evdevKeyCode, state)
        if (modsUpdate) {
          resource.modifiers(serial, modsDepressed, modsLatched, modsLocked, group)
        }
      })
    }

    return consumed
  }

  /**
   * @param {!WlKeyboardResource}resource
   */
  emitKeyRepeatInfo (resource) {
    if (resource.version >= 4) {
      // TODO get this from some config source
      // TODO make available in config menu
      resource.repeatInfo(40, 400)
    }
  }
}


/***/ }),
/* 82 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlKeyboardRequests {

	/**
	 *
	 * @param {WlKeyboardResource} resource 
	 *
	 * @since 3
	 *
	 */
	release(resource) {}
}

module.exports = WlKeyboardRequests


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Xkb; });
/* harmony import */ var _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);




const XKB_KEYMAP_FORMAT_TEXT_V1 = 1
const XKB_CONTEXT_NO_DEFAULT_INCLUDES = 1 << 0
const XKB_CONTEXT_NO_ENVIRONMENT_NAMES = 1 << 1
const XKB_KEYMAP_COMPILE_NO_FLAGS = 0
const XKB_KEY_UP = 0
const XKB_KEY_DOWN = 1
const XKB_STATE_MODS_DEPRESSED = (1 << 0)
const XKB_STATE_MODS_LATCHED = (1 << 1)
const XKB_STATE_MODS_LOCKED = (1 << 2)
const XKB_STATE_LAYOUT_EFFECTIVE = (1 << 7)

class Xkb {
  /**
   * @param {string}resource file name of the remote resource. Resource should be an xkb keymap.
   * @return {Promise<Xkb>}
   */
  static createFromResource (resource) {
    return new Promise((resolve, reject) => {
      const xhr = new window.XMLHttpRequest()

      xhr.onreadystatechange = () => {
        if (xhr.readyState === window.XMLHttpRequest.DONE && xhr.status === 200) {
          const mappingFile = xhr.responseText
          try {
            const xkb = Xkb.create(mappingFile)
            resolve(xkb)
          } catch (error) {
            reject(error)
          }
        } // TODO reject if we have something else than 2xx
      }

      xhr.open('GET', `/keymaps/${resource}`)
      xhr.send()
    })
  }

  /**
   * @param {string}keymapLayout an xkb keymap as a single string.
   * @return {Xkb}
   */
  static create (keymapLayout) {
    const keymapLayoutPtr = _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._malloc(_lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"].lengthBytesUTF8(keymapLayout) + 1)
    _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"].stringToUTF8(keymapLayout, keymapLayoutPtr, _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"].lengthBytesUTF8(keymapLayout) + 1)

    const xkbContext = _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_context_new(XKB_CONTEXT_NO_DEFAULT_INCLUDES | XKB_CONTEXT_NO_ENVIRONMENT_NAMES)
    const keymap = _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_keymap_new_from_string(xkbContext, keymapLayoutPtr, XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS)
    const state = _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_new(keymap)

    _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._free(keymapLayoutPtr)

    return new Xkb(xkbContext, keymap, state)
  }

  /**
   * Use Xkb.create(..) or Xkb.createFromResource(..)
   * @private
   * @param {number}xkbContext
   * @param {number}keymap
   * @param {number}state
   */
  constructor (xkbContext, keymap, state) {
    this.xkbContext = xkbContext
    this.keymap = keymap
    this.state = state
    this._stateComponentMask = 0
  }

  asString () {
    const keymapStringPtr = _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_keymap_get_as_string(this.keymap, XKB_KEYMAP_FORMAT_TEXT_V1)
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"].Pointer_stringify(keymapStringPtr)
  }

  /**
   *
   * @param {number}linuxKeyCode
   */
  keyUp (linuxKeyCode) {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_update_key(this.state, linuxKeyCode, XKB_KEY_UP) !== 0
  }

  /**
   *
   * @param {number}linuxKeyCode
   */
  keyDown (linuxKeyCode) {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_update_key(this.state, linuxKeyCode, XKB_KEY_DOWN) !== 0
  }

  get modsDepressed () {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_serialize_mods(this.state, XKB_STATE_MODS_DEPRESSED)
  }

  get modsLatched () {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_serialize_mods(this.state, XKB_STATE_MODS_LATCHED)
  }

  get modsLocked () {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_serialize_mods(this.state, XKB_STATE_MODS_LOCKED)
  }

  get group () {
    return _lib_libxkbcommon__WEBPACK_IMPORTED_MODULE_0__["default"]._xkb_state_serialize_layout(this.state, XKB_STATE_LAYOUT_EFFECTIVE)
  }
}
// convert browser neutral key codes (which are strings *sigh*) to linux (x11) keycode
Xkb.linuxKeycode = {
  'Escape': 0x0009,
  'Digit1': 0x000A,
  'Digit2': 0x000B,
  'Digit3': 0x000C,
  'Digit4': 0x000D,
  'Digit5': 0x000E,
  'Digit6': 0x000F,
  'Digit7': 0x0010,
  'Digit8': 0x0011,
  'Digit9': 0x0012,
  'Digit0': 0x0013,
  'Minus': 0x0014,
  'Equal': 0x0015,
  'Backspace': 0x0016,
  'Tab': 0x0017,
  'KeyQ': 0x0018,
  'KeyW': 0x0019,
  'KeyE': 0x001A,
  'KeyR': 0x001B,
  'KeyT': 0x001C,
  'KeyY': 0x001D,
  'KeyU': 0x001E,
  'KeyI': 0x001F,
  'KeyO': 0x0020,
  'KeyP': 0x0021,
  'BracketLeft': 0x0022,
  'BracketRight': 0x0023,
  'Enter': 0x0024,
  'ControlLeft': 0x0025,
  'KeyA': 0x0026,
  'KeyS': 0x0027,
  'KeyD': 0x0028,
  'KeyF': 0x0029,
  'KeyG': 0x002A,
  'KeyH': 0x002B,
  'KeyJ': 0x002C,
  'KeyK': 0x002D,
  'KeyL': 0x002E,
  'Semicolon': 0x002F,
  'Quote': 0x0030,
  'Backquote': 0x0031,
  'ShiftLeft': 0x0032,
  'Backslash': 0x0033,
  'KeyZ': 0x0034,
  'KeyX': 0x0035,
  'KeyC': 0x0036,
  'KeyV': 0x0037,
  'KeyB': 0x0038,
  'KeyN': 0x0039,
  'KeyM': 0x003A,
  'Comma': 0x003B,
  'Period': 0x003C,
  'Slash': 0x003D,
  'ShiftRight': 0x003E,
  'NumpadMultiply': 0x003F,
  'AltLeft': 0x0040,
  'Space': 0x0041,
  'CapsLock': 0x0042,
  'F1': 0x0043,
  'F2': 0x0044,
  'F3': 0x0045,
  'F4': 0x0046,
  'F5': 0x0047,
  'F6': 0x0048,
  'F7': 0x0049,
  'F8': 0x004A,
  'F9': 0x004B,
  'F10': 0x004C,
  'NumLock': 0x004D,
  'ScrollLock': 0x004E,
  'Numpad7': 0x004F,
  'Numpad8': 0x0050,
  'Numpad9': 0x0051,
  'NumpadSubtract': 0x0052,
  'Numpad4': 0x0053,
  'Numpad5': 0x0054,
  'Numpad6': 0x0055,
  'NumpadAdd': 0x0056,
  'Numpad1': 0x0057,
  'Numpad2': 0x0058,
  'Numpad3': 0x0059,
  'Numpad0': 0x005A,
  'NumpadDecimal': 0x005B,
  'IntlBackslash': 0x005E,
  'F11': 0x005F,
  'F12': 0x0060,
  'IntlRo': 0x0061,
  'Convert': 0x0064,
  'KanaMode': 0x0065,
  'NonConvert': 0x0066,
  'NumpadEnter': 0x0068,
  'ControlRight': 0x0069,
  'NumpadDivide': 0x006A,
  'PrintScreen': 0x006B,
  'AltRight': 0x006C,
  'Home': 0x006E,
  'ArrowUp': 0x006F,
  'PageUp': 0x0070,
  'ArrowLeft': 0x0071,
  'ArrowRight': 0x0072,
  'End': 0x0073,
  'ArrowDown': 0x0074,
  'PageDown': 0x0075,
  'Insert': 0x0076,
  'Delete': 0x0077,
  'NumpadEqual': 0x007D,
  'Pause': 0x007F,
  'IntlYen': 0x0084,
  'OSLeft': 0x0085,
  'OSRight': 0x0086,
  'ContextMenu': 0x0087
}


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Touch; });


/**
 *
 *            The gr_touch interface represents a touchscreen
 *            associated with a seat.
 *
 *            Touch interactions can consist of one or more contacts.
 *            For each contact, a series of events is generated, starting
 *            with a down event, followed by zero or more motion events,
 *            and ending with an up event. Events relating to the same
 *            contact point can be identified by the ID of the sequence.
 *
 */
class Touch {
  /**
   * @returns {Touch}
   */
  static create () {
    return new Touch()
  }

  constructor () {
    /**
     * @type {Array<WlTouchResource>}
     */
    this.resources = []
    /**
     * @type {Seat}
     */
    this.seat = null
  }

  /**
   *
   * @param {WlTouchResource} resource
   *
   * @since 3
   *
   */
  release (resource) {
    resource.destroy()
    const index = this.resources.indexOf(resource)
    if (index > -1) {
      this.resources.splice(index, 1)
    }
  }
}


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataDevice; });
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlDataDeviceRequests__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86);
/* harmony import */ var _protocol_WlDataDeviceRequests__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceRequests__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var _protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(29);
/* harmony import */ var _DataOffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(90);











const DndAction = _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_3___default.a.DndAction

/**
 *
 *            There is one wl_data_device per seat which can be obtained
 *            from the global wl_data_device_manager singleton.
 *
 *            A wl_data_device provides access to inter-client data transfer
 *            mechanisms such as copy-and-paste and drag-and-drop.
 * @implements WlDataDeviceRequests
 */
class DataDevice extends _protocol_WlDataDeviceRequests__WEBPACK_IMPORTED_MODULE_1___default.a {
  /**
   * @return {DataDevice}
   */
  static create () {
    return new DataDevice()
  }

  /**
   * Use DataDevice.create(..) instead.
   * @private
   */
  constructor () {
    super()
    /**
     * @type {Array<WlDataDeviceResource>}
     */
    this.resources = []
    /**
     * @type {Seat}
     */
    this.seat = null
    /**
     * @type {WlDataSourceResource}
     */
    this.dndSource = null
    /**
     * @type {WlDataSourceResource}
     */
    this.selectionSource = null
    /**
     * @type {View}
     */
    this.dndFocus = null
    /**
     * @type {Client}
     * @private
     */
    this.dndSourceClient = null
    /**
     * @type {Surface}
     * @private
     */
    this._selectionFocus = null
    /**
     * @type {function():void}
     * @private
     */
    this._dndSourceDestroyListener = () => {
      this._handleDndSourceDestroy()
    }
    /**
     * @type {function():void}
     * @private
     */
    this._selectionSourceDestroyListener = () => {
      this._handleSelectionSourceDestroy()
    }
  }

  /**
   * @param {Client}client
   * @return {WlDataDeviceResource | null}
   * @private
   */
  _dataDeviceForClient (client) {
    const dataDeviceResource = this.resources.find((dataDeviceResource) => {
      return dataDeviceResource.client === client
    })
    // safeguard against undefined
    return dataDeviceResource == null ? null : dataDeviceResource
  }

  _handleDndSourceDestroy () {
    const dataDeviceResource = this._dataDeviceForClient(this.dndSourceClient)
    if (dataDeviceResource === null) {
      return
    }
    dataDeviceResource.leave()
    this.dndSourceClient = null
  }

  _handleSelectionSourceDestroy () {
    if (this._selectionFocus === null) {
      return
    }

    const surfaceResource = this._selectionFocus.resource
    const client = surfaceResource.client

    const dataDeviceResource = this._dataDeviceForClient(client)
    if (dataDeviceResource == null) {
      return
    }

    dataDeviceResource.selection(null)
    this.selectionSource = null
  }

  /**
   *
   *                This request asks the compositor to start a drag-and-drop
   *                operation on behalf of the client.
   *
   *                The source argument is the data source that provides the data
   *                for the eventual data transfer. If source is NULL, enter, leave
   *                and motion events are sent only to the client that initiated the
   *                drag and the client is expected to handle the data passing
   *                internally.
   *
   *                The origin surface is the surface where the drag originates and
   *                the client must have an active implicit wlab that matches the
   *                serial.
   *
   *                The icon surface is an optional (can be NULL) surface that
   *                provides an icon to be moved around with the cursor.  Initially,
   *                the top-left corner of the icon surface is placed at the cursor
   *                hotspot, but subsequent wl_surface.attach request can move the
   *                relative position. Attach requests must be confirmed with
   *                wl_surface.commit as usual. The icon surface is given the role of
   *                a drag-and-drop icon. If the icon surface already has another role,
   *                it raises a protocol error.
   *
   *                The current and pending input regions of the icon wl_surface are
   *                cleared, and wl_surface.set_input_region is ignored until the
   *                wl_surface is no longer used as the icon surface. When the use
   *                as an icon ends, the current and pending input regions become
   *                undefined, and the wl_surface is unmapped.
   *
   *
   * @param {WlDataDeviceResource} resource
   * @param {WlDataSourceResource|null} source data source for the eventual transfer
   * @param {WlSurfaceResource} origin surface where the drag originates
   * @param {WlSurfaceResource|null} icon drag-and-drop icon surface
   * @param {number} serial serial number of the implicit grab on the origin
   *
   * @since 1
   * @override
   */
  startDrag (resource, source, origin, icon, serial) {
    const iconSurface = /** @type {Surface} */ icon.implementation
    if (iconSurface.role) {
      resource.postError(_protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.role, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role.')
      return
    }

    const pointer = this.seat.pointer

    if (this.seat.serial !== serial) {
      return
    }
    if (pointer.grab.surface.resource !== origin) {
      return
    }

    const dndFocus = pointer.focus
    // clear all previous mouse state (focus+grab)
    pointer.unsetFocus()
    if (icon !== null) {
      pointer.setCursorInternal(icon, 0, 0)
    }

    this.dndSourceClient = resource.client

    /*
     * From the specs:
     * For objects of version 2 or older, wl_data_source.cancelled will only be emitted if the data source was
     * replaced by another data source.
     */
    if (this.dndSource) {
      this.dndSource.removeDestroyListener(this._dndSourceDestroyListener)
    }

    this.dndSource = source
    if (this.dndSource) {
      this.dndSource.addDestroyListener(this._dndSourceDestroyListener)
    }

    if (dndFocus) {
      this._onFocusGained(dndFocus)
    }
  }

  /**
   * @param {View}focus
   */
  onMouseMotion (focus) {
    if (this.dndFocus !== focus) {
      if (this.dndFocus) {
        this._onFocusLost()
      }
      if (focus) {
        this._onFocusGained(focus)
      }
    }

    this.dndFocus = focus
    if (!this.dndFocus) {
      return
    }

    const surfaceResource = this.dndFocus.surface.resource
    const client = surfaceResource.client

    // if source is null, only transfers within the same client can take place
    if (this.dndSource === null && client !== this.dndSourceClient) {
      return
    }

    const pointer = this.seat.pointer
    const mousePoint = _math_Point__WEBPACK_IMPORTED_MODULE_5__["default"].create(pointer.x, pointer.y)
    const surfacePoint = this.dndFocus.toSurfaceSpace(mousePoint)

    this.resources.filter((dataDeviceResource) => {
      return dataDeviceResource.client === client
    }).forEach((dataDeviceResource) => {
      dataDeviceResource.motion(Date.now(), westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__["Fixed"].parseFixed(surfacePoint.x), westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__["Fixed"].parseFixed(surfacePoint.y))
    })
  }

  /**
   * @param {View}view
   * @private
   */
  _onFocusGained (view) {
    this.dndFocus = view
    if (!this.dndSourceClient) {
      return
    }

    const surfaceResource = view.surface.resource
    const client = surfaceResource.client

    // if source is null, only transfers within the same client can take place
    if (this.dndSource === null && client !== this.dndSourceClient) {
      return
    }

    const pointer = this.seat.pointer
    const mousePoint = _math_Point__WEBPACK_IMPORTED_MODULE_5__["default"].create(pointer.x, pointer.y)
    const surfacePoint = view.toSurfaceSpace(mousePoint)
    const serial = this.seat.nextSerial()

    const x = westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__["Fixed"].parseFixed(surfacePoint.x)
    const y = westfield_runtime_server__WEBPACK_IMPORTED_MODULE_0__["Fixed"].parseFixed(surfacePoint.y)

    const dataDeviceResource = this._dataDeviceForClient(client)
    if (dataDeviceResource === null) {
      // target doesn't support dnd
      return
    }

    let wlDataOffer = null
    if (this.dndSource) {
      wlDataOffer = this._createDataOffer(this.dndSource, dataDeviceResource)
      wlDataOffer.implementation.updateAction()
      this.dndSource.accepted = false
    }
    dataDeviceResource.enter(serial, surfaceResource, x, y, wlDataOffer)

    if (wlDataOffer) {
      const dataSource = /** @type {DataSource} */ this.dndSource.implementation
      const dndActions = dataSource.dndActions
      if (wlDataOffer.version >= 3) {
        wlDataOffer.sourceActions(dndActions)
      }
    }
  }

  _onFocusLost () {
    if (!this.dndSourceClient) {
      return
    }

    const surfaceResource = this.dndFocus.surface.resource
    const client = surfaceResource.client

    // if source is null, only transfers within the same client can take place
    if (this.dndSource === null && client !== this.dndSourceClient) {
      return
    }

    const dataDeviceResource = this._dataDeviceForClient(client)
    if (dataDeviceResource) {
      dataDeviceResource.leave()
    }
    this.dndFocus = null
  }

  onMouseUp () {
    if (this.dndSource && this.dndFocus) {
      const surfaceResource = this.dndFocus.surface.resource
      const client = surfaceResource.client
      const dataDeviceResource = this._dataDeviceForClient(client)

      if (dataDeviceResource) {
        const dataSource = /** @type {DataSource} */ this.dndSource.implementation
        if (dataSource.accepted && dataSource.currentDndAction) {
          dataDeviceResource.drop()

          if (this.dndSource.version >= 3) {
            this.dndSource.dndDropPerformed()
          }

          const dataOffer = /** @type{DataOffer} */dataSource.wlDataOffer.implementation
          dataOffer.inAsk = this.dndSource.currentDndAction === DndAction.ask
        } else if (this.dndSource && this.dndSource.version >= 3) {
          this.dndSource.cancelled()
        }

        dataDeviceResource.leave()
      }
    }

    this.dndSourceClient = null

    const pointer = this.seat.pointer
    if (this.dndFocus) {
      pointer.setFocus(this.dndFocus)
    } else {
      pointer.setDefaultCursor()
    }
  }

  // TODO handle touch events

  /**
   * @param {WlDataSourceResource}source
   * @param {WlDataDeviceResource}dataDeviceResource
   * @return {WlDataOfferResource}
   * @private
   */
  _createDataOffer (source, dataDeviceResource) {
    const offerId = /** @type {number} */dataDeviceResource.dataOffer()
    const dataOffer = _DataOffer__WEBPACK_IMPORTED_MODULE_6__["default"].create(source, offerId, dataDeviceResource)
    source.implementation.wlDataOffer = dataOffer.resource
    source.implementation.mimeTypes.forEach((mimeType) => {
      dataOffer.resource.offer(mimeType)
    })
    return dataOffer.resource
  }

  /**
   *
   *                This request asks the compositor to set the selection
   *                to the data from the source on behalf of the client.
   *
   *                To unset the selection, set the source to NULL.
   *
   *
   * @param {WlDataDeviceResource} resource
   * @param {WlDataSourceResource|null} source data source for the selection
   * @param {Number} serial serial number of the event that triggered this request
   *
   * @since 1
   *
   */
  setSelection (resource, source, serial) {
    // TODO what should the serial correspond to? Looking at weston, the serial is quite useless...
    const dataSource = /** @type {DataSource} */source.implementation
    if (source && dataSource.dndActions) {
      source.postError(_protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_4___default.a.Error.invalidSource, 'Can not set selection when source has dnd actions active.')
      false && console.log('Protocol error. Can not set selection when source has dnd actions active.')
      return
    }

    if (this.selectionSource) {
      this.selectionSource.removeDestroyListener(this._selectionSourceDestroyListener)
      /*
       * From the specs:
       * For objects of version 2 or older, wl_data_source.cancelled will only be emitted if the data source was
       * replaced by another data source.
       */
      this.selectionSource.cancelled()
    }

    this.selectionSource = source
    // send out selection if there is a keyboard focus
    if (this._selectionFocus) {
      this.selectionSource.addDestroyListener(this._selectionSourceDestroyListener)
      this.onKeyboardFocusGained(this._selectionFocus)
    }
  }

  /**
   * @param {Surface}newSelectionFocus
   */
  onKeyboardFocusGained (newSelectionFocus) {
    this._selectionFocus = newSelectionFocus

    const surfaceResource = this._selectionFocus.resource
    const client = surfaceResource.client

    const dataDeviceResource = this._dataDeviceForClient(client)
    if (dataDeviceResource == null) {
      return
    }

    if (this.selectionSource === null) {
      dataDeviceResource.selection(null)
    } else {
      const wlDataOffer = this._createDataOffer(this.selectionSource, dataDeviceResource)
      dataDeviceResource.selection(wlDataOffer)
      this.selectionSource.implementation.wlDataOffer = wlDataOffer
    }
  }

  /**
   *
   *                This request destroys the data device.
   *
   *
   * @param {WlDataDeviceResource} resource
   *
   * @since 2
   *
   */
  release (resource) {
    if (this.dndSource) {
      this.dndSource.removeDestroyListener(this._dndSourceDestroyListener)
    }

    const index = this.resources.indexOf(resource)
    if (index > -1) {
      this.resources.splice(index, 1)
    }
    resource.destroy()
  }
}


/***/ }),
/* 86 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataDeviceRequests {

	/**
	 *
	 *	This request asks the compositor to start a drag-and-drop
	 *	operation on behalf of the client.
	 *
	 *	The source argument is the data source that provides the data
	 *	for the eventual data transfer. If source is NULL, enter, leave
	 *	and motion events are sent only to the client that initiated the
	 *	drag and the client is expected to handle the data passing
	 *	internally.
	 *
	 *	The origin surface is the surface where the drag originates and
	 *	the client must have an active implicit grab that matches the
	 *	serial.
	 *
	 *	The icon surface is an optional (can be NULL) surface that
	 *	provides an icon to be moved around with the cursor.  Initially,
	 *	the top-left corner of the icon surface is placed at the cursor
	 *	hotspot, but subsequent wl_surface.attach request can move the
	 *	relative position. Attach requests must be confirmed with
	 *	wl_surface.commit as usual. The icon surface is given the role of
	 *	a drag-and-drop icon. If the icon surface already has another role,
	 *	it raises a protocol error.
	 *
	 *	The current and pending input regions of the icon wl_surface are
	 *	cleared, and wl_surface.set_input_region is ignored until the
	 *	wl_surface is no longer used as the icon surface. When the use
	 *	as an icon ends, the current and pending input regions become
	 *	undefined, and the wl_surface is unmapped.
	 *      
	 *
	 * @param {WlDataDeviceResource} resource 
	 * @param {?*} source data source for the eventual transfer 
	 * @param {*} origin surface where the drag originates 
	 * @param {?*} icon drag-and-drop icon surface 
	 * @param {number} serial serial number of the implicit grab on the origin 
	 *
	 * @since 1
	 *
	 */
	startDrag(resource, source, origin, icon, serial) {}

	/**
	 *
	 *	This request asks the compositor to set the selection
	 *	to the data from the source on behalf of the client.
	 *
	 *	To unset the selection, set the source to NULL.
	 *      
	 *
	 * @param {WlDataDeviceResource} resource 
	 * @param {?*} source data source for the selection 
	 * @param {number} serial serial number of the event that triggered this request 
	 *
	 * @since 1
	 *
	 */
	setSelection(resource, source, serial) {}

	/**
	 *
	 *	This request destroys the data device.
	 *      
	 *
	 * @param {WlDataDeviceResource} resource 
	 *
	 * @since 2
	 *
	 */
	release(resource) {}
}

module.exports = WlDataDeviceRequests


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      There is one wl_data_device per seat which can be obtained
 *      from the global wl_data_device_manager singleton.
 *
 *      A wl_data_device provides access to inter-client data transfer
 *      mechanisms such as copy-and-paste and drag-and-drop.
 *    
 */
class WlDataDeviceResource extends Resource {

	/**
	 *
	 *	The data_offer event introduces a new wl_data_offer object,
	 *	which will subsequently be used in either the
	 *	data_device.enter event (for drag-and-drop) or the
	 *	data_device.selection event (for selections).  Immediately
	 *	following the data_device_data_offer event, the new data_offer
	 *	object will send out data_offer.offer events to describe the
	 *	mime types it offers.
	 *      
	 *
	 * @return {number} resource id. the new data_offer object 
	 *
	 * @since 1
	 *
	 */
	dataOffer () {
		return this.client.marshallConstructor(this.id, 0, 'WlDataOffer', [newObject()])
	}

	/**
	 *
	 *	This event is sent when an active drag-and-drop pointer enters
	 *	a surface owned by the client.  The position of the pointer at
	 *	enter time is provided by the x and y arguments, in surface-local
	 *	coordinates.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface client surface entered 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 * @param {?*} id source data_offer object 
	 *
	 * @since 1
	 *
	 */
	enter (serial, surface, x, y, id) {
		this.client.marshall(this.id, 1, [uint(serial), object(surface), fixed(x), fixed(y), objectOptional(id)])
	}

	/**
	 *
	 *	This event is sent when the drag-and-drop pointer leaves the
	 *	surface and the session ends.  The client must destroy the
	 *	wl_data_offer introduced at enter time at this point.
	 *      
	 * @since 1
	 *
	 */
	leave () {
		this.client.marshall(this.id, 2, [])
	}

	/**
	 *
	 *	This event is sent when the drag-and-drop pointer moves within
	 *	the currently focused surface. The new position of the pointer
	 *	is provided by the x and y arguments, in surface-local
	 *	coordinates.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion (time, x, y) {
		this.client.marshall(this.id, 3, [uint(time), fixed(x), fixed(y)])
	}

	/**
	 *
	 *	The event is sent when a drag-and-drop operation is ended
	 *	because the implicit grab is removed.
	 *
	 *	The drag-and-drop destination is expected to honor the last action
	 *	received through wl_data_offer.action, if the resulting action is
	 *	"copy" or "move", the destination can still perform
	 *	wl_data_offer.receive requests, and is expected to end all
	 *	transfers with a wl_data_offer.finish request.
	 *
	 *	If the resulting action is "ask", the action will not be considered
	 *	final. The drag-and-drop destination is expected to perform one last
	 *	wl_data_offer.set_actions request, or wl_data_offer.destroy in order
	 *	to cancel the operation.
	 *      
	 * @since 1
	 *
	 */
	drop () {
		this.client.marshall(this.id, 4, [])
	}

	/**
	 *
	 *	The selection event is sent out to notify the client of a new
	 *	wl_data_offer for the selection for this device.  The
	 *	data_device.data_offer and the data_offer.offer events are
	 *	sent out immediately before this event to introduce the data
	 *	offer object.  The selection event is sent to a client
	 *	immediately before receiving keyboard focus and when a new
	 *	selection is set while the client has keyboard focus.  The
	 *	data_offer is valid until a new data_offer or NULL is received
	 *	or until the client loses keyboard focus.  The client must
	 *	destroy the previous selection data_offer, if any, upon receiving
	 *	this event.
	 *      
	 *
	 * @param {?*} id selection data_offer object 
	 *
	 * @since 1
	 *
	 */
	selection (id) {
		this.client.marshall(this.id, 5, [objectOptional(id)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlDataDeviceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'?oo?ou')
		await this.implementation.startDrag(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'?ou')
		await this.implementation.setSelection(this, ...args)
	}
	async [2] (message) {
		await this.implementation.release(this)
	}
}
WlDataDeviceResource.protocolName = 'wl_data_device'

WlDataDeviceResource.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

module.exports = WlDataDeviceResource


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The wl_data_device_manager is a singleton global object that
 *      provides access to inter-client data transfer mechanisms such as
 *      copy-and-paste and drag-and-drop.  These mechanisms are tied to
 *      a wl_seat and this interface lets a client get a wl_data_device
 *      corresponding to a wl_seat.
 *
 *      Depending on the version bound, the objects created from the bound
 *      wl_data_device_manager object will have different requirements for
 *      functioning properly. See wl_data_source.set_actions,
 *      wl_data_offer.accept and wl_data_offer.finish for details.
 *    
 */
class WlDataDeviceManagerResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlDataDeviceManagerRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.createDataSource(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'no')
		await this.implementation.getDataDevice(this, ...args)
	}
}
WlDataDeviceManagerResource.protocolName = 'wl_data_device_manager'

WlDataDeviceManagerResource.DndAction = {
  /**
   * no action
   */
  none: 0,
  /**
   * copy action
   */
  copy: 1,
  /**
   * move action
   */
  move: 2,
  /**
   * ask action
   */
  ask: 4
}

module.exports = WlDataDeviceManagerResource


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The wl_data_source object is the source side of a wl_data_offer.
 *      It is created by the source client in a data transfer and
 *      provides a way to describe the offered data and a way to respond
 *      to requests to transfer the data.
 *    
 */
class WlDataSourceResource extends Resource {

	/**
	 *
	 *	Sent when a target accepts pointer_focus or motion events.  If
	 *	a target does not accept any of the offered types, type is NULL.
	 *
	 *	Used for feedback during drag-and-drop.
	 *      
	 *
	 * @param {?string} mimeType mime type accepted by the target 
	 *
	 * @since 1
	 *
	 */
	target (mimeType) {
		this.client.marshall(this.id, 0, [stringOptional(mimeType)])
	}

	/**
	 *
	 *	Request for data from the client.  Send the data as the
	 *	specified mime type over the passed file descriptor, then
	 *	close it.
	 *      
	 *
	 * @param {string} mimeType mime type for the data 
	 * @param {number} fd file descriptor for the data 
	 *
	 * @since 1
	 *
	 */
	send (mimeType, fd) {
		this.client.marshall(this.id, 1, [string(mimeType), fileDescriptor(fd)])
	}

	/**
	 *
	 *	This data source is no longer valid. There are several reasons why
	 *	this could happen:
	 *
	 *	- The data source has been replaced by another data source.
	 *	- The drag-and-drop operation was performed, but the drop destination
	 *	  did not accept any of the mime types offered through
	 *	  wl_data_source.target.
	 *	- The drag-and-drop operation was performed, but the drop destination
	 *	  did not select any of the actions present in the mask offered through
	 *	  wl_data_source.action.
	 *	- The drag-and-drop operation was performed but didn't happen over a
	 *	  surface.
	 *	- The compositor cancelled the drag-and-drop operation (e.g. compositor
	 *	  dependent timeouts to avoid stale drag-and-drop transfers).
	 *
	 *	The client should clean up and destroy this data source.
	 *
	 *	For objects of version 2 or older, wl_data_source.cancelled will
	 *	only be emitted if the data source was replaced by another data
	 *	source.
	 *      
	 * @since 1
	 *
	 */
	cancelled () {
		this.client.marshall(this.id, 2, [])
	}

	/**
	 *
	 *	The user performed the drop action. This event does not indicate
	 *	acceptance, wl_data_source.cancelled may still be emitted afterwards
	 *	if the drop destination does not accept any mime type.
	 *
	 *	However, this event might however not be received if the compositor
	 *	cancelled the drag-and-drop operation before this event could happen.
	 *
	 *	Note that the data_source may still be used in the future and should
	 *	not be destroyed here.
	 *      
	 * @since 3
	 *
	 */
	dndDropPerformed () {
		this.client.marshall(this.id, 3, [])
	}

	/**
	 *
	 *	The drop destination finished interoperating with this data
	 *	source, so the client is now free to destroy this data source and
	 *	free all associated data.
	 *
	 *	If the action used to perform the operation was "move", the
	 *	source can now delete the transferred data.
	 *      
	 * @since 3
	 *
	 */
	dndFinished () {
		this.client.marshall(this.id, 4, [])
	}

	/**
	 *
	 *	This event indicates the action selected by the compositor after
	 *	matching the source/destination side actions. Only one action (or
	 *	none) will be offered here.
	 *
	 *	This event can be emitted multiple times during the drag-and-drop
	 *	operation, mainly in response to destination side changes through
	 *	wl_data_offer.set_actions, and as the data device enters/leaves
	 *	surfaces.
	 *
	 *	It is only possible to receive this event after
	 *	wl_data_source.dnd_drop_performed if the drag-and-drop operation
	 *	ended in an "ask" action, in which case the final wl_data_source.action
	 *	event will happen immediately before wl_data_source.dnd_finished.
	 *
	 *	Compositors may also change the selected action on the fly, mainly
	 *	in response to keyboard modifier changes during the drag-and-drop
	 *	operation.
	 *
	 *	The most recent action received is always the valid one. The chosen
	 *	action may change alongside negotiation (e.g. an "ask" action can turn
	 *	into a "move" operation), so the effects of the final action must
	 *	always be applied in wl_data_offer.dnd_finished.
	 *
	 *	Clients can trigger cursor surface changes from this point, so
	 *	they reflect the current action.
	 *      
	 *
	 * @param {number} dndAction action selected by the compositor 
	 *
	 * @since 3
	 *
	 */
	action (dndAction) {
		this.client.marshall(this.id, 5, [uint(dndAction)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlDataSourceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'s')
		await this.implementation.offer(this, ...args)
	}
	async [1] (message) {
		await this.implementation.destroy(this)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.setActions(this, ...args)
	}
}
WlDataSourceResource.protocolName = 'wl_data_source'

WlDataSourceResource.Error = {
  /**
   * action mask contains invalid values
   */
  invalidActionMask: 0,
  /**
   * source doesn't accept this request
   */
  invalidSource: 1
}

module.exports = WlDataSourceResource


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataOffer; });
/* harmony import */ var _protocol_WlDataOfferRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/* harmony import */ var _protocol_WlDataOfferRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataOfferRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlDataOfferResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92);
/* harmony import */ var _protocol_WlDataOfferResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataOfferResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_2__);






const {copy, move, ask, none} = _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_2___default.a.DndAction
const ALL_ACTIONS = (copy | move | ask)

/**
 *
 *            A wl_data_offer represents a piece of data offered for transfer
 *            by another client (the source client).  It is used by the
 *            copy-and-paste and drag-and-drop mechanisms.  The offer
 *            describes the different mime types that the data can be
 *            converted to and provides the mechanism for transferring the
 *            data directly from the source client.
 * @implements WlDataOfferRequests
 */
class DataOffer extends _protocol_WlDataOfferRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {WlDataSourceResource}source
   * @param {number}offerId
   * @param {WlDataDeviceResource}dataDeviceResource
   * @return {DataOffer}
   */
  static create (source, offerId, dataDeviceResource) {
    const dataOffer = new DataOffer(source)
    const wlDataOfferResource = new _protocol_WlDataOfferResource__WEBPACK_IMPORTED_MODULE_1___default.a(dataDeviceResource.client, offerId, dataDeviceResource.version)
    wlDataOfferResource.implementation = dataOffer
    dataOffer.resource = wlDataOfferResource
    wlDataOfferResource.onDestroy().then(() => {
      dataOffer._handleDestroy()
    })

    return dataOffer
  }

  /**
   * Use DataOffer.create(..) instead.
   * @private
   * @param {WlDataSourceResource}source
   */
  constructor (source) {
    super()
    // set when offer is created
    /**
     * @type {WlDataOfferResource}
     */
    this.resource = null
    /**
     * @type {string|null}
     */
    this.acceptMimeType = null
    /**
     * @type {number}
     */
    this.preferredAction = 0
    /**
     * @type {number}
     */
    this.dndActions = none
    /**
     * @type {WlDataSourceResource}
     */
    this.wlDataSource = source
    /**
     * @type {boolean}
     * @private
     */
    this._finished = false
    this.inAsk = false
  }

  _handleDestroy () {
    if (!this.wlDataSource) { return }

    // TODO remove source destroy listener
    // TODO add source destroy listener
    // wl_list_remove(&offer->source_destroy_listener.link);

    const dataSoure = /** @type {DataSource} */this.wlDataSource.implementation
    if (dataSoure.wlDataOffer !== this.resource) { return }

    /* If the drag destination has version < 3, wl_data_offer.finish
     * won't be called, so do this here as a safety net, because
     * we still want the version >=3 drag source to be happy.
     */
    if (this.resource < 3) {
      dataSoure.notifyFinish()
    } else if (this.wlDataSource.resource &&
      this.wlDataSource.resource.version >= 3) {
      this.wlDataSource.resource.cancelled()
    }

    dataSoure.wlDataOffer = null
  }

  /**
   *
   *                Indicate that the client can accept the given mime type, or
   *                NULL for not accepted.
   *
   *                For objects of version 2 or older, this request is used by the
   *                client to give feedback whether the client can receive the given
   *                mime type, or NULL if none is accepted; the feedback does not
   *                determine whether the drag-and-drop operation succeeds or not.
   *
   *                For objects of version 3 or newer, this request determines the
   *                final result of the drag-and-drop operation. If the end result
   *                is that no mime types were accepted, the drag-and-drop operation
   *                will be cancelled and the corresponding drag source will receive
   *                wl_data_source.cancelled. Clients may still use this event in
   *                conjunction with wl_data_source.action for feedback.
   *
   *
   * @param {WlDataOfferResource} resource
   * @param {number} serial serial number of the accept request
   * @param {string|null} mimeType mime type accepted by the client
   *
   * @since 1
   * @override
   */
  accept (resource, serial, mimeType) {
    if (!this.wlDataSource || !this.wlDataSource.implementation.wlDataOffer) {
      return
    }
    if (this._finished) {
      // TODO raise protocol error
    }

    this.acceptMimeType = mimeType
    this.wlDataSource.target(mimeType)
    this.wlDataSource.implementation.accepted = mimeType !== null
  }

  /**
   *
   *                To transfer the offered data, the client issues this request
   *                and indicates the mime type it wants to receive.  The transfer
   *                happens through the passed file descriptor (typically created
   *                with the pipe system call).  The source client writes the data
   *                in the mime type representation requested and then closes the
   *                file descriptor.
   *
   *                The receiving client reads from the read end of the pipe until
   *                EOF and then closes its end, at which point the transfer is
   *                complete.
   *
   *                This request may happen multiple times for different mime types,
   *                both before and after wl_data_device.drop. Drag-and-drop destination
   *                clients may preemptively fetch data or examine it more closely to
   *                determine acceptance.
   *
   *
   * @param {WlDataOfferResource} resource
   * @param {string} mimeType mime type desired by receiver
   * @param {Number} fd file descriptor for data transfer
   *
   * @since 1
   * @override
   */
  receive (resource, mimeType, fd) {
    if (this._finished) {
      // TODO raise protocol error
    }
    if (this.wlDataSource) {
      this.wlDataSource.send(mimeType, fd)
    } else {
      this.wlDataSource.send('', -1)
    }
  }

  /**
   *
   *                Destroy the data offer.
   *
   *
   * @param {WlDataOfferResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *                Notifies the compositor that the drag destination successfully
   *                finished the drag-and-drop operation.
   *
   *                Upon receiving this request, the compositor will emit
   *                wl_data_source.dnd_finished on the drag source client.
   *
   *                It is a client error to perform other requests than
   *                wl_data_offer.destroy after this one. It is also an error to perform
   *                this request after a NULL mime type has been set in
   *                wl_data_offer.accept or no action was received through
   *                wl_data_offer.action.
   *
   *
   * @param {WlDataOfferResource} resource
   *
   * @since 3
   *
   */
  finish (resource) {
    if (this.wlDataSource || !this.preferredAction) {
      return
    }
    if (!this.acceptMimeType || this._finished) {
      return
    }

    /* Disallow finish while we have a grab driving drag-and-drop, or
     * if the negotiation is not at the right stage
     */
    if (!this.wlDataSource.implementation.accepted) {
      // TODO raise protocol error
      // wl_resource_post_error(offer->resource,
      //   WL_DATA_OFFER_ERROR_INVALID_FINISH,
      //   "premature finish request");
      return
    }

    switch (this.wlDataSource.implementation.currentDndAction) {
      case none:
      case ask:
        // TODO raise protocol error
        // wl_resource_post_error(offer->resource,
        //   WL_DATA_OFFER_ERROR_INVALID_OFFER,
        //   'offer finished with an invalid action')
        return
      default:
        break
    }

    this.wlDataSource.implementation.notifyFinish()
  }

  _bitCount (u) {
    // https://blogs.msdn.microsoft.com/jeuge/2005/06/08/bit-fiddling-3/
    const uCount = u - ((u >> 1) & 0o33333333333) - ((u >> 2) & 0o11111111111)
    return ((uCount + (uCount >> 3)) & 0o30707070707) % 63
  }

  /**
   *
   *                Sets the actions that the destination side client supports for
   *                this operation. This request may trigger the emission of
   *                wl_data_source.action and wl_data_offer.action events if the compositor
   *                needs to change the selected action.
   *
   *                This request can be called multiple times throughout the
   *                drag-and-drop operation, typically in response to wl_data_device.enter
   *                or wl_data_device.motion events.
   *
   *                This request determines the final result of the drag-and-drop
   *                operation. If the end result is that no action is accepted,
   *                the drag source will receive wl_drag_source.cancelled.
   *
   *                The dnd_actions argument must contain only values expressed in the
   *                wl_data_device_manager.dnd_actions enum, and the preferred_action
   *                argument must only contain one of those values set, otherwise it
   *                will result in a protocol error.
   *
   *                While managing an "ask" action, the destination drag-and-drop client
   *                may perform further wl_data_offer.receive requests, and is expected
   *                to perform one last wl_data_offer.set_actions request with a preferred
   *                action other than "ask" (and optionally wl_data_offer.accept) before
   *                requesting wl_data_offer.finish, in order to convey the action selected
   *                by the user. If the preferred action is not in the
   *                wl_data_offer.source_actions mask, an error will be raised.
   *
   *                If the "ask" action is dismissed (e.g. user cancellation), the client
   *                is expected to perform wl_data_offer.destroy right away.
   *
   *                This request can only be made on drag-and-drop offers, a protocol error
   *                will be raised otherwise.
   *
   *
   * @param {WlDataOfferResource} resource
   * @param {Number} dndActions actions supported by the destination client
   * @param {Number} preferredAction action preferred by the destination client
   *
   * @since 3
   *
   */
  setActions (resource, dndActions, preferredAction) {
    if (!this.wlDataSource) {
      return
    }
    if (this._finished) {
      // TODO raise protocol error
    }

    if (dndActions & ~ALL_ACTIONS) {
      // TODO protocol error
      // wl_resource_post_error(offer->resource,
      //   WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK,
      //   'invalid action mask %x', dnd_actions)
      return
    }

    if (preferredAction &&
      (!(preferredAction & dndActions) ||
        this._bitCount(preferredAction) > 1)) {
      // TODO protocol error
      // wl_resource_post_error(offer->resource,
      //   WL_DATA_OFFER_ERROR_INVALID_ACTION,
      //   'invalid action %x', preferred_action)
      return
    }

    this.dndActions = dndActions
    this.preferredAction = preferredAction
    this.updateAction()
  }

  updateAction () {
    if (!this.wlDataSource) { return }

    const action = this._chooseAction()

    if (this.wlDataSource.implementation.currentDndAction === action) { return }

    this.wlDataSource.implementation.currentDndAction = action

    if (this.inAsk) { return }

    if (this.wlDataSource.version >= 3) {
      this.wlDataSource.action(action)
    }

    if (this.resource.version >= 3) {
      this.resource.action(action)
    }
  }

  _chooseAction () {
    let offerActions = none
    let preferredAction = none
    if (this.resource >= 3) {
      offerActions = this.dndActions
      preferredAction = this.preferredAction
    } else {
      offerActions = copy
    }

    let sourceActions = none
    if (this.wlDataSource.version >= 3) {
      sourceActions = this.wlDataSource.implementation.dndActions
    } else {
      sourceActions = copy
    }
    const availableActions = offerActions & sourceActions

    if (!availableActions) {
      return none
    }

    // TODO a compositor defined action could be returned here

    /* If the dest side has a preferred DnD action, use it */
    if ((preferredAction & availableActions) !== 0) {
      return preferredAction
    }

    /* Use the first found action, in bit order */
    return 1 << (Math.floor(Math.log2(availableActions)) - 1)
  }
}


/***/ }),
/* 91 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataOfferRequests {

	/**
	 *
	 *	Indicate that the client can accept the given mime type, or
	 *	NULL for not accepted.
	 *
	 *	For objects of version 2 or older, this request is used by the
	 *	client to give feedback whether the client can receive the given
	 *	mime type, or NULL if none is accepted; the feedback does not
	 *	determine whether the drag-and-drop operation succeeds or not.
	 *
	 *	For objects of version 3 or newer, this request determines the
	 *	final result of the drag-and-drop operation. If the end result
	 *	is that no mime types were accepted, the drag-and-drop operation
	 *	will be cancelled and the corresponding drag source will receive
	 *	wl_data_source.cancelled. Clients may still use this event in
	 *	conjunction with wl_data_source.action for feedback.
	 *      
	 *
	 * @param {WlDataOfferResource} resource 
	 * @param {number} serial serial number of the accept request 
	 * @param {?string} mimeType mime type accepted by the client 
	 *
	 * @since 1
	 *
	 */
	accept(resource, serial, mimeType) {}

	/**
	 *
	 *	To transfer the offered data, the client issues this request
	 *	and indicates the mime type it wants to receive.  The transfer
	 *	happens through the passed file descriptor (typically created
	 *	with the pipe system call).  The source client writes the data
	 *	in the mime type representation requested and then closes the
	 *	file descriptor.
	 *
	 *	The receiving client reads from the read end of the pipe until
	 *	EOF and then closes its end, at which point the transfer is
	 *	complete.
	 *
	 *	This request may happen multiple times for different mime types,
	 *	both before and after wl_data_device.drop. Drag-and-drop destination
	 *	clients may preemptively fetch data or examine it more closely to
	 *	determine acceptance.
	 *      
	 *
	 * @param {WlDataOfferResource} resource 
	 * @param {string} mimeType mime type desired by receiver 
	 * @param {number} fd file descriptor for data transfer 
	 *
	 * @since 1
	 *
	 */
	receive(resource, mimeType, fd) {}

	/**
	 *
	 *	Destroy the data offer.
	 *      
	 *
	 * @param {WlDataOfferResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Notifies the compositor that the drag destination successfully
	 *	finished the drag-and-drop operation.
	 *
	 *	Upon receiving this request, the compositor will emit
	 *	wl_data_source.dnd_finished on the drag source client.
	 *
	 *	It is a client error to perform other requests than
	 *	wl_data_offer.destroy after this one. It is also an error to perform
	 *	this request after a NULL mime type has been set in
	 *	wl_data_offer.accept or no action was received through
	 *	wl_data_offer.action.
	 *      
	 *
	 * @param {WlDataOfferResource} resource 
	 *
	 * @since 3
	 *
	 */
	finish(resource) {}

	/**
	 *
	 *	Sets the actions that the destination side client supports for
	 *	this operation. This request may trigger the emission of
	 *	wl_data_source.action and wl_data_offer.action events if the compositor
	 *	needs to change the selected action.
	 *
	 *	This request can be called multiple times throughout the
	 *	drag-and-drop operation, typically in response to wl_data_device.enter
	 *	or wl_data_device.motion events.
	 *
	 *	This request determines the final result of the drag-and-drop
	 *	operation. If the end result is that no action is accepted,
	 *	the drag source will receive wl_drag_source.cancelled.
	 *
	 *	The dnd_actions argument must contain only values expressed in the
	 *	wl_data_device_manager.dnd_actions enum, and the preferred_action
	 *	argument must only contain one of those values set, otherwise it
	 *	will result in a protocol error.
	 *
	 *	While managing an "ask" action, the destination drag-and-drop client
	 *	may perform further wl_data_offer.receive requests, and is expected
	 *	to perform one last wl_data_offer.set_actions request with a preferred
	 *	action other than "ask" (and optionally wl_data_offer.accept) before
	 *	requesting wl_data_offer.finish, in order to convey the action selected
	 *	by the user. If the preferred action is not in the
	 *	wl_data_offer.source_actions mask, an error will be raised.
	 *
	 *	If the "ask" action is dismissed (e.g. user cancellation), the client
	 *	is expected to perform wl_data_offer.destroy right away.
	 *
	 *	This request can only be made on drag-and-drop offers, a protocol error
	 *	will be raised otherwise.
	 *      
	 *
	 * @param {WlDataOfferResource} resource 
	 * @param {number} dndActions actions supported by the destination client 
	 * @param {number} preferredAction action preferred by the destination client 
	 *
	 * @since 3
	 *
	 */
	setActions(resource, dndActions, preferredAction) {}
}

module.exports = WlDataOfferRequests


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A wl_data_offer represents a piece of data offered for transfer
 *      by another client (the source client).  It is used by the
 *      copy-and-paste and drag-and-drop mechanisms.  The offer
 *      describes the different mime types that the data can be
 *      converted to and provides the mechanism for transferring the
 *      data directly from the source client.
 *    
 */
class WlDataOfferResource extends Resource {

	/**
	 *
	 *	Sent immediately after creating the wl_data_offer object.  One
	 *	event per offered mime type.
	 *      
	 *
	 * @param {string} mimeType offered mime type 
	 *
	 * @since 1
	 *
	 */
	offer (mimeType) {
		this.client.marshall(this.id, 0, [string(mimeType)])
	}

	/**
	 *
	 *	This event indicates the actions offered by the data source. It
	 *	will be sent right after wl_data_device.enter, or anytime the source
	 *	side changes its offered actions through wl_data_source.set_actions.
	 *      
	 *
	 * @param {number} sourceActions actions offered by the data source 
	 *
	 * @since 3
	 *
	 */
	sourceActions (sourceActions) {
		this.client.marshall(this.id, 1, [uint(sourceActions)])
	}

	/**
	 *
	 *	This event indicates the action selected by the compositor after
	 *	matching the source/destination side actions. Only one action (or
	 *	none) will be offered here.
	 *
	 *	This event can be emitted multiple times during the drag-and-drop
	 *	operation in response to destination side action changes through
	 *	wl_data_offer.set_actions.
	 *
	 *	This event will no longer be emitted after wl_data_device.drop
	 *	happened on the drag-and-drop destination, the client must
	 *	honor the last action received, or the last preferred one set
	 *	through wl_data_offer.set_actions when handling an "ask" action.
	 *
	 *	Compositors may also change the selected action on the fly, mainly
	 *	in response to keyboard modifier changes during the drag-and-drop
	 *	operation.
	 *
	 *	The most recent action received is always the valid one. Prior to
	 *	receiving wl_data_device.drop, the chosen action may change (e.g.
	 *	due to keyboard modifiers being pressed). At the time of receiving
	 *	wl_data_device.drop the drag-and-drop destination must honor the
	 *	last action received.
	 *
	 *	Action changes may still happen after wl_data_device.drop,
	 *	especially on "ask" actions, where the drag-and-drop destination
	 *	may choose another action afterwards. Action changes happening
	 *	at this stage are always the result of inter-client negotiation, the
	 *	compositor shall no longer be able to induce a different action.
	 *
	 *	Upon "ask" actions, it is expected that the drag-and-drop destination
	 *	may potentially choose a different action and/or mime type,
	 *	based on wl_data_offer.source_actions and finally chosen by the
	 *	user (e.g. popping up a menu with the available options). The
	 *	final wl_data_offer.set_actions and wl_data_offer.accept requests
	 *	must happen before the call to wl_data_offer.finish.
	 *      
	 *
	 * @param {number} dndAction action selected by the compositor 
	 *
	 * @since 3
	 *
	 */
	action (dndAction) {
		this.client.marshall(this.id, 2, [uint(dndAction)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlDataOfferRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		const args = this.client._unmarshallArgs(message,'u?s')
		await this.implementation.accept(this, ...args)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'sh')
		await this.implementation.receive(this, ...args)
	}
	async [2] (message) {
		await this.implementation.destroy(this)
	}
	async [3] (message) {
		await this.implementation.finish(this)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'uu')
		await this.implementation.setActions(this, ...args)
	}
}
WlDataOfferResource.protocolName = 'wl_data_offer'

WlDataOfferResource.Error = {
  /**
   * finish request was called untimely
   */
  invalidFinish: 0,
  /**
   * action mask contains invalid values
   */
  invalidActionMask: 1,
  /**
   * action argument has an invalid value
   */
  invalidAction: 2,
  /**
   * offer doesn't accept this request
   */
  invalidOffer: 3
}

module.exports = WlDataOfferResource


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataDeviceManager; });
/* harmony import */ var _protocol_WlDataDeviceManagerRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
/* harmony import */ var _protocol_WlDataDeviceManagerRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceManagerRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89);
/* harmony import */ var _protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(87);
/* harmony import */ var _protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _DataSource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);








/**
 *
 *            The wldata_device_manager is a singleton global object that
 *            provides access to inter-client data transfer mechanisms such as
 *            copy-and-paste and drag-and-drop.  These mechanisms are tied to
 *            a wlseat and this interface lets a client get a wldata_device
 *            corresponding to a wlseat.
 *
 *            Depending on the version bound, the objects created from the bound
 *            wldata_device_manager object will have different requirements for
 *            functioning properly. See wldata_source.set_actions,
 *            wldata_offer.accept and wldata_offer.finish for details.
 * @implements WlDataDeviceManagerRequests
 */
class DataDeviceManager extends _protocol_WlDataDeviceManagerRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @return {DataDeviceManager}
   */
  static create () {
    return new DataDeviceManager()
  }

  constructor () {
    super()
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1___default.a.name, 3, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const wlDataDeviceManagerResource = new _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    wlDataDeviceManagerResource.implementation = this
  }

  /**
   *
   *                Create a new data source.
   *
   *
   * @param {WlDataDeviceManagerResource} resource
   * @param {number} id data source to create
   *
   * @since 1
   * @override
   */
  createDataSource (resource, id) {
    const wlDataSourceResource = new _protocol_WlDataSourceResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    _DataSource__WEBPACK_IMPORTED_MODULE_4__["default"].create(wlDataSourceResource)
  }

  /**
   *
   *                Create a new data device for a given seat.
   *
   *
   * @param {WlDataDeviceManagerResource} resource
   * @param {number} id data device to create
   * @param {WlSeat} seatResource seat associated with the data device
   *
   * @since 1
   * @override
   */
  getDataDevice (resource, id, seatResource) {
    const wlDataDeviceResource = new _protocol_WlDataDeviceResource__WEBPACK_IMPORTED_MODULE_3___default.a(resource.client, id, resource.version)
    const seat = /** @type {Seat} */seatResource.implementation
    wlDataDeviceResource.implementation = seat.dataDevice
    seat.dataDevice.resources.push(wlDataDeviceResource)
  }
}


/***/ }),
/* 94 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataDeviceManagerRequests {

	/**
	 *
	 *	Create a new data source.
	 *      
	 *
	 * @param {WlDataDeviceManagerResource} resource 
	 * @param {number} id data source to create 
	 *
	 * @since 1
	 *
	 */
	createDataSource(resource, id) {}

	/**
	 *
	 *	Create a new data device for a given seat.
	 *      
	 *
	 * @param {WlDataDeviceManagerResource} resource 
	 * @param {number} id data device to create 
	 * @param {*} seat seat associated with the data device 
	 *
	 * @since 1
	 *
	 */
	getDataDevice(resource, id, seat) {}
}

module.exports = WlDataDeviceManagerRequests


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataSource; });
/* harmony import */ var _protocol_WlDataSourceRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);
/* harmony import */ var _protocol_WlDataSourceRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataSourceRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);
/* harmony import */ var _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1__);





const {copy, move, ask, none} = _protocol_WlDataDeviceManagerResource__WEBPACK_IMPORTED_MODULE_1___default.a.DndAction
const ALL_ACTIONS = (copy | move | ask)

/**
 *
 *            The wl_data_source object is the source side of a wl_data_offer.
 *            It is created by the source client in a data transfer and
 *            provides a way to describe the offered data and a way to respond
 *            to requests to transfer the data.
 * @implements WlDataSourceRequests
 */
class DataSource extends _protocol_WlDataSourceRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {WlDataSourceResource} wlDataSourceResource
   * @return {DataSource}
   */
  static create (wlDataSourceResource) {
    const dataSource = new DataSource(wlDataSourceResource)
    wlDataSourceResource.implementation = dataSource
    return dataSource
  }

  /**
   * @param {WlDataSourceResource} wlDataSourceResource
   */
  constructor (wlDataSourceResource) {
    super()
    /**
     * @type {WlDataSourceResource}
     */
    this.resource = wlDataSourceResource
    /**
     * @type {Array<string>}
     */
    this.mimeTypes = []
    /**
     * @type {number}
     */
    this.dndActions = 0
    /**
     * @type {boolean}
     * @private
     */
    this._actionsSet = false
    /**
     * @type {number}
     */
    this.currentDndAction = none
    /**
     * @type {boolean}
     */
    this.accepted = false
    /**
     * @type {WlDataOfferResource}
     */
    this.wlDataOffer = null
  }

  /**
   *
   *                This request adds a mime type to the set of mime types
   *                advertised to targets.  Can be called several times to offer
   *                multiple types.
   *
   *
   * @param {WlDataSourceResource} resource
   * @param {string} mimeType mime type offered by the data source
   *
   * @since 1
   * @override
   */
  offer (resource, mimeType) {
    this.mimeTypes.push(mimeType)
    if (this.wlDataOffer) {
      this.wlDataOffer.offer(mimeType)
    }
  }

  /**
   *
   *                Destroy the data source.
   *
   *
   * @param {WlDataSourceResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *                Sets the actions that the source side client supports for this
   *                operation. This request may trigger wl_data_source.action and
   *                wl_data_offer.action events if the compositor needs to change the
   *                selected action.
   *
   *                The dnd_actions argument must contain only values expressed in the
   *                wl_data_device_manager.dnd_actions enum, otherwise it will result
   *                in a protocol error.
   *
   *                This request must be made once only, and can only be made on sources
   *                used in drag-and-drop, so it must be performed before
   *                wl_data_device.start_drag. Attempting to use the source other than
   *                for drag-and-drop will raise a protocol error.
   *
   *
   * @param {WlDataSourceResource} resource
   * @param {Number} dndActions actions supported by the data source
   *
   * @since 3
   * @override
   */
  setActions (resource, dndActions) {
    if (this._actionsSet) {
      // TODO protocol error
      // wl_resource_post_error(source->resource,
      //   WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK,
      //   "cannot set actions more than once");
      return
    }

    if (this.dndActions & ~ALL_ACTIONS) {
      // TODO protocol error
      // wl_resource_post_error(source->resource,
      //   WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK,
      //   "invalid action mask %x", dnd_actions);
      return
    }

    // if (source->seat) {
    //   wl_resource_post_error(source->resource,
    //     WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK,
    //     "invalid action change after "
    //   "wl_data_device.start_drag");
    //   return;
    // }

    this.dndActions = dndActions
    this._actionsSet = true
  }

  notifyFinish () {
    if (!this.dndActions) {
      return
    }

    if (this.wlDataOffer.implementation.inAsk && this.resource.version >= 3) {
      this.resource.action(this.currentDndAction)
    }

    if (this.resource >= 3) {
      this.resource.dndFinished()
    }

    this.wlDataOffer = null
  }
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataSourceRequests {

	/**
	 *
	 *	This request adds a mime type to the set of mime types
	 *	advertised to targets.  Can be called several times to offer
	 *	multiple types.
	 *      
	 *
	 * @param {WlDataSourceResource} resource 
	 * @param {string} mimeType mime type offered by the data source 
	 *
	 * @since 1
	 *
	 */
	offer(resource, mimeType) {}

	/**
	 *
	 *	Destroy the data source.
	 *      
	 *
	 * @param {WlDataSourceResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Sets the actions that the source side client supports for this
	 *	operation. This request may trigger wl_data_source.action and
	 *	wl_data_offer.action events if the compositor needs to change the
	 *	selected action.
	 *
	 *	The dnd_actions argument must contain only values expressed in the
	 *	wl_data_device_manager.dnd_actions enum, otherwise it will result
	 *	in a protocol error.
	 *
	 *	This request must be made once only, and can only be made on sources
	 *	used in drag-and-drop, so it must be performed before
	 *	wl_data_device.start_drag. Attempting to use the source other than
	 *	for drag-and-drop will raise a protocol error.
	 *      
	 *
	 * @param {WlDataSourceResource} resource 
	 * @param {number} dndActions actions supported by the data source 
	 *
	 * @since 3
	 *
	 */
	setActions(resource, dndActions) {}
}

module.exports = WlDataSourceRequests


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Output; });
/* harmony import */ var _protocol_WlOutputRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98);
/* harmony import */ var _protocol_WlOutputRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlOutputRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1__);





/**
 *
 *            An output describes part of the compositor geometry.  The
 *            compositor works in the 'compositor coordinate system' and an
 *            output corresponds to a rectangular area in that space that is
 *            actually visible.  This typically corresponds to a monitor that
 *            displays part of the compositor space.  This object is published
 *            as global during start up, or when a monitor is hotplugged.
 * @implements WlOutputRequests
 */
class Output extends _protocol_WlOutputRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @return {!Output}
   */
  static create () {
    return new Output()
  }

  /**
   * Use Output.create(..) instead.
   * @private
   */
  constructor () {
    super()
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.protocolName, 3, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   * @param {!Client}client
   * @param {!number}id
   * @param {!number}version
   */
  bindClient (client, id, version) {
    const wlOutputResource = new _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    wlOutputResource.implementation = this
    this.emitSpecs(wlOutputResource)
  }

  /**
   * @param {!WlOutputResource}wlOutputResource
   */
  emitSpecs (wlOutputResource) {
    // TODO we might want to listen for window/document size changes and emit on update
    this._emitGeomtry(wlOutputResource)
    this._emitMode(wlOutputResource)
    // TODO scaling info using window.devicePixelRatio
    // TODO expose pixel scaling in config menu
    if (wlOutputResource.version >= 2) {
      wlOutputResource.done()
    }
  }

  /**
   * @param {!WlOutputResource}wlOutputResource
   */
  _emitMode (wlOutputResource) {
    const flags = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Mode.current
    const width = Math.ceil(window.innerWidth * window.devicePixelRatio)
    const height = Math.ceil(window.innerHeight * window.devicePixelRatio)
    // the refresh rate is impossible to query without manual measuring, which is error prone.
    const refresh = 60
    wlOutputResource.mode(flags, width, height, refresh)
  }

  /**
   * @param {!WlOutputResource}wlOutputResource
   */
  _emitGeomtry (wlOutputResource) {
    const x = 0
    const y = 0
    // this is really just an approximation as browsers don't offer a way to get the physical width :(
    // A css pixel is roughly 1/96 of an inch, so ~0.2646 mm
    // TODO test this on high dpi devices
    const physicalWidth = Math.ceil(window.innerWidth * 0.2646)
    const physicalHeight = Math.ceil(window.innerHeight * 0.2646)
    const subpixel = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Subpixel.unknown
    const make = 'Greenfield'
    const model = window.navigator.userAgent

    const orientation = window.screen.orientation.type
    let transform = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transform.normal

    // FIXME this requires some experimentation to get it right
    switch (orientation) {
      case 'portrait-primary': {
        transform = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transform.normal
        break
      }
      case 'portrait-secondary': {
        transform = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transform['180']
        break
      }
      case 'landscape-primary': {
        transform = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transform.normal
        break
      }
      case 'landscape-secondary': {
        transform = _protocol_WlOutputResource__WEBPACK_IMPORTED_MODULE_1___default.a.Transform['180']
        break
      }
    }

    wlOutputResource.geometry(x, y, physicalWidth, physicalHeight, subpixel, make, model, transform)
  }

  /**
   *
   *                Using this request a client can tell the server that it is not going to
   *                use the output object anymore.
   *
   *
   * @param {!WlOutputResource} resource
   *
   * @since 3
   *
   */
  release (resource) {
    resource.destroy()
  }
}


/***/ }),
/* 98 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlOutputRequests {

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the output object anymore.
	 *      
	 *
	 * @param {WlOutputResource} resource 
	 *
	 * @since 3
	 *
	 */
	release(resource) {}
}

module.exports = WlOutputRequests


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Subcompositor; });
/* harmony import */ var _protocol_WlSubcompositorRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _protocol_WlSubcompositorRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSubcompositorRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlSubcompositorResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(101);
/* harmony import */ var _protocol_WlSubcompositorResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSubcompositorResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);
/* harmony import */ var _protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Subsurface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(103);








/**
 *
 *            The global interface exposing sub-surface compositing capabilities.
 *            A wl_surface, that has sub-surfaces associated, is called the
 *            parent surface. Sub-surfaces can be arbitrarily nested and create
 *            a tree of sub-surfaces.
 *
 *            The root surface in a tree of sub-surfaces is the main
 *            surface. The main surface cannot be a sub-surface, because
 *            sub-surfaces must always have a parent.
 *
 *            A main surface with its sub-surfaces forms a (compound) window.
 *            For window management purposes, this set of wl_surface objects is
 *            to be considered as a single window, and it should also behave as
 *            such.
 *
 *            The aim of sub-surfaces is to offload some of the compositing work
 *            within a window from clients to the compositor. A prime example is
 *            a video player with decorations and video in separate wl_surface
 *            objects. This should allow the compositor to pass YUV video buffer
 *            processing to dedicated overlay hardware when possible.
 *
 * @import {WlSubcompositorRequests}
 */
class Subcompositor extends _protocol_WlSubcompositorRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @return {Subcompositor}
   */
  static create () {
    return new Subcompositor()
  }

  constructor () {
    super()
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_WlSubcompositorRequests__WEBPACK_IMPORTED_MODULE_0___default.a.name, 1, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   * @param {Client}client
   * @param {number}id
   * @param {number}version
   */
  bindClient (client, id, version) {
    const grSubcompositorResource = new _protocol_WlSubcompositorResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    grSubcompositorResource.implementation = this
  }

  /**
   *
   *                Create a sub-surface interface for the given surface, and
   *                associate it with the given parent surface. This turns a
   *                plain wl_surface into a sub-surface.
   *
   *                The to-be sub-surface must not already have another role, and it
   *                must not have an existing wl_subsurface object. Otherwise a protocol
   *                error is raised.
   *
   *
   * @param {WlSubcompositorResource} resource
   * @param {number} id the new sub-surface object ID
   * @param {WlSurfaceResource} wlSurfaceResource the surface to be turned into a sub-surface
   * @param {WlSurfaceResource} wlParentSurfaceResource the parent surface
   *
   * @since 1
   *
   */
  getSubsurface (resource, id, wlSurfaceResource, wlParentSurfaceResource) {
    const surface = /** @type {Surface} */wlSurfaceResource.implementation
    if (surface.role) {
      resource.postError(_protocol_WlSubcompositorResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.badSurface, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role.')
      return
    }

    const wlSubsurfaceResource = new _protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    _Subsurface__WEBPACK_IMPORTED_MODULE_3__["default"].create(wlParentSurfaceResource, wlSurfaceResource, wlSubsurfaceResource)

    const parentSurface = wlParentSurfaceResource.implementation

    // having added this sub-surface to a parent will have it create a view for each parent view
    const views = parentSurface.addSubsurface(surface.surfaceChildSelf)
    const onNewView = (view) => {
      view.onDestroy().then(() => {
        view.detach()
      })
    }
    views.forEach(onNewView)
    // this handles the case where a view is created later on (ie if a new parent view is created)
    surface.onViewCreated = onNewView
  }
}


/***/ }),
/* 100 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSubcompositorRequests {

	/**
	 *
	 *	Informs the server that the client will not be using this
	 *	protocol object anymore. This does not affect any other
	 *	objects, wl_subsurface objects included.
	 *      
	 *
	 * @param {WlSubcompositorResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Create a sub-surface interface for the given surface, and
	 *	associate it with the given parent surface. This turns a
	 *	plain wl_surface into a sub-surface.
	 *
	 *	The to-be sub-surface must not already have another role, and it
	 *	must not have an existing wl_subsurface object. Otherwise a protocol
	 *	error is raised.
	 *      
	 *
	 * @param {WlSubcompositorResource} resource 
	 * @param {number} id the new sub-surface object ID 
	 * @param {*} surface the surface to be turned into a sub-surface 
	 * @param {*} parent the parent surface 
	 *
	 * @since 1
	 *
	 */
	getSubsurface(resource, id, surface, parent) {}
}

module.exports = WlSubcompositorRequests


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The global interface exposing sub-surface compositing capabilities.
 *      A wl_surface, that has sub-surfaces associated, is called the
 *      parent surface. Sub-surfaces can be arbitrarily nested and create
 *      a tree of sub-surfaces.
 *
 *      The root surface in a tree of sub-surfaces is the main
 *      surface. The main surface cannot be a sub-surface, because
 *      sub-surfaces must always have a parent.
 *
 *      A main surface with its sub-surfaces forms a (compound) window.
 *      For window management purposes, this set of wl_surface objects is
 *      to be considered as a single window, and it should also behave as
 *      such.
 *
 *      The aim of sub-surfaces is to offload some of the compositing work
 *      within a window from clients to the compositor. A prime example is
 *      a video player with decorations and video in separate wl_surface
 *      objects. This should allow the compositor to pass YUV video buffer
 *      processing to dedicated overlay hardware when possible.
 *    
 */
class WlSubcompositorResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlSubcompositorRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'noo')
		await this.implementation.getSubsurface(this, ...args)
	}
}
WlSubcompositorResource.protocolName = 'wl_subcompositor'

WlSubcompositorResource.Error = {
  /**
   * the to-be sub-surface is invalid
   */
  badSurface: 0
}

module.exports = WlSubcompositorResource


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      An additional interface to a wl_surface object, which has been
 *      made a sub-surface. A sub-surface has one parent surface. A
 *      sub-surface's size and position are not limited to that of the parent.
 *      Particularly, a sub-surface is not automatically clipped to its
 *      parent's area.
 *
 *      A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 *      and the parent surface is mapped. The order of which one happens
 *      first is irrelevant. A sub-surface is hidden if the parent becomes
 *      hidden, or if a NULL wl_buffer is applied. These rules apply
 *      recursively through the tree of surfaces.
 *
 *      The behaviour of a wl_surface.commit request on a sub-surface
 *      depends on the sub-surface's mode. The possible modes are
 *      synchronized and desynchronized, see methods
 *      wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 *      mode caches the wl_surface state to be applied when the parent's
 *      state gets applied, and desynchronized mode applies the pending
 *      wl_surface state directly. A sub-surface is initially in the
 *      synchronized mode.
 *
 *      Sub-surfaces have also other kind of state, which is managed by
 *      wl_subsurface requests, as opposed to wl_surface requests. This
 *      state includes the sub-surface position relative to the parent
 *      surface (wl_subsurface.set_position), and the stacking order of
 *      the parent and its sub-surfaces (wl_subsurface.place_above and
 *      .place_below). This state is applied when the parent surface's
 *      wl_surface state is applied, regardless of the sub-surface's mode.
 *      As the exception, set_sync and set_desync are effective immediately.
 *
 *      The main surface can be thought to be always in desynchronized mode,
 *      since it does not have a parent in the sub-surfaces sense.
 *
 *      Even if a sub-surface is in desynchronized mode, it will behave as
 *      in synchronized mode, if its parent surface behaves as in
 *      synchronized mode. This rule is applied recursively throughout the
 *      tree of surfaces. This means, that one can set a sub-surface into
 *      synchronized mode, and then assume that all its child and grand-child
 *      sub-surfaces are synchronized, too, without explicitly setting them.
 *
 *      If the wl_surface associated with the wl_subsurface is destroyed, the
 *      wl_subsurface object becomes inert. Note, that destroying either object
 *      takes effect immediately. If you need to synchronize the removal
 *      of a sub-surface to the parent surface update, unmap the sub-surface
 *      first by attaching a NULL wl_buffer, update parent, and then destroy
 *      the sub-surface.
 *
 *      If the parent wl_surface object is destroyed, the sub-surface is
 *      unmapped.
 *    
 */
class WlSubsurfaceResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {WlSubsurfaceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'ii')
		await this.implementation.setPosition(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'o')
		await this.implementation.placeAbove(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'o')
		await this.implementation.placeBelow(this, ...args)
	}
	async [4] (message) {
		await this.implementation.setSync(this)
	}
	async [5] (message) {
		await this.implementation.setDesync(this)
	}
}
WlSubsurfaceResource.protocolName = 'wl_subsurface'

WlSubsurfaceResource.Error = {
  /**
   * wl_surface is not a sibling or the parent
   */
  badSurface: 0
}

module.exports = WlSubsurfaceResource


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Subsurface; });
/* harmony import */ var _protocol_WlSubsurfaceRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(104);
/* harmony import */ var _protocol_WlSubsurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSubsurfaceRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
/* harmony import */ var _protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);
/* harmony import */ var _Surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);









/**
 *
 *            An additional interface to a wl_surface object, which has been
 *            made a sub-surface. A sub-surface has one parent surface. A
 *            sub-surface's size and position are not limited to that of the parent.
 *            Particularly, a sub-surface is not automatically clipped to its
 *            parent's area.
 *
 *            A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 *            and the parent surface is mapped. The order of which one happens
 *            first is irrelevant. A sub-surface is hidden if the parent becomes
 *            hidden, or if a NULL wl_buffer is applied. These rules apply
 *            recursively through the tree of surfaces.
 *
 *            The behaviour of a wl_surface.commit request on a sub-surface
 *            depends on the sub-surface's mode. The possible modes are
 *            synchronized and desynchronized, see methods
 *            wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 *            mode caches the wl_surface state to be applied when the parent's
 *            state gets applied, and desynchronized mode applies the pending
 *            wl_surface state directly. A sub-surface is initially in the
 *            synchronized mode.
 *
 *            Sub-surfaces have also other kind of state, which is managed by
 *            wl_subsurface requests, as opposed to wl_surface requests. This
 *            state includes the sub-surface position relative to the parent
 *            surface (wl_subsurface.set_position), and the stacking order of
 *            the parent and its sub-surfaces (wl_subsurface.place_above and
 *            .place_below). This state is applied when the parent surface's
 *            wl_surface state is applied, regardless of the sub-surface's mode.
 *            As the exception, set_sync and set_desync are effective immediately.
 *
 *            The main surface can be thought to be always in desynchronized mode,
 *            since it does not have a parent in the sub-surfaces sense.
 *
 *            Even if a sub-surface is in desynchronized mode, it will behave as
 *            in synchronized mode, if its parent surface behaves as in
 *            synchronized mode. This rule is applied recursively throughout the
 *            tree of surfaces. This means, that one can set a sub-surface into
 *            synchronized mode, and then assume that all its child and grand-child
 *            sub-surfaces are synchronized, too, without explicitly setting them.
 *
 *            If the wl_surface associated with the wl_subsurface is destroyed, the
 *            wl_subsurface object becomes inert. Note, that destroying either object
 *            takes effect immediately. If you need to synchronize the removal
 *            of a sub-surface to the parent surface update, unmap the sub-surface
 *            first by attaching a NULL wl_buffer, update parent, and then destroy
 *            the sub-surface.
 *
 *            If the parent wl_surface object is destroyed, the sub-surface is
 *            unmapped.
 *
 * @implements SurfaceRole
 * @implements WlSubsurfaceRequests
 */
class Subsurface extends _protocol_WlSubsurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {WlSurfaceResource}parentWlSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {WlSubsurfaceResource}wlSubsurfaceResource
   * @return {Subsurface}
   */
  static create (parentWlSurfaceResource, wlSurfaceResource, wlSubsurfaceResource) {
    const subsurface = new Subsurface(parentWlSurfaceResource, wlSurfaceResource, wlSubsurfaceResource)
    wlSubsurfaceResource.implementation = subsurface

    wlSurfaceResource.onDestroy().then(() => {
      subsurface._inert = true
    })

    parentWlSurfaceResource.onDestroy().then(() => {
      // TODO unmap
    })

    // TODO sync viewable/hidden state with parent

    wlSurfaceResource.implementation.role = subsurface

    return subsurface
  }

  /**
   * Use Subsurface.create(..) instead.
   * @param {WlSurfaceResource}parentWlSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {WlSubsurfaceResource}wlSubsurfaceResource
   * @private
   */
  constructor (parentWlSurfaceResource, wlSurfaceResource, wlSubsurfaceResource) {
    super()
    /**
     * @type {WlSurfaceResource}
     */
    this.parentWlSurfaceResource = parentWlSurfaceResource
    /**
     * @type {WlSurfaceResource}
     */
    this.wlSurfaceResource = wlSurfaceResource
    /**
     * @type {WlSubsurfaceResource}
     */
    this.resource = wlSubsurfaceResource
    /**
     * @type {boolean}
     * @private
     */
    this._sync = true
    /**
     * @type {Point}
     */
    this.pendingPosition = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(0, 0)
    /**
     * @type {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}
     */
    this._cachedState = wlSurfaceResource.implementation.state
    /**
     * @type {boolean}
     * @private
     */
    this._inert = false
  }

  /**
   * @param {Surface}parentSurface
   * @param {RenderFrame}renderFrame
   */
  onParentCommit (parentSurface, renderFrame) {
    if (this._inert) {
      return
    }

    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation
    // sibling stacking order & position is committed by the parent itself so no need to do it here.

    if (this._effectiveSync && this._cachedState) {
      surface.render(renderFrame, this._cachedState)
      // TODO if we throw away cached state, we need to free the pixman regions in it
      this._cachedState = null
    }
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @return {Promise<void>}
   * @override
   */
  async onCommit (surface, renderFrame, newState) {
    if (this._inert) {
      return
    }

    if (this._effectiveSync) {
      if (!this._cachedState) {
        this._cachedState = surface.state
      }
      _Surface__WEBPACK_IMPORTED_MODULE_4__["default"].mergeState(this._cachedState, newState)
    } else {
      if (this._cachedState) {
        // FIXME this will probably overwrite newer state with old cached state? :-/ How to fix this?
        _Surface__WEBPACK_IMPORTED_MODULE_4__["default"].mergeState(newState, this._cachedState)
        // TODO if we throw away cached state, we need to free the pixman regions in it
        this._cachedState = null
      }
      await surface.render(renderFrame, newState)
      renderFrame.fire()
      await renderFrame
      surface.session.flush()
    }
  }

  /**
   *
   *                The sub-surface interface is removed from the wl_surface object
   *                that was turned into a sub-surface with a
   *                wl_subcompositor.get_subsurface request. The wl_surface's association
   *                to the parent is deleted, and the wl_surface loses its role as
   *                a sub-surface. The wl_surface is unmapped.
   *
   *
   * @param {WlSubsurfaceResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *                This schedules a sub-surface position change.
   *                The sub-surface will be moved so that its origin (top left
   *                corner pixel) will be at the location x, y of the parent surface
   *                coordinate system. The coordinates are not restricted to the parent
   *                surface area. Negative values are allowed.
   *
   *                The scheduled coordinates will take effect whenever the state of the
   *                parent surface is applied. When this happens depends on whether the
   *                parent surface is in synchronized mode or not. See
   *                wl_subsurface.set_sync and wl_subsurface.set_desync for details.
   *
   *                If more than one set_position request is invoked by the client before
   *                the commit of the parent surface, the position of a new request always
   *                replaces the scheduled position from any previous request.
   *
   *                The initial position is 0, 0.
   *
   *
   * @param {WlSubsurfaceResource} resource
   * @param {Number} x x coordinate in the parent surface
   * @param {Number} y y coordinate in the parent surface
   *
   * @since 1
   * @override
   */
  setPosition (resource, x, y) {
    if (this._inert) {
      return
    }

    this.pendingPosition = _math_Point__WEBPACK_IMPORTED_MODULE_2__["default"].create(x, y)
  }

  /**
   *
   *                This sub-surface is taken from the stack, and put back just
   *                above the reference surface, changing the z-order of the sub-surfaces.
   *                The reference surface must be one of the sibling surfaces, or the
   *                parent surface. Using any other surface, including this sub-surface,
   *                will cause a protocol error.
   *
   *                The z-order is double-buffered. Requests are handled in order and
   *                applied immediately to a pending state. The final pending state is
   *                copied to the active state the next time the state of the parent
   *                surface is applied. When this happens depends on whether the parent
   *                surface is in synchronized mode or not. See wl_subsurface.set_sync and
   *                wl_subsurface.set_desync for details.
   *
   *                A new sub-surface is initially added as the top-most in the stack
   *                of its siblings and parent.
   *
   *
   * @param {WlSubsurfaceResource} resource
   * @param {WlSurfaceResource} sibling the reference surface
   *
   * @since 1
   * @override
   */
  placeAbove (resource, sibling) {
    const parentSurface = /** @type {Surface} */ this.parentWlSurfaceResource.implementation
    const siblingSurface = /** @type {Surface} */ sibling.implementation
    const siblingSurfaceChildSelf = siblingSurface.surfaceChildSelf
    if (!parentSurface.subsurfaceChildren.includes(siblingSurfaceChildSelf) ||
      siblingSurface === parentSurface) {
      resource.postError(_protocol_WlSubsurfaceResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.badSurface, 'Surface is not a sibling or the parent.')
      false && console.log('Protocol error. Surface is not a sibling or the parent.')
      return
    }

    if (this._inert) {
      return
    }

    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation

    const currentIdx = parentSurface.pendingSubsurfaceChildren.indexOf(surface.surfaceChildSelf)
    parentSurface.pendingSubsurfaceChildren.splice(currentIdx, 1)

    const siblingIdx = parentSurface.pendingSubsurfaceChildren.indexOf(siblingSurfaceChildSelf)
    const newIdx = siblingIdx + 1
    parentSurface.pendingSubsurfaceChildren.splice(newIdx, 0, surface.surfaceChildSelf)
  }

  /**
   *
   *                The sub-surface is placed just below the reference surface.
   *                See wl_subsurface.place_above.
   *
   *
   * @param {WlSubsurfaceResource} resource
   * @param {WlSurfaceResource} sibling the reference surface
   *
   * @since 1
   * @override
   */
  placeBelow (resource, sibling) {
    if (this._inert) {
      return
    }

    const parentSurface = /** @type {Surface} */this.parentWlSurfaceResource.implementation
    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation

    const currentIdx = parentSurface.pendingSubsurfaceChildren.indexOf(surface.surfaceChildSelf)
    parentSurface.pendingSubsurfaceChildren.splice(currentIdx, 1)

    const siblingSurface = /** @type {Surface} */ sibling.implementation
    const newIdx = parentSurface.pendingSubsurfaceChildren.indexOf(siblingSurface.surfaceChildSelf)
    parentSurface.pendingSubsurfaceChildren.splice(newIdx, 0, surface.surfaceChildSelf)
  }

  /**
   * @return {boolean}
   * @private
   */
  get _effectiveSync () {
    return this._sync || this._parentEffectiveSync
  }

  /**
   * @return {boolean}
   * @private
   */
  get _parentEffectiveSync () {
    let parentEffectiveSync = false

    const parentSurface = /** @type {Surface} */this.parentWlSurfaceResource.implementation
    const parentRole = parentSurface.role
    if (parentRole && parentRole instanceof Subsurface) {
      parentEffectiveSync = parentRole._effectiveSync
    }

    return parentEffectiveSync
  }

  /**
   *
   *                Change the commit behaviour of the sub-surface to synchronized
   *                mode, also described as the parent dependent mode.
   *
   *                In synchronized mode, wl_surface.commit on a sub-surface will
   *                accumulate the committed state in a cache, but the state will
   *                not be applied and hence will not change the compositor output.
   *                The cached state is applied to the sub-surface immediately after
   *                the parent surface's state is applied. This ensures atomic
   *                updates of the parent and all its synchronized sub-surfaces.
   *                Applying the cached state will invalidate the cache, so further
   *                parent surface commits do not (re-)apply old state.
   *
   *                See wl_subsurface for the recursive effect of this mode.
   *
   *
   * @param {WlSubsurfaceResource} resource
   *
   * @since 1
   * @override
   */
  setSync (resource) {
    if (this._inert) {
      return
    }

    this._sync = true
  }

  /**
   *
   *                Change the commit behaviour of the sub-surface to desynchronized
   *                mode, also described as independent or freely running mode.
   *
   *                In desynchronized mode, wl_surface.commit on a sub-surface will
   *                apply the pending state directly, without caching, as happens
   *                normally with a wl_surface. Calling wl_surface.commit on the
   *                parent surface has no effect on the sub-surface's wl_surface
   *                state. This mode allows a sub-surface to be updated on its own.
   *
   *                If cached state exists when wl_surface.commit is called in
   *                desynchronized mode, the pending state is added to the cached
   *                state, and applied as a whole. This invalidates the cache.
   *
   *                Note: even if a sub-surface is set to desynchronized, a parent
   *                sub-surface may override it to behave as synchronized. For details,
   *                see wl_subsurface.
   *
   *                If a surface's parent surface behaves as desynchronized, then
   *                the cached state is applied on set_desync.
   *
   *
   * @param {WlSubsurfaceResource} resource
   *
   * @since 1
   * @override
   */
  async setDesync (resource) {
    if (this._inert) {
      return
    }

    this._sync = false
    if (!this._effectiveSync && this._cachedState) {
      const surface = /** @type {Surface} */this.wlSurfaceResource.implementation
      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_3__["default"].createRenderFrame()
      surface.render(renderFrame, this._cachedState)
      // TODO if we throw away cached state, we need to free the pixman regions in it
      this._cachedState = null
      renderFrame.fire()
      await renderFrame
      surface.session.flush()
    }
  }

  /**
   * @override
   */
  captureRoleState () {}

  /**
   * @param roleState
   * @override
   */
  setRoleState (roleState) {}
}


/***/ }),
/* 104 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSubsurfaceRequests {

	/**
	 *
	 *	The sub-surface interface is removed from the wl_surface object
	 *	that was turned into a sub-surface with a
	 *	wl_subcompositor.get_subsurface request. The wl_surface's association
	 *	to the parent is deleted, and the wl_surface loses its role as
	 *	a sub-surface. The wl_surface is unmapped.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	This schedules a sub-surface position change.
	 *	The sub-surface will be moved so that its origin (top left
	 *	corner pixel) will be at the location x, y of the parent surface
	 *	coordinate system. The coordinates are not restricted to the parent
	 *	surface area. Negative values are allowed.
	 *
	 *	The scheduled coordinates will take effect whenever the state of the
	 *	parent surface is applied. When this happens depends on whether the
	 *	parent surface is in synchronized mode or not. See
	 *	wl_subsurface.set_sync and wl_subsurface.set_desync for details.
	 *
	 *	If more than one set_position request is invoked by the client before
	 *	the commit of the parent surface, the position of a new request always
	 *	replaces the scheduled position from any previous request.
	 *
	 *	The initial position is 0, 0.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 * @param {number} x x coordinate in the parent surface 
	 * @param {number} y y coordinate in the parent surface 
	 *
	 * @since 1
	 *
	 */
	setPosition(resource, x, y) {}

	/**
	 *
	 *	This sub-surface is taken from the stack, and put back just
	 *	above the reference surface, changing the z-order of the sub-surfaces.
	 *	The reference surface must be one of the sibling surfaces, or the
	 *	parent surface. Using any other surface, including this sub-surface,
	 *	will cause a protocol error.
	 *
	 *	The z-order is double-buffered. Requests are handled in order and
	 *	applied immediately to a pending state. The final pending state is
	 *	copied to the active state the next time the state of the parent
	 *	surface is applied. When this happens depends on whether the parent
	 *	surface is in synchronized mode or not. See wl_subsurface.set_sync and
	 *	wl_subsurface.set_desync for details.
	 *
	 *	A new sub-surface is initially added as the top-most in the stack
	 *	of its siblings and parent.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 * @param {*} sibling the reference surface 
	 *
	 * @since 1
	 *
	 */
	placeAbove(resource, sibling) {}

	/**
	 *
	 *	The sub-surface is placed just below the reference surface.
	 *	See wl_subsurface.place_above.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 * @param {*} sibling the reference surface 
	 *
	 * @since 1
	 *
	 */
	placeBelow(resource, sibling) {}

	/**
	 *
	 *	Change the commit behaviour of the sub-surface to synchronized
	 *	mode, also described as the parent dependent mode.
	 *
	 *	In synchronized mode, wl_surface.commit on a sub-surface will
	 *	accumulate the committed state in a cache, but the state will
	 *	not be applied and hence will not change the compositor output.
	 *	The cached state is applied to the sub-surface immediately after
	 *	the parent surface's state is applied. This ensures atomic
	 *	updates of the parent and all its synchronized sub-surfaces.
	 *	Applying the cached state will invalidate the cache, so further
	 *	parent surface commits do not (re-)apply old state.
	 *
	 *	See wl_subsurface for the recursive effect of this mode.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	setSync(resource) {}

	/**
	 *
	 *	Change the commit behaviour of the sub-surface to desynchronized
	 *	mode, also described as independent or freely running mode.
	 *
	 *	In desynchronized mode, wl_surface.commit on a sub-surface will
	 *	apply the pending state directly, without caching, as happens
	 *	normally with a wl_surface. Calling wl_surface.commit on the
	 *	parent surface has no effect on the sub-surface's wl_surface
	 *	state. This mode allows a sub-surface to be updated on its own.
	 *
	 *	If cached state exists when wl_surface.commit is called in
	 *	desynchronized mode, the pending state is added to the cached
	 *	state, and applied as a whole. This invalidates the cache.
	 *
	 *	Note: even if a sub-surface is set to desynchronized, a parent
	 *	sub-surface may override it to behave as synchronized. For details,
	 *	see wl_subsurface.
	 *
	 *	If a surface's parent surface behaves as desynchronized, then
	 *	the cached state is applied on set_desync.
	 *      
	 *
	 * @param {WlSubsurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	setDesync(resource) {}
}

module.exports = WlSubsurfaceRequests


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(106);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(108)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(107)(false);
// imports


// module
exports.push([module.i, "body {\n    margin: 0;\n    padding: 0;\n    height: 100vh;\n    min-height: 100vh;\n}\n\n#workspace {\n    z-index: -65535;\n}\n\ncanvas {\n    will-change: transform, contents, display;\n    transform-origin: top left;\n    pointer-events: none;\n    position: absolute;\n    transition: inherit;\n    visibility: inherit;\n    opacity: inherit;\n}\n\n.fadeToHidden {\n    visibility: hidden;\n    opacity: 0;\n    transition: visibility 200ms, opacity 200ms ease-in-out;\n}\n\n.fadeToUnresponsive {\n    filter: grayscale(0.9) brightness(0.6) contrast(1.3) blur(1px);\n    transition: filter 1000ms ease-in-out;\n}\n\n.inputRegion {\n    transform-origin: top left;\n    position: absolute;\n    display: inline-block;\n    transform: inherit;\n}", ""]);

// exports


/***/ }),
/* 107 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(109);

module.exports = function(list, options) {
	if (false) {}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 109 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgWmBase; });
/* harmony import */ var _protocol_XdgWmBaseRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(111);
/* harmony import */ var _protocol_XdgWmBaseRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgWmBaseRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_XdgSurfaceResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(114);
/* harmony import */ var _protocol_XdgSurfaceResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgSurfaceResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _XdgSurface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(115);
/* harmony import */ var _XdgPositioner__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(123);










/**
 *
 *      The xdg_wm_base interface is exposed as a global object enabling clients
 *      to turn their wl_surfaces into windows in a desktop environment. It
 *      defines the basic functionality needed for clients and the compositor to
 *      create windows that can be dragged, resized, maximized, etc, as well as
 *      creating transient windows such as popup menus.
 *
 * @implements {XdgWmBaseRequests}
 */
class XdgWmBase extends _protocol_XdgWmBaseRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {Session} session
   * @param {UserShell}userShell
   * @param {Seat}seat
   * @return {XdgWmBase}
   */
  static create (session, userShell, seat) {
    return new XdgWmBase(session, userShell, seat)
  }

  /**
   * @param {Session} session
   * @param {UserShell}userShell
   * @param {Seat}seat
   * @private
   */
  constructor (session, userShell, seat) {
    super()
    /**
     * @type {Session}
     * @private
     */
    this._session = session
    /**
     * @type {UserShell}
     * @private
     */
    this._userShell = userShell
    /**
     * @type {Seat}
     * @private
     */
    this._seat = seat
    /**
     * @type {number}
     * @private
     */
    this._timeoutTimer = 0
    /**
     * @type {boolean}
     * @private
     */
    this._pingTimeoutActive = false
    /**
     * @type {number}
     * @private
     */
    this._doPingTimer = 0
    /**
     * @type {number}
     * @private
     */
    this._pingSerial = 0
    /**
     * @type {Array<WlSurfaceResource>}
     * @private
     */
    this._wlSurfaceResources = []
    /**
     * @type {Global}
     * @private
     */
    this._global = null
  }

  /**
   * @param {Registry}registry
   */
  registerGlobal (registry) {
    if (this._global) {
      return
    }
    this._global = registry.createGlobal(this, _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1___default.a.name, 1, (client, id, version) => {
      this.bindClient(client, id, version)
    })
  }

  unregisterGlobal () {
    if (!this._global) {
      return
    }
    this._global.destroy()
    this._global = null
  }

  /**
   *
   * Invoked when a client binds to this global.
   *
   * @param {!Client} client
   * @param {!number} id
   * @param {!number} version
   */
  bindClient (client, id, version) {
    const xdgWmBaseResource = new _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1___default.a(client, id, version)
    xdgWmBaseResource.implementation = this
    xdgWmBaseResource.onDestroy().then(() => {
      window.clearTimeout(this._timeoutTimer)
    })
    xdgWmBaseResource.onDestroy().then(() => {
      window.clearTimeout(this._doPingTimer)
    })
  }

  /**
   *
   *  Destroy this xdg_wm_base object.
   *
   *  Destroying a bound xdg_wm_base object while there are surfaces
   *  still alive created by this xdg_wm_base object instance is illegal
   *  and will result in a protocol error.
   *
   *
   * @param {XdgWmBaseResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    if (this._wlSurfaceResources.length > 0) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.defunctSurfaces, 'xdg_wm_base was destroyed before children.')
      false && console.log('Protocol error. xdg_wm_base was destroyed before children.')
      return
    }
    resource.destroy()
  }

  /**
   *
   *  Create a positioner object. A positioner object is used to position
   *  surfaces relative to some parent surface. See the interface description
   *  and xdg_surface.get_popup for details.
   *
   *
   * @param {XdgWmBaseResource} resource
   * @param {number} id
   *
   * @since 1
   * @override
   */
  createPositioner (resource, id) {
    const xdgPositionerResource = new _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_2___default.a(resource.client, id, resource.version)
    _XdgPositioner__WEBPACK_IMPORTED_MODULE_5__["default"].create(xdgPositionerResource)
  }

  /**
   *
   *  This creates an xdg_surface for the given surface. While xdg_surface
   *  itself is not a role, the corresponding surface may only be assigned
   *  a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
   *
   *  This creates an xdg_surface for the given surface. An xdg_surface is
   *  used as basis to define a role to a given surface, such as xdg_toplevel
   *  or xdg_popup. It also manages functionality shared between xdg_surface
   *  based surface roles.
   *
   *  See the documentation of xdg_surface for more details about what an
   *  xdg_surface is and how it is used.
   *
   *
   * @param {XdgWmBaseResource} resource
   * @param {number} id
   * @param {WlSurfaceResource} wlSurfaceResource
   *
   * @since 1
   * @override
   */
  getXdgSurface (resource, id, wlSurfaceResource) {
    const surface = /** @type {Surface} */wlSurfaceResource.implementation
    if (surface.pendingWlBuffer || surface.state.bufferContents) {
      resource.postError(XdgWmBase.Error.invalidSurfaceState, 'Surface had a buffer attached before xdg surface was created.')
      false && console.log('Protocol error. Surface had a buffer attached before xdg surface was created.')
      return
    }

    const xdgSurfaceResource = new _protocol_XdgSurfaceResource__WEBPACK_IMPORTED_MODULE_3___default.a(resource.client, id, resource.version)
    _XdgSurface__WEBPACK_IMPORTED_MODULE_4__["default"].create(xdgSurfaceResource, wlSurfaceResource, this._session, this._userShell, this._seat)
    this._wlSurfaceResources.push(wlSurfaceResource)
    surface.onDestroy().then(() => {
      const index = this._wlSurfaceResources.indexOf(wlSurfaceResource)
      if (index > -1) {
        this._wlSurfaceResources.splice(index, 1)
      }
    })
  }

  /**
   *
   *  A client must respond to a ping event with a pong request or
   *  the client may be deemed unresponsive. See xdg_wm_base.ping.
   *
   *
   * @param {XdgWmBaseResource} resource
   * @param {number} serial serial of the ping event
   *
   * @since 1
   * @override
   */
  pong (resource, serial) {
    // TODO compare serial with send out pingSerial
    if (this._pingTimeoutActive) {
      this._wlSurfaceResources.forEach((wlSurfaceResource) => {
        this._removeClassRecursively(/** @type {Surface} */wlSurfaceResource.implementation, 'fadeToUnresponsive')
      })
      this._pingTimeoutActive = false
    }
    window.clearTimeout(this._timeoutTimer)
    this._doPingTimer = window.setTimeout(() => {
      this._doPing(resource)
    }, 1000)
  }

  /**
   * @param {XdgWmBaseResource} resource
   * @private
   */
  _doPing (resource) {
    this._timeoutTimer = window.setTimeout(() => {
      if (!this._pingTimeoutActive) {
        // ping timed out, make view gray
        this._pingTimeoutActive = true
        this._wlSurfaceResources.forEach((wlSurfaceResource) => {
          this._addClassRecursively(/** @type {Surface} */wlSurfaceResource.implementation, 'fadeToUnresponsive')
        })
      }
    }, 3000)
    this._pingSerial++
    resource.ping(this._pingSerial)
    this.session.flush()
  }

  /**
   * @param {Surface}surface
   * @param {string}cssClass
   * @private
   */
  _removeClassRecursively (surface, cssClass) {
    surface.views.forEach((view) => {
      view.bufferedCanvas.removeCssClass(cssClass)
    })
    surface.children.forEach((surfaceChild) => {
      if (surfaceChild.surface !== surface) {
        this._removeClassRecursively(surfaceChild.surface, cssClass)
      }
    })
  }

  /**
   * @param {Surface}surface
   * @param {string}cssClass
   * @private
   */
  _addClassRecursively (surface, cssClass) {
    surface.views.forEach((view) => {
      view.bufferedCanvas.addCssClass(cssClass)
    })
    surface.children.forEach((surfaceChild) => {
      if (surfaceChild.surface !== surface) {
        this._addClassRecursively(surfaceChild.surface, cssClass)
      }
    })
  }
}


/***/ }),
/* 111 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgWmBaseRequests {

	/**
	 *
	 *	Destroy this xdg_wm_base object.
	 *
	 *	Destroying a bound xdg_wm_base object while there are surfaces
	 *	still alive created by this xdg_wm_base object instance is illegal
	 *	and will result in a protocol error.
	 *      
	 *
	 * @param {XdgWmBaseResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Create a positioner object. A positioner object is used to position
	 *	surfaces relative to some parent surface. See the interface description
	 *	and xdg_surface.get_popup for details.
	 *      
	 *
	 * @param {XdgWmBaseResource} resource 
	 * @param {number} id  
	 *
	 * @since 1
	 *
	 */
	createPositioner(resource, id) {}

	/**
	 *
	 *	This creates an xdg_surface for the given surface. While xdg_surface
	 *	itself is not a role, the corresponding surface may only be assigned
	 *	a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
	 *
	 *	This creates an xdg_surface for the given surface. An xdg_surface is
	 *	used as basis to define a role to a given surface, such as xdg_toplevel
	 *	or xdg_popup. It also manages functionality shared between xdg_surface
	 *	based surface roles.
	 *
	 *	See the documentation of xdg_surface for more details about what an
	 *	xdg_surface is and how it is used.
	 *      
	 *
	 * @param {XdgWmBaseResource} resource 
	 * @param {number} id  
	 * @param {*} surface  
	 *
	 * @since 1
	 *
	 */
	getXdgSurface(resource, id, surface) {}

	/**
	 *
	 *	A client must respond to a ping event with a pong request or
	 *	the client may be deemed unresponsive. See xdg_wm_base.ping.
	 *      
	 *
	 * @param {XdgWmBaseResource} resource 
	 * @param {number} serial serial of the ping event 
	 *
	 * @since 1
	 *
	 */
	pong(resource, serial) {}
}

module.exports = XdgWmBaseRequests


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The xdg_wm_base interface is exposed as a global object enabling clients
 *      to turn their wl_surfaces into windows in a desktop environment. It
 *      defines the basic functionality needed for clients and the compositor to
 *      create windows that can be dragged, resized, maximized, etc, as well as
 *      creating transient windows such as popup menus.
 *    
 */
class XdgWmBaseResource extends Resource {

	/**
	 *
	 *	The ping event asks the client if it's still alive. Pass the
	 *	serial specified in the event back to the compositor by sending
	 *	a "pong" request back with the specified serial. See xdg_wm_base.ping.
	 *
	 *	Compositors can use this to determine if the client is still
	 *	alive. It's unspecified what will happen if the client doesn't
	 *	respond to the ping request, or in what timeframe. Clients should
	 *	try to respond in a reasonable amount of time.
	 *
	 *	A compositor is free to ping in any way it wants, but a client must
	 *	always respond to any xdg_wm_base object it created.
	 *      
	 *
	 * @param {number} serial pass this to the pong request 
	 *
	 * @since 1
	 *
	 */
	ping (serial) {
		this.client.marshall(this.id, 0, [uint(serial)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {XdgWmBaseRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.createPositioner(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'no')
		await this.implementation.getXdgSurface(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.pong(this, ...args)
	}
}
XdgWmBaseResource.protocolName = 'xdg_wm_base'

XdgWmBaseResource.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0,
  /**
   * xdg_wm_base was destroyed before children
   */
  defunctSurfaces: 1,
  /**
   * the client tried to map or destroy a non-topmost popup
   */
  notTheTopmostPopup: 2,
  /**
   * the client specified an invalid popup parent surface
   */
  invalidPopupParent: 3,
  /**
   * the client provided an invalid surface state
   */
  invalidSurfaceState: 4,
  /**
   * the client provided an invalid positioner
   */
  invalidPositioner: 5
}

module.exports = XdgWmBaseResource


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      The xdg_positioner provides a collection of rules for the placement of a
 *      child surface relative to a parent surface. Rules can be defined to ensure
 *      the child surface remains within the visible area's borders, and to
 *      specify how the child surface changes its position, such as sliding along
 *      an axis, or flipping around a rectangle. These positioner-created rules are
 *      constrained by the requirement that a child surface must intersect with or
 *      be at least partially adjacent to its parent surface.
 *
 *      See the various requests for details about possible rules.
 *
 *      At the time of the request, the compositor makes a copy of the rules
 *      specified by the xdg_positioner. Thus, after the request is complete the
 *      xdg_positioner object can be destroyed or reused; further changes to the
 *      object will have no effect on previous usages.
 *
 *      For an xdg_positioner object to be considered complete, it must have a
 *      non-zero size set by set_size, and a non-zero anchor rectangle set by
 *      set_anchor_rect. Passing an incomplete xdg_positioner object when
 *      positioning a surface raises an error.
 *    
 */
class XdgPositionerResource extends Resource {

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {XdgPositionerRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'ii')
		await this.implementation.setSize(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.setAnchorRect(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.setAnchor(this, ...args)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.setGravity(this, ...args)
	}
	async [5] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.setConstraintAdjustment(this, ...args)
	}
	async [6] (message) {
		const args = this.client._unmarshallArgs(message,'ii')
		await this.implementation.setOffset(this, ...args)
	}
}
XdgPositionerResource.protocolName = 'xdg_positioner'

XdgPositionerResource.Error = {
  /**
   * invalid input provided
   */
  invalidInput: 0
}

XdgPositionerResource.Anchor = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 3,
  /**
   * 
   */
  right: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  topRight: 7,
  /**
   * 
   */
  bottomRight: 8
}

XdgPositionerResource.Gravity = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 3,
  /**
   * 
   */
  right: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  topRight: 7,
  /**
   * 
   */
  bottomRight: 8
}

XdgPositionerResource.ConstraintAdjustment = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  slideX: 1,
  /**
   * 
   */
  slideY: 2,
  /**
   * 
   */
  flipX: 4,
  /**
   * 
   */
  flipY: 8,
  /**
   * 
   */
  resizeX: 16,
  /**
   * 
   */
  resizeY: 32
}

module.exports = XdgPositionerResource


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      An interface that may be implemented by a wl_surface, for
 *      implementations that provide a desktop-style user interface.
 *
 *      It provides a base set of functionality required to construct user
 *      interface elements requiring management by the compositor, such as
 *      toplevel windows, menus, etc. The types of functionality are split into
 *      xdg_surface roles.
 *
 *      Creating an xdg_surface does not set the role for a wl_surface. In order
 *      to map an xdg_surface, the client must create a role-specific object
 *      using, e.g., get_toplevel, get_popup. The wl_surface for any given
 *      xdg_surface can have at most one role, and may not be assigned any role
 *      not based on xdg_surface.
 *
 *      A role must be assigned before any other requests are made to the
 *      xdg_surface object.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_surface state to take effect.
 *
 *      Creating an xdg_surface from a wl_surface which has a buffer attached or
 *      committed is a client error, and any attempts by a client to attach or
 *      manipulate a buffer prior to the first xdg_surface.configure call must
 *      also be treated as errors.
 *
 *      Mapping an xdg_surface-based role surface is defined as making it
 *      possible for the surface to be shown by the compositor. Note that
 *      a mapped surface is not guaranteed to be visible once it is mapped.
 *
 *      For an xdg_surface to be mapped by the compositor, the following
 *      conditions must be met:
 *      (1) the client has assigned an xdg_surface-based role to the surface
 *      (2) the client has set and committed the xdg_surface state and the
 *	  role-dependent state to the surface
 *      (3) the client has committed a buffer to the surface
 *
 *      A newly-unmapped surface is considered to have met condition (1) out
 *      of the 3 required conditions for mapping a surface if its role surface
 *      has not been destroyed.
 *    
 */
class XdgSurfaceResource extends Resource {

	/**
	 *
	 *	The configure event marks the end of a configure sequence. A configure
	 *	sequence is a set of one or more events configuring the state of the
	 *	xdg_surface, including the final xdg_surface.configure event.
	 *
	 *	Where applicable, xdg_surface surface roles will during a configure
	 *	sequence extend this event as a latched state sent as events before the
	 *	xdg_surface.configure event. Such events should be considered to make up
	 *	a set of atomically applied configuration states, where the
	 *	xdg_surface.configure commits the accumulated state.
	 *
	 *	Clients should arrange their surface for the new states, and then send
	 *	an ack_configure request with the serial sent in this configure event at
	 *	some point before committing the new surface.
	 *
	 *	If the client receives multiple configure events before it can respond
	 *	to one, it is free to discard all but the last event it received.
	 *      
	 *
	 * @param {number} serial serial of the configure event 
	 *
	 * @since 1
	 *
	 */
	configure (serial) {
		this.client.marshall(this.id, 0, [uint(serial)])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {XdgSurfaceRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'n')
		await this.implementation.getToplevel(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'n?oo')
		await this.implementation.getPopup(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'iiii')
		await this.implementation.setWindowGeometry(this, ...args)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'u')
		await this.implementation.ackConfigure(this, ...args)
	}
}
XdgSurfaceResource.protocolName = 'xdg_surface'

XdgSurfaceResource.Error = {
  /**
   * 
   */
  notConstructed: 1,
  /**
   * 
   */
  alreadyConstructed: 2,
  /**
   * 
   */
  unconfiguredBuffer: 3
}

module.exports = XdgSurfaceResource


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgSurface; });
/* harmony import */ var _protocol_XdgSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(116);
/* harmony import */ var _protocol_XdgSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgSurfaceRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(118);
/* harmony import */ var _protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _XdgToplevel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(119);
/* harmony import */ var _XdgPopup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(121);
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);












/**
 *
 *      An interface that may be implemented by a wl_surface, for
 *      implementations that provide a desktop-style user interface.
 *
 *      It provides a base set of functionality required to construct user
 *      interface elements requiring management by the compositor, such as
 *      toplevel windows, menus, etc. The types of functionality are split into
 *      xdg_surface roles.
 *
 *      Creating an xdg_surface does not set the role for a wl_surface. In order
 *      to map an xdg_surface, the client must create a role-specific object
 *      using, e.g., get_toplevel, get_popup. The wl_surface for any given
 *      xdg_surface can have at most one role, and may not be assigned any role
 *      not based on xdg_surface.
 *
 *      A role must be assigned before any other requests are made to the
 *      xdg_surface object.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_surface state to take effect.
 *
 *      Creating an xdg_surface from a wl_surface which has a buffer attached or
 *      committed is a client error, and any attempts by a client to attach or
 *      manipulate a buffer prior to the first xdg_surface.configure call must
 *      also be treated as errors.
 *
 *      Mapping an xdg_surface-based role surface is defined as making it
 *      possible for the surface to be shown by the compositor. Note that
 *      a mapped surface is not guaranteed to be visible once it is mapped.
 *
 *      For an xdg_surface to be mapped by the compositor, the following
 *      conditions must be met:
 *      (1) the client has assigned an xdg_surface-based role to the surface
 *      (2) the client has set and committed the xdg_surface state and the
 *    role-dependent state to the surface
 *      (3) the client has committed a buffer to the surface
 *
 *      A newly-unmapped surface is considered to have met condition (1) out
 *      of the 3 required conditions for mapping a surface if its role surface
 *      has not been destroyed.
 * @implements XdgSurfaceRequests
 */
class XdgSurface extends _protocol_XdgSurfaceRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {XdgSurfaceResource}xdgSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {Session} session
   * @param {UserShell}userShell
   * @param {Seat}seat
   * @return {XdgSurface}
   */
  static create (xdgSurfaceResource, wlSurfaceResource, session, userShell, seat) {
    const xdgSurface = new XdgSurface(xdgSurfaceResource, wlSurfaceResource, session, userShell, seat)
    xdgSurfaceResource.implementation = xdgSurface
    const surface = /** @type {Surface} */wlSurfaceResource.implementation
    surface.hasKeyboardInput = true
    surface.hasPointerInput = true
    surface.hasTouchInput = true
    return xdgSurface
  }

  /**
   * @param {XdgSurfaceResource}xdgSurfaceResource
   * @param {WlSurfaceResource}wlSurfaceResource
   * @param {Session} session
   * @param {UserShell}userShell
   * @param {Seat}seat
   * @private
   */
  constructor (xdgSurfaceResource, wlSurfaceResource, session, userShell, seat) {
    super()
    /**
     * @type {XdgSurfaceResource}
     */
    this.xdgSurfaceResource = xdgSurfaceResource
    /**
     * @type {WlSurfaceResource}
     */
    this.wlSurfaceResource = wlSurfaceResource
    /**
     * @type {Session}
     * @private
     */
    this._session = session
    /**
     * @type {UserShell}
     * @private
     */
    this._userShell = userShell
    /**
     * @type {Seat}
     * @private
     */
    this._seat = seat
    /**
     * @type {Rect}
     */
    this.pendingWindowGeometry = _math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
    /**
     * @type {number}
     */
    this.configureSerial = 0
    /**
     * @type {Rect}
     */
    this.windowGeometry = _math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(0, 0, 0, 0)
  }

  /**
   *
   *  Destroy the xdg_surface object. An xdg_surface must only be destroyed
   *  after its role object has been destroyed.
   *
   *
   * @param {XdgSurfaceResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *  This creates an xdg_toplevel object for the given xdg_surface and gives
   *  the associated wl_surface the xdg_toplevel role.
   *
   *  See the documentation of xdg_toplevel for more details about what an
   *  xdg_toplevel is and how it is used.
   *
   *
   * @param {XdgSurfaceResource} resource
   * @param {number} id
   *
   * @since 1
   * @override
   */
  getToplevel (resource, id) {
    const surface = this.wlSurfaceResource.implementation
    if (surface.role) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.role, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role.')
      return
    }
    const xdgToplevelResource = new _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_1___default.a(resource.client, id, resource.version)
    const xdgToplevel = _XdgToplevel__WEBPACK_IMPORTED_MODULE_4__["default"].create(xdgToplevelResource, this, this._session, this._userShell)
    xdgToplevelResource.implementation = xdgToplevel
    this.ackConfigure = (resource, serial) => {
      xdgToplevel.ackConfigure(serial)
    }
  }

  /**
   *
   *  This creates an xdg_popup object for the given xdg_surface and gives
   *  the associated wl_surface the xdg_popup role.
   *
   *  If null is passed as a parent, a parent surface must be specified using
   *  some other protocol, before committing the initial state.
   *
   *  See the documentation of xdg_popup for more details about what an
   *  xdg_popup is and how it is used.
   *
   *
   * @param {XdgSurfaceResource} resource
   * @param {number} id
   * @param {XdgSurfaceResource} parent
   * @param {XdgPositionerResource} positioner
   *
   * @since 1
   * @override
   */
  getPopup (resource, id, parent, positioner) {
    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation
    if (surface.role) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.role, 'Given surface has another role.')
      false && console.log('Protocol error. Given surface has another role.')
      return
    }

    const xdgPositioner = positioner.implementation
    if (xdgPositioner.size === null) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidPositioner, 'Client provided an invalid positioner. Size is NULL.')
      false && console.log('Protocol error. Client provided an invalid positioner. Size is NULL.')
      return
    }

    if (xdgPositioner.anchorRect === null) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidPositioner, 'Client provided an invalid positioner. AnchorRect is NULL.')
      false && console.log('Protocol error. Client provided an invalid positioner. AnchorRect is NULL.')
      return
    }

    const positionerState = xdgPositioner.createStateCopy()

    const xdgPopupResource = new _protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_3___default.a(resource.client, id, resource.version)
    const xdgPopup = _XdgPopup__WEBPACK_IMPORTED_MODULE_5__["default"].create(xdgPopupResource, this, parent, positionerState, this._session, this._seat)
    this.ackConfigure = (resource, serial) => {
      xdgPopup.ackConfigure(serial)
    }

    const onNewView = (view) => {
      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_7__["default"].createRenderFrame()
      view.applyTransformations(renderFrame)
      renderFrame.fire()
      view.onDestroy().then(() => {
        view.detach()
      })
    }

    if (parent) {
      const parentXdgSurface = /** @type {XdgSurface} */parent.implementation
      const parentSurface = /** @type {Surface} */parentXdgSurface.wlSurfaceResource.implementation
      const views = parentSurface.addChild(surface.surfaceChildSelf)
      views.forEach(onNewView)
    } else {
      const view = surface.createView()
      onNewView(view)
    }

    // this handles the case where a view is created later on (ie if a new parent view is created)
    surface.onViewCreated = onNewView
  }

  /**
   *
   *  The window geometry of a surface is its "visible bounds" from the
   *  user's perspective. Client-side decorations often have invisible
   *  portions like drop-shadows which should be ignored for the
   *  purposes of aligning, placing and constraining windows.
   *
   *  The window geometry is double buffered, and will be applied at the
   *  time wl_surface.commit of the corresponding wl_surface is called.
   *
   *  When maintaining a position, the compositor should treat the (x, y)
   *  coordinate of the window geometry as the top left corner of the window.
   *  A client changing the (x, y) window geometry coordinate should in
   *  general not alter the position of the window.
   *
   *  Once the window geometry of the surface is set, it is not possible to
   *  unset it, and it will remain the same until set_window_geometry is
   *  called again, even if a new subsurface or buffer is attached.
   *
   *  If never set, the value is the full bounds of the surface,
   *  including any subsurfaces. This updates dynamically on every
   *  commit. This unset is meant for extremely simple clients.
   *
   *  The arguments are given in the surface-local coordinate space of
   *  the wl_surface associated with this xdg_surface.
   *
   *  The width and height must be greater than zero. Setting an invalid size
   *  will raise an error. When applied, the effective window geometry will be
   *  the set window geometry clamped to the bounding rectangle of the
   *  combined geometry of the surface of the xdg_surface and the associated
   *  subsurfaces.
   *
   *
   * @param {XdgSurfaceResource} resource
   * @param {Number} x
   * @param {Number} y
   * @param {Number} width
   * @param {Number} height
   *
   * @since 1
   * @override
   */
  setWindowGeometry (resource, x, y, width, height) {
    if (width <= 0 || height <= 0) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidSurfaceState, 'Client provided negative window geometry.')
      false && console.log('Protocol error. Client provided negative window geometry.')
      return
    }
    this.pendingWindowGeometry = _math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(x, y, x + width, y + height)
  }

  /**
   * @param {Rect}windowGeometry
   */
  updateWindowGeometry (windowGeometry) {
    this.windowGeometry = this._createBoundingRectangle().intersect(windowGeometry)
  }

  /**
   * @return {Rect}
   * @private
   */
  _createBoundingRectangle () {
    const xs = [0]
    const ys = [0]

    const surface = /** @type {Surface} */this.wlSurfaceResource.implementation
    const size = surface.size
    xs.push(size.w)
    ys.push(size.h)

    surface.subsurfaceChildren.forEach((subsurfaceChild) => {
      const subsurfacePosition = subsurfaceChild.position
      const subsurfaceSize = subsurfaceChild.surface.size

      xs.push(subsurfacePosition.x)
      ys.push(subsurfacePosition.y)
      xs.push(subsurfacePosition.x + subsurfaceSize.w)
      ys.push(subsurfacePosition.y + subsurfaceSize.h)
    })

    const minX = Math.min(...xs)
    const maxX = Math.max(...xs)
    const minY = Math.min(...ys)
    const maxY = Math.max(...ys)

    return _math_Rect__WEBPACK_IMPORTED_MODULE_6__["default"].create(minX, minY, maxX, maxY)
  }

  /**
   *
   *  When a configure event is received, if a client commits the
   *  surface in response to the configure event, then the client
   *  must make an ack_configure request sometime before the commit
   *  request, passing along the serial of the configure event.
   *
   *  For instance, for toplevel surfaces the compositor might use this
   *  information to move a surface to the top left only when the client has
   *  drawn itself for the maximized or fullscreen state.
   *
   *  If the client receives multiple configure events before it
   *  can respond to one, it only has to ack the last configure event.
   *
   *  A client is not required to commit immediately after sending
   *  an ack_configure request - it may even ack_configure several times
   *  before its next surface commit.
   *
   *  A client may send multiple ack_configure requests before committing, but
   *  only the last request sent before a commit indicates which configure
   *  event the client really is responding to.
   *
   *
   * @param {XdgSurfaceResource} resource
   * @param {Number} serial the serial from the configure event
   *
   * @since 1
   * @override
   */
  ackConfigure (resource, serial) {
    // implemented by 'subclass' interface
  }

  emitConfigureDone () {
    this.xdgSurfaceResource.configure(++this.configureSerial)
  }
}


/***/ }),
/* 116 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgSurfaceRequests {

	/**
	 *
	 *	Destroy the xdg_surface object. An xdg_surface must only be destroyed
	 *	after its role object has been destroyed.
	 *      
	 *
	 * @param {XdgSurfaceResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	This creates an xdg_toplevel object for the given xdg_surface and gives
	 *	the associated wl_surface the xdg_toplevel role.
	 *
	 *	See the documentation of xdg_toplevel for more details about what an
	 *	xdg_toplevel is and how it is used.
	 *      
	 *
	 * @param {XdgSurfaceResource} resource 
	 * @param {number} id  
	 *
	 * @since 1
	 *
	 */
	getToplevel(resource, id) {}

	/**
	 *
	 *	This creates an xdg_popup object for the given xdg_surface and gives
	 *	the associated wl_surface the xdg_popup role.
	 *
	 *	If null is passed as a parent, a parent surface must be specified using
	 *	some other protocol, before committing the initial state.
	 *
	 *	See the documentation of xdg_popup for more details about what an
	 *	xdg_popup is and how it is used.
	 *      
	 *
	 * @param {XdgSurfaceResource} resource 
	 * @param {number} id  
	 * @param {?*} parent  
	 * @param {*} positioner  
	 *
	 * @since 1
	 *
	 */
	getPopup(resource, id, parent, positioner) {}

	/**
	 *
	 *	The window geometry of a surface is its "visible bounds" from the
	 *	user's perspective. Client-side decorations often have invisible
	 *	portions like drop-shadows which should be ignored for the
	 *	purposes of aligning, placing and constraining windows.
	 *
	 *	The window geometry is double buffered, and will be applied at the
	 *	time wl_surface.commit of the corresponding wl_surface is called.
	 *
	 *	When maintaining a position, the compositor should treat the (x, y)
	 *	coordinate of the window geometry as the top left corner of the window.
	 *	A client changing the (x, y) window geometry coordinate should in
	 *	general not alter the position of the window.
	 *
	 *	Once the window geometry of the surface is set, it is not possible to
	 *	unset it, and it will remain the same until set_window_geometry is
	 *	called again, even if a new subsurface or buffer is attached.
	 *
	 *	If never set, the value is the full bounds of the surface,
	 *	including any subsurfaces. This updates dynamically on every
	 *	commit. This unset is meant for extremely simple clients.
	 *
	 *	The arguments are given in the surface-local coordinate space of
	 *	the wl_surface associated with this xdg_surface.
	 *
	 *	The width and height must be greater than zero. Setting an invalid size
	 *	will raise an error. When applied, the effective window geometry will be
	 *	the set window geometry clamped to the bounding rectangle of the
	 *	combined geometry of the surface of the xdg_surface and the associated
	 *	subsurfaces.
	 *      
	 *
	 * @param {XdgSurfaceResource} resource 
	 * @param {number} x  
	 * @param {number} y  
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setWindowGeometry(resource, x, y, width, height) {}

	/**
	 *
	 *	When a configure event is received, if a client commits the
	 *	surface in response to the configure event, then the client
	 *	must make an ack_configure request sometime before the commit
	 *	request, passing along the serial of the configure event.
	 *
	 *	For instance, for toplevel surfaces the compositor might use this
	 *	information to move a surface to the top left only when the client has
	 *	drawn itself for the maximized or fullscreen state.
	 *
	 *	If the client receives multiple configure events before it
	 *	can respond to one, it only has to ack the last configure event.
	 *
	 *	A client is not required to commit immediately after sending
	 *	an ack_configure request - it may even ack_configure several times
	 *	before its next surface commit.
	 *
	 *	A client may send multiple ack_configure requests before committing, but
	 *	only the last request sent before a commit indicates which configure
	 *	event the client really is responding to.
	 *      
	 *
	 * @param {XdgSurfaceResource} resource 
	 * @param {number} serial the serial from the configure event 
	 *
	 * @since 1
	 *
	 */
	ackConfigure(resource, serial) {}
}

module.exports = XdgSurfaceRequests


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      This interface defines an xdg_surface role which allows a surface to,
 *      among other things, set window-like properties such as maximize,
 *      fullscreen, and minimize, set application-specific metadata like title and
 *      id, and well as trigger user interactive operations such as interactive
 *      resize and move.
 *
 *      Unmapping an xdg_toplevel means that the surface cannot be shown
 *      by the compositor until it is explicitly mapped again.
 *      All active operations (e.g., move, resize) are canceled and all
 *      attributes (e.g. title, state, stacking, ...) are discarded for
 *      an xdg_toplevel surface when it is unmapped.
 *
 *      Attaching a null buffer to a toplevel unmaps the surface.
 *    
 */
class XdgToplevelResource extends Resource {

	/**
	 *
	 *	This configure event asks the client to resize its toplevel surface or
	 *	to change its state. The configured state should not be applied
	 *	immediately. See xdg_surface.configure for details.
	 *
	 *	The width and height arguments specify a hint to the window
	 *	about how its surface should be resized in window geometry
	 *	coordinates. See set_window_geometry.
	 *
	 *	If the width or height arguments are zero, it means the client
	 *	should decide its own window dimension. This may happen when the
	 *	compositor needs to configure the state of the surface but doesn't
	 *	have any information about any previous or expected dimension.
	 *
	 *	The states listed in the event specify how the width/height
	 *	arguments should be interpreted, and possibly how it should be
	 *	drawn.
	 *
	 *	Clients must send an ack_configure in response to this event. See
	 *	xdg_surface.configure and xdg_surface.ack_configure for details.
	 *      
	 *
	 * @param {number} width  
	 * @param {number} height  
	 * @param {TypedArray} states  
	 *
	 * @since 1
	 *
	 */
	configure (width, height, states) {
		this.client.marshall(this.id, 0, [int(width), int(height), array(states)])
	}

	/**
	 *
	 *	The close event is sent by the compositor when the user
	 *	wants the surface to be closed. This should be equivalent to
	 *	the user clicking the close button in client-side decorations,
	 *	if your application has any.
	 *
	 *	This is only a request that the user intends to close the
	 *	window. The client may choose to ignore this request, or show
	 *	a dialog to ask the user to save their data, etc.
	 *      
	 * @since 1
	 *
	 */
	close () {
		this.client.marshall(this.id, 1, [])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {XdgToplevelRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'?o')
		await this.implementation.setParent(this, ...args)
	}
	async [2] (message) {
		const args = this.client._unmarshallArgs(message,'s')
		await this.implementation.setTitle(this, ...args)
	}
	async [3] (message) {
		const args = this.client._unmarshallArgs(message,'s')
		await this.implementation.setAppId(this, ...args)
	}
	async [4] (message) {
		const args = this.client._unmarshallArgs(message,'ouii')
		await this.implementation.showWindowMenu(this, ...args)
	}
	async [5] (message) {
		const args = this.client._unmarshallArgs(message,'ou')
		await this.implementation.move(this, ...args)
	}
	async [6] (message) {
		const args = this.client._unmarshallArgs(message,'ouu')
		await this.implementation.resize(this, ...args)
	}
	async [7] (message) {
		const args = this.client._unmarshallArgs(message,'ii')
		await this.implementation.setMaxSize(this, ...args)
	}
	async [8] (message) {
		const args = this.client._unmarshallArgs(message,'ii')
		await this.implementation.setMinSize(this, ...args)
	}
	async [9] (message) {
		await this.implementation.setMaximized(this)
	}
	async [10] (message) {
		await this.implementation.unsetMaximized(this)
	}
	async [11] (message) {
		const args = this.client._unmarshallArgs(message,'?o')
		await this.implementation.setFullscreen(this, ...args)
	}
	async [12] (message) {
		await this.implementation.unsetFullscreen(this)
	}
	async [13] (message) {
		await this.implementation.setMinimized(this)
	}
}
XdgToplevelResource.protocolName = 'xdg_toplevel'

XdgToplevelResource.ResizeEdge = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  right: 8,
  /**
   * 
   */
  topRight: 9,
  /**
   * 
   */
  bottomRight: 10
}

XdgToplevelResource.State = {
  /**
   * the surface is maximized
   */
  maximized: 1,
  /**
   * the surface is fullscreen
   */
  fullscreen: 2,
  /**
   * the surface is being resized
   */
  resizing: 3,
  /**
   * the surface is now activated
   */
  activated: 4
}

module.exports = XdgToplevelResource


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

const {Resource, WireFormat} = __webpack_require__(3)
const {parseFixed, uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional} = WireFormat

/**
 *
 *      A popup surface is a short-lived, temporary surface. It can be used to
 *      implement for example menus, popovers, tooltips and other similar user
 *      interface concepts.
 *
 *      A popup can be made to take an explicit grab. See xdg_popup.grab for
 *      details.
 *
 *      When the popup is dismissed, a popup_done event will be sent out, and at
 *      the same time the surface will be unmapped. See the xdg_popup.popup_done
 *      event for details.
 *
 *      Explicitly destroying the xdg_popup object will also dismiss the popup and
 *      unmap the surface. Clients that want to dismiss the popup when another
 *      surface of their own is clicked should dismiss the popup using the destroy
 *      request.
 *
 *      The parent surface must have either the xdg_toplevel or xdg_popup surface
 *      role.
 *
 *      A newly created xdg_popup will be stacked on top of all previously created
 *      xdg_popup surfaces associated with the same xdg_toplevel.
 *
 *      The parent of an xdg_popup must be mapped (see the xdg_surface
 *      description) before the xdg_popup itself.
 *
 *      The x and y arguments passed when creating the popup object specify
 *      where the top left of the popup should be placed, relative to the
 *      local surface coordinates of the parent surface. See
 *      xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 *      partially adjacent to its parent surface.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_popup state to take effect.
 *    
 */
class XdgPopupResource extends Resource {

	/**
	 *
	 *	This event asks the popup surface to configure itself given the
	 *	configuration. The configured state should not be applied immediately.
	 *	See xdg_surface.configure for details.
	 *
	 *	The x and y arguments represent the position the popup was placed at
	 *	given the xdg_positioner rule, relative to the upper left corner of the
	 *	window geometry of the parent surface.
	 *      
	 *
	 * @param {number} x x position relative to parent surface window geometry 
	 * @param {number} y y position relative to parent surface window geometry 
	 * @param {number} width window geometry width 
	 * @param {number} height window geometry height 
	 *
	 * @since 1
	 *
	 */
	configure (x, y, width, height) {
		this.client.marshall(this.id, 0, [int(x), int(y), int(width), int(height)])
	}

	/**
	 *
	 *	The popup_done event is sent out when a popup is dismissed by the
	 *	compositor. The client should destroy the xdg_popup object at this
	 *	point.
	 *      
	 * @since 1
	 *
	 */
	popupDone () {
		this.client.marshall(this.id, 1, [])
	}

/**
	 *@param {Client}client
	 *@param {number}id
	 *@param {number}version
	 */
	constructor (client, id, version) {
		super(client, id, version)
		/**
		 * @type {XdgPopupRequests|null}
		 */
		this.implementation = null
	}

	async [0] (message) {
		await this.implementation.destroy(this)
	}
	async [1] (message) {
		const args = this.client._unmarshallArgs(message,'ou')
		await this.implementation.grab(this, ...args)
	}
}
XdgPopupResource.protocolName = 'xdg_popup'

XdgPopupResource.Error = {
  /**
   * tried to grab after being mapped
   */
  invalidGrab: 0
}

module.exports = XdgPopupResource


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgToplevel; });
/* harmony import */ var _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
/* harmony import */ var _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_XdgToplevelRequests__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/* harmony import */ var _protocol_XdgToplevelRequests__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgToplevelRequests__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _Size__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);
/* harmony import */ var _render_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
/* harmony import */ var _math_Mat4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27);











const {none, bottom, bottomLeft, bottomRight, left, right, top, topLeft, topRight} = _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_0___default.a.ResizeEdge
const {fullscreen, activated, maximized, resizing} = _protocol_XdgToplevelResource__WEBPACK_IMPORTED_MODULE_0___default.a.State

/**
 *
 *      This interface defines an xdg_surface role which allows a surface to,
 *      among other things, set window-like properties such as maximize,
 *      fullscreen, and minimize, set application-specific metadata like title and
 *      id, and well as trigger user interactive operations such as interactive
 *      resize and move.
 *
 *      Unmapping an xdg_toplevel means that the surface cannot be shown
 *      by the compositor until it is explicitly mapped again.
 *      All active operations (e.g., move, resize) are canceled and all
 *      attributes (e.g. title, state, stacking, ...) are discarded for
 *      an xdg_toplevel surface when it is unmapped.
 *
 *      Attaching a null buffer to a toplevel unmaps the surface.
 *
 * @implements {SurfaceRole}
 * @implements {XdgToplevelRequests}
 */
class XdgToplevel extends _protocol_XdgToplevelRequests__WEBPACK_IMPORTED_MODULE_1___default.a {
  /**
   * @param {XdgToplevelResource}xdgToplevelResource
   * @param {XdgSurface}xdgSurface
   * @param {Session} session
   * @param {UserShell}userShell
   */
  static create (xdgToplevelResource, xdgSurface, session, userShell) {
    const surface = /** @type {Surface} */xdgSurface.wlSurfaceResource.implementation
    const userShellSurface = userShell.manage(surface)
    const xdgToplevel = new XdgToplevel(xdgToplevelResource, xdgSurface, session, userShellSurface)
    xdgToplevelResource.implementation = xdgToplevel
    surface.role = xdgToplevel
    xdgToplevelResource.onDestroy().then(() => {
      if (xdgToplevel._userShellSurface) {
        xdgToplevel._userShellSurface.destroy()
      }
    })

    userShellSurface.onActivationRequest = () => {
      if (!xdgToplevel._activationRequested) {
        xdgToplevel._activationRequested = true
        if (!xdgToplevel._configureState.state.includes(activated)) {
          const newState = xdgToplevel._configureState.state.slice()
          newState.push(activated)
          xdgToplevel._emitConfigure(xdgToplevelResource, xdgToplevel._configureState.width, xdgToplevel._configureState.height, newState, none)
        }
      }
    }
    userShellSurface.onInactive = () => {
      if (xdgToplevel._configureState.state.includes(activated)) {
        const newState = xdgToplevel._configureState.state.slice()
        const idx = newState.indexOf(activated)
        newState.splice(idx, 1)
        xdgToplevel._emitConfigure(xdgToplevelResource, xdgToplevel._configureState.width, xdgToplevel._configureState.height, newState, none)
      }
    }

    return xdgToplevel
  }

  /**
   * Use XdgToplevel.create(..) instead.
   * @param {XdgToplevelResource}xdgToplevelResource
   * @param {XdgSurface}xdgSurface
   * @param {Session} session
   * @param {UserShellSurface} userShellSurface
   * @private
   */
  constructor (xdgToplevelResource, xdgSurface, session, userShellSurface) {
    super()
    /**
     * @type {XdgToplevel}
     */
    this.resource = xdgToplevelResource
    /**
     * @type {XdgSurface}
     */
    this.xdgSurface = xdgSurface
    /**
     * @type {Session}
     * @private
     */
    this._session = session
    /**
     * @type {UserShellSurface}
     * @private
     */
    this._userShellSurface = userShellSurface
    /**
     * @type {XdgToplevelResource|null}
     * @private
     */
    this._parent = null
    /**
     * @type {string}
     * @private
     */
    this._title = ''
    /**
     * @type {string}
     * @private
     */
    this._appId = ''
    /**
     * @type {Point}
     * @private
     */
    this._pendingMaxSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
    /**
     * @type {Point}
     */
    this._maxSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
    /**
     * @type {Point}
     * @private
     */
    this._pendingMinSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, 0)
    /**
     * @type {Point}
     */
    this._minSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, 0)
    /**
     * @type {Array<{serial: number, state: number[], width: number, height: number, resizeEdge: number}>}
     */
    this._pendingConfigureStates = []
    /**
     * @type {{state: number[], width: number, height: number}|null}
     * @private
     */
    this._unfullscreenConfigureState = null

    /**
     * @type {{serial: number, state: number[], width: number, height: number}}
     * @private
     */
    this._ackedConfigureState = {serial: 0, state: [], width: 0, height: 0, resizeEdge: 0}
    /**
     * @type {{serial: number, state: number[], width: number, height: number}}
     * @private
     */
    this._configureState = {serial: 0, state: [], width: 0, height: 0, resizeEdge: 0}
    /**
     * @type {Rect|Null}
     * @private
     */
    this._previousGeometry = null
    /**
     * @type {boolean}
     */
    this.mapped = false
    /**
     * @type {boolean}
     * @private
     */
    this._activationRequested = false
  }

  /**
   * @return {{windowGeometry: Rect, maxSize: Point, minSize: Point, configureState: {serial: number, state: number[], width: number, height: number}}}
   * @override
   */
  captureRoleState () {
    return {
      windowGeometry: this.xdgSurface.pendingWindowGeometry,
      maxSize: this._pendingMaxSize,
      minSize: this._pendingMinSize,
      configureState: this._ackedConfigureState
    }
  }

  /**
   * @param {{windowGeometry: Rect, maxSize: Point, minSize: Point, configureState: {serial: number, state: number[], width: number, height: number}}}roleState
   * @override
   */
  setRoleState (roleState) {
    this._maxSize = roleState.maxSize
    this._minSize = roleState.minSize
    this._configureState = roleState.configureState
    this.xdgSurface.updateWindowGeometry(roleState.windowGeometry)

    if (this._activationRequested && this._configureState.state.includes(activated)) {
      this._activationRequested = false
      this._userShellSurface.activationAck()
    }
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @return {Promise<void>}
   * @override
   */
  async onCommit (surface, renderFrame, newState) {
    if (newState.bufferContents) {
      if (!this.mapped) {
        this._map(surface)
      }
      if (newState.roleState.configureState.state.includes(resizing)) {
        this._resizingCommit(surface, renderFrame, newState)
      } else if (newState.roleState.configureState.state.includes(maximized)) {
        this._maximizedCommit(surface, renderFrame, newState)
      } else if (newState.roleState.configureState.state.includes(fullscreen)) {
        this._fullscreenCommit(surface, renderFrame, newState)
      } else {
        this._normalCommit(surface, renderFrame, newState)
      }
    } else if (this.mapped) {
      this._unmap()
    }

    await surface.render(renderFrame, newState)
    renderFrame.fire()
    await renderFrame
    this._session.flush()
  }

  /**
   * @param {Surface}surface
   * @private
   */
  _map (surface) {
    this.mapped = true
    this._userShellSurface.mapped = true
  }

  /**
   * @private
   */
  _unmap () {
    this.mapped = false
    this._configureState = {serial: 0, state: [], width: 0, height: 0, resizeEdge: 0}
    this._userShellSurface.mapped = false
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _resizingCommit (surface, renderFrame, newState) {
    const roleState = newState.roleState
    const {w: newSurfaceWidth, h: newSurfaceHeight} = roleState.windowGeometry.size

    const {w: oldSurfaceWidth, h: oldSurfaceHeight} = this.xdgSurface.windowGeometry.size

    let dx = 0
    let dy = 0
    const edges = this._configureState.resizeEdge
    switch (edges) {
      case topRight:
      case top: {
        dy = oldSurfaceHeight - newSurfaceHeight
        break
      }
      case bottomLeft:
      case left: {
        dx = oldSurfaceWidth - newSurfaceWidth
        break
      }
      case topLeft: {
        dx = oldSurfaceWidth - newSurfaceWidth
        dy = oldSurfaceHeight - newSurfaceHeight
        break
      }
      default: {
        break
      }
    }

    if (dx || dy) {
      const {x, y} = surface.surfaceChildSelf.position
      surface.surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x + dx, y + dy)
      surface.views.forEach(value => {
        value.applyTransformations(renderFrame)
      })
    }
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _maximizedCommit (surface, renderFrame, newState) {
    const roleState = newState.roleState
    const {w: newSurfaceWidth, h: newSurfaceHeight} = roleState.windowGeometry.size

    if (newSurfaceWidth !== roleState.configureState.width || newSurfaceHeight !== roleState.configureState.height) {
      this.resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidSurfaceState, 'Surface size does not match configure event.')
      false && console.log('Protocol error. Surface size does not match configure event.')
      return
    }

    if (!this._previousGeometry) {
      this._storePreviousGeometry()
    }
    if (this._unfullscreenConfigureState) {
      this._unfullscreenConfigureState = null
    }
    const x = 0
    const {y} = document.getElementById('workspace').getBoundingClientRect()
    const windowGeoPositionOffset = newState.roleState.windowGeometry.position

    const primaryView = surface.views.find(view => { return view.primary })
    const viewPositionOffset = primaryView.toViewSpaceFromSurface(windowGeoPositionOffset)

    primaryView.customTransformation = _math_Mat4__WEBPACK_IMPORTED_MODULE_6__["default"].translation(x - viewPositionOffset.x, y - viewPositionOffset.y)
    primaryView.applyTransformations(renderFrame)
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _fullscreenCommit (surface, renderFrame, newState) {
    const bufferSize = newState.bufferContents.size
    const {x: newSurfaceWidth, y: newSurfaceHeight} = surface.toSurfaceSpace(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(bufferSize.w, bufferSize.h))
    if (newSurfaceWidth > this._configureState.width || newSurfaceHeight > this._configureState.height) {
      this.resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidSurfaceState, 'Surface size does not match configure event.')
      false && console.log('Protocol error. Surface size does not match configure event.')
      return
    }

    if (!this._unfullscreenConfigureState) {
      this._unfullscreenConfigureState = this._configureState
    }
    if (!this._previousGeometry) {
      this._storePreviousGeometry()
    }

    const x = (window.innerWidth - newSurfaceWidth) / 2
    const y = (window.innerHeight - newSurfaceHeight) / 2

    surface.surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
    surface.views.forEach(value => {
      value.applyTransformations(renderFrame)
    })
    // TODO put an opaque black fullscreen div behind the fullscreened application
    // TODO make sure z-order is always the highest
    // TODO also do this for ShellSurface
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _normalCommit (surface, renderFrame, newState) {
    if (this._previousGeometry) {
      // restore position (we came from a fullscreen or maximize and must restore the position)
      const primaryView = surface.views.find(view => { return view.primary })
      primaryView.customTransformation = null
      primaryView.applyTransformations(renderFrame)
      this._previousGeometry = null
    }
    if (this._unfullscreenConfigureState) {
      this._unfullscreenConfigureState = null
    }
  }

  /**
   * @param {number}serial
   */
  ackConfigure (serial) {
    this._pendingConfigureStates = this._pendingConfigureStates.filter((pendingConfigureState) => {
      if (pendingConfigureState.serial < serial) {
        return false
      } else if (pendingConfigureState.serial === serial) {
        this._ackedConfigureState = pendingConfigureState
        return false
      }
      return true
    })
  }

  /**
   * @private
   */
  _storePreviousGeometry () {
    this._previousGeometry = this.xdgSurface.windowGeometry
  }

  /**
   *
   *  This request destroys the role surface and unmaps the surface;
   *  see "Unmapping" behavior in interface section for details.
   *
   *
   * @param {XdgToplevelResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    this._unmap()
    resource.destroy()
  }

  /**
   *
   *  Set the "parent" of this surface. This surface should be stacked
   *  above the parent surface and all other ancestor surfaces.
   *
   *  Parent windows should be set on dialogs, toolboxes, or other
   *  "auxiliary" surfaces, so that the parent is raised when the dialog
   *  is raised.
   *
   *  Setting a null parent for a child window removes any parent-child
   *  relationship for the child. Setting a null parent for a window which
   *  currently has no parent is a no-op.
   *
   *  If the parent is unmapped then its children are managed as
   *  though the parent of the now-unmapped parent has become the
   *  parent of this surface. If no parent exists for the now-unmapped
   *  parent then the children are managed as though they have no
   *  parent surface.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {?XdgToplevelResource} parent
   *
   * @since 1
   * @override
   */
  setParent (resource, parent) {
    if (this._parent) {
      const oldParentXdgToplevel = /** @type {XdgToplevel} */this._parent.implementation
      const oldParentXdgSurface = oldParentXdgToplevel.xdgSurface
      const oldParentSurface = /** @type {Surface} */oldParentXdgSurface.wlSurfaceResource.implementation
      const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
      oldParentSurface.removeChild(surface.surfaceChildSelf)
    }

    if (parent) {
      const parentXdgToplevel = /** @type {XdgToplevel} */parent.implementation
      const parentXdgSurface = parentXdgToplevel.xdgSurface
      const parentSurface = /** @type {Surface} */parentXdgSurface.wlSurfaceResource.implementation
      const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
      parentSurface.addToplevelChild(surface.surfaceChildSelf)
    }

    this._parent = parent
  }

  /**
   *
   *  Set a short title for the surface.
   *
   *  This string may be used to identify the surface in a task bar,
   *  window list, or other user interface elements provided by the
   *  compositor.
   *
   *  The string must be encoded in UTF-8.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {string} title undefined
   *
   * @since 1
   * @override
   */
  setTitle (resource, title) {
    this._title = title
    this._userShellSurface.title = title
  }

  /**
   *
   *  Set an application identifier for the surface.
   *
   *  The app ID identifies the general class of applications to which
   *  the surface belongs. The compositor can use this to group multiple
   *  surfaces together, or to determine how to launch a new application.
   *
   *  For D-Bus activatable applications, the app ID is used as the D-Bus
   *  service name.
   *
   *  The compositor shell will try to group application surfaces together
   *  by their app ID. As a best practice, it is suggested to select app
   *  ID's that match the basename of the application's .desktop file.
   *  For example, "org.freedesktop.FooViewer" where the .desktop file is
   *  "org.freedesktop.FooViewer.desktop".
   *
   *  See the desktop-entry specification [0] for more details on
   *  application identifiers and how they relate to well-known D-Bus
   *  names and .desktop files.
   *
   *  [0] http://standards.freedesktop.org/desktop-entry-spec/
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {string} appId undefined
   *
   * @since 1
   * @override
   */
  setAppId (resource, appId) {
    this._appId = appId
    this._userShellSurface.appId = appId
  }

  /**
   *
   *  Clients implementing client-side decorations might want to show
   *  a context menu when right-clicking on the decorations, giving the
   *  user a menu that they can use to maximize or minimize the window.
   *
   *  This request asks the compositor to pop up such a window menu at
   *  the given position, relative to the local surface coordinates of
   *  the parent surface. There are no guarantees as to what menu items
   *  the window menu contains.
   *
   *  This request must be used in response to some sort of user action
   *  like a button press, key press, or touch down event.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {WlSeatResource} wlSeatResource the wl_seat of the user event
   * @param {number} serial the serial of the user event
   * @param {number} x the x position to pop up the window menu at
   * @param {number} y the y position to pop up the window menu at
   *
   * @since 1
   *
   */
  showWindowMenu (resource, wlSeatResource, serial, x, y) {
    const seat = /** @type {Seat} */wlSeatResource.implementation

    if (!seat.isValidInputSerial(serial)) {
      false && console.log('showWindowMenu serial mismatch. Ignoring.')
      return
    }

    this._showWindowMenuAt(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y))
  }

  /**
   * @param {Point}point
   * @private
   */
  _showWindowMenuAt (point) {
    // TODO
  }

  /**
   *
   *  Start an interactive, user-driven move of the surface.
   *
   *  This request must be used in response to some sort of user action
   *  like a button press, key press, or touch down event. The passed
   *  serial is used to determine the type of interactive move (touch,
   *  pointer, etc).
   *
   *  The server may ignore move requests depending on the state of
   *  the surface (e.g. fullscreen or maximized), or if the passed serial
   *  is no longer valid.
   *
   *  If triggered, the surface will lose the focus of the device
   *  (wl_pointer, wl_touch, etc) used for the move. It is up to the
   *  compositor to visually indicate that the move is taking place, such as
   *  updating a pointer cursor, during the move. There is no guarantee
   *  that the device focus will return when the move is completed.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {WlSeatResource} wlSeatResource the wl_seat of the user event
   * @param {number} serial the serial of the user event
   *
   * @since 1
   * @override
   */
  move (resource, wlSeatResource, serial) {
    if (this._configureState.state.includes(fullscreen) || this._configureState.state.includes(maximized)) {
      return
    }

    const seat = /** @type {Seat} */wlSeatResource.implementation

    if (!seat.isValidInputSerial(serial)) {
      false && console.log('move serial mismatch. Ignoring.')
      return
    }

    const pointer = seat.pointer
    const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
    const surfaceChildSelf = surface.surfaceChildSelf
    const origPosition = surfaceChildSelf.position

    const pointerX = pointer.x
    const pointerY = pointer.y

    const moveListener = () => {
      if (!this.mapped) {
        pointer.removeMouseMoveListener(moveListener)
        return
      }

      const deltaX = pointer.x - pointerX
      const deltaY = pointer.y - pointerY

      surfaceChildSelf.position = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(origPosition.x + deltaX, origPosition.y + deltaY)

      const renderFrame = _render_Renderer__WEBPACK_IMPORTED_MODULE_5__["default"].createRenderFrame()
      surface.views.forEach((view) => {
        view.applyTransformations(renderFrame)
      })
      renderFrame.fire()
    }

    pointer.onButtonRelease().then(() => {
      surface.hasPointerInput = true
      pointer.removeMouseMoveListener(moveListener)
      pointer.setDefaultCursor()
    })

    surface.hasPointerInput = false
    pointer.unsetFocus()
    pointer.addMouseMoveListener(moveListener)
    window.document.body.style.cursor = 'move'
  }

  /**
   *
   *  Start a user-driven, interactive resize of the surface.
   *
   *  This request must be used in response to some sort of user action
   *  like a button press, key press, or touch down event. The passed
   *  serial is used to determine the type of interactive resize (touch,
   *  pointer, etc).
   *
   *  The server may ignore resize requests depending on the state of
   *  the surface (e.g. fullscreen or maximized).
   *
   *  If triggered, the client will receive configure events with the
   *  "resize" state enum value and the expected sizes. See the "resize"
   *  enum value for more details about what is required. The client
   *  must also acknowledge configure events using "ack_configure". After
   *  the resize is completed, the client will receive another "configure"
   *  event without the resize state.
   *
   *  If triggered, the surface also will lose the focus of the device
   *  (wl_pointer, wl_touch, etc) used for the resize. It is up to the
   *  compositor to visually indicate that the resize is taking place,
   *  such as updating a pointer cursor, during the resize. There is no
   *  guarantee that the device focus will return when the resize is
   *  completed.
   *
   *  The edges parameter specifies how the surface should be resized,
   *  and is one of the values of the resize_edge enum. The compositor
   *  may use this information to update the surface position for
   *  example when dragging the top left corner. The compositor may also
   *  use this information to adapt its behavior, e.g. choose an
   *  appropriate cursor image.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {WlSeatResource} wlSeatResource the wl_seat of the user event
   * @param {Number} serial the serial of the user event
   * @param {Number} edges which edge or corner is being dragged
   *
   * @since 1
   * @override
   */
  resize (resource, wlSeatResource, serial, edges) {
    if (this._configureState.state.includes(fullscreen) || this._configureState.state.includes(maximized)) {
      return
    }

    const seat = /** @type {Seat} */wlSeatResource.implementation
    const pointer = seat.pointer

    if (!seat.isValidInputSerial(serial)) {
      false && console.log('resize serial mismatch. Ignoring.')
      return
    }
    // assigned in switch statement
    let sizeAdjustment = (width, height, deltaX, deltaY) => {}

    switch (edges) {
      case bottomRight: {
        window.document.body.style.cursor = 'nwse-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height + deltaY}
        }
        break
      }
      case top: {
        window.document.body.style.cursor = 'ns-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height - deltaY}
        }
        break
      }
      case bottom: {
        window.document.body.style.cursor = 'ns-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height + deltaY}
        }
        break
      }
      case left: {
        window.document.body.style.cursor = 'ew-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height}
        }
        break
      }
      case topLeft: {
        window.document.body.style.cursor = 'nwse-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height - deltaY}
        }
        break
      }
      case bottomLeft: {
        window.document.body.style.cursor = 'nesw-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width - deltaX, h: height + deltaY}
        }
        break
      }
      case right: {
        window.document.body.style.cursor = 'ew-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height}
        }
        break
      }
      case topRight: {
        window.document.body.style.cursor = 'nesw-resize'
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width + deltaX, h: height - deltaY}
        }
        break
      }
      case none:
      default: {
        pointer.setDefaultCursor()
        sizeAdjustment = (width, height, deltaX, deltaY) => {
          return {w: width, h: height}
        }
        break
      }
    }

    const pointerX = pointer.x
    const pointerY = pointer.y
    const {width: windowGeometryWidth, height: windowGeometryHeight} = this.xdgSurface.windowGeometry

    const sizeCalculation = () => {
      const deltaX = pointer.x - pointerX
      const deltaY = pointer.y - pointerY

      const size = sizeAdjustment(windowGeometryWidth, windowGeometryHeight, deltaX, deltaY)
      const width = Math.max(this._minSize.x, Math.min(size.w, this._maxSize.x))
      const height = Math.max(this._minSize.y, Math.min(size.h, this._maxSize.y))

      return _Size__WEBPACK_IMPORTED_MODULE_4__["default"].create(width, height)
    }

    const resizeListener = () => {
      if (!this.mapped) {
        pointer.removeMouseMoveListener(resizeListener)
        return
      }

      const {w: width, h: height} = sizeCalculation()
      this._emitConfigure(resource, width, height, [activated, resizing], edges)
    }

    const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
    pointer.onButtonRelease().then(() => {
      surface.hasPointerInput = true
      pointer.removeMouseMoveListener(resizeListener)
      pointer.setDefaultCursor()

      const {w: width, h: height} = sizeCalculation()
      this._emitConfigure(resource, width, height, [activated], none)
    })

    surface.hasPointerInput = false
    pointer.unsetFocus()
    pointer.addMouseMoveListener(resizeListener)
  }

  /**
   * @param {XdgToplevelResource} resource
   * @param {number}width
   * @param {number}height
   * @param {Array<number>}states
   * @param {number}resizeEdge
   * @private
   */
  _emitConfigure (resource, width, height, states, resizeEdge) {
    resource.configure(width, height, Uint32Array.from(states))
    this.xdgSurface.emitConfigureDone()
    this._pendingConfigureStates.push({
      serial: this.xdgSurface.configureSerial,
      state: states,
      width: width,
      height: height,
      resizeEdge: resizeEdge
    })
  }

  /**
   *
   *  Set a maximum size for the window.
   *
   *  The client can specify a maximum size so that the compositor does
   *  not try to configure the window beyond this size.
   *
   *  The width and height arguments are in window geometry coordinates.
   *  See xdg_surface.set_window_geometry.
   *
   *  Values set in this way are double-buffered. They will get applied
   *  on the next commit.
   *
   *  The compositor can use this information to allow or disallow
   *  different states like maximize or fullscreen and draw accurate
   *  animations.
   *
   *  Similarly, a tiling window manager may use this information to
   *  place and resize client windows in a more effective way.
   *
   *  The client should not rely on the compositor to obey the maximum
   *  size. The compositor may decide to ignore the values set by the
   *  client and request a larger size.
   *
   *  If never set, or a value of zero in the request, means that the
   *  client has no expected maximum size in the given dimension.
   *  As a result, a client wishing to reset the maximum size
   *  to an unspecified state can use zero for width and height in the
   *  request.
   *
   *  Requesting a maximum size to be smaller than the minimum size of
   *  a surface is illegal and will result in a protocol error.
   *
   *  The width and height must be greater than or equal to zero. Using
   *  strictly negative values for width and height will result in a
   *  protocol error.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {number} width undefined
   * @param {number} height undefined
   *
   * @since 1
   * @override
   */
  setMaxSize (resource, width, height) {
    width = width === 0 ? Number.MAX_SAFE_INTEGER : width
    height = height === 0 ? Number.MAX_SAFE_INTEGER : height
    if (width < 0 || height < 0 || width < this._minSize.x || height < this._minSize.y) {
      resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidSurfaceState, 'Max size can not be me smaller than min size.')
      false && console.log('Protocol error. Max size can not be me smaller than min size.')
      return
    }
    this._pendingMaxSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(
      width,
      height
    )
  }

  /**
   *
   *  Set a minimum size for the window.
   *
   *  The client can specify a minimum size so that the compositor does
   *  not try to configure the window below this size.
   *
   *  The width and height arguments are in window geometry coordinates.
   *  See xdg_surface.set_window_geometry.
   *
   *  Values set in this way are double-buffered. They will get applied
   *  on the next commit.
   *
   *  The compositor can use this information to allow or disallow
   *  different states like maximize or fullscreen and draw accurate
   *  animations.
   *
   *  Similarly, a tiling window manager may use this information to
   *  place and resize client windows in a more effective way.
   *
   *  The client should not rely on the compositor to obey the minimum
   *  size. The compositor may decide to ignore the values set by the
   *  client and request a smaller size.
   *
   *  If never set, or a value of zero in the request, means that the
   *  client has no expected minimum size in the given dimension.
   *  As a result, a client wishing to reset the minimum size
   *  to an unspecified state can use zero for width and height in the
   *  request.
   *
   *  Requesting a minimum size to be larger than the maximum size of
   *  a surface is illegal and will result in a protocol error.
   *
   *  The width and height must be greater than or equal to zero. Using
   *  strictly negative values for width and height will result in a
   *  protocol error.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {number} width
   * @param {number} height
   *
   * @since 1
   * @override
   */
  setMinSize (resource, width, height) {
    if (width < 0 || height < 0 || width > this._maxSize.x || height > this._maxSize.y) {
      this.resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidSurfaceState, 'Min size can not be greater than max size.')
      false && console.log('Protocol error. Min size can not be greater than max size.')
      return
    }
    this._pendingMinSize = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(width, height)
  }

  /**
   *
   *  Maximize the surface.
   *
   *  After requesting that the surface should be maximized, the compositor
   *  will respond by emitting a configure event with the "maximized" state
   *  and the required window geometry. The client should then update its
   *  content, drawing it in a maximized state, i.e. without shadow or other
   *  decoration outside of the window geometry. The client must also
   *  acknowledge the configure when committing the new content (see
   *  ack_configure).
   *
   *  It is up to the compositor to decide how and where to maximize the
   *  surface, for example which output and what region of the screen should
   *  be used.
   *
   *  If the surface was already maximized, the compositor will still emit
   *  a configure event with the "maximized" state.
   *
   *  If the surface is in a fullscreen state, this request has no direct
   *  effect. It will alter the state the surface is returned to when
   *  unmaximized if not overridden by the compositor.
   *
   *
   * @param {XdgToplevelResource} resource
   *
   * @since 1
   * @override
   */
  setMaximized (resource) {
    if (this._configureState.state.includes(resizing)) {
      return
    }

    const {width: workspaceWidth, height: workspaceHeight} = document.getElementById('workspace').getBoundingClientRect()
    const maxWidth = Math.round(workspaceWidth)
    const maxHeight = Math.round(workspaceHeight)

    if (this._configureState.state.includes(fullscreen)) {
      this._unfullscreenConfigureState = {
        state: [maximized, activated],
        width: maxWidth,
        height: maxHeight
      }
    } else {
      this._emitConfigure(resource, maxWidth, maxHeight, [maximized, activated], none)
    }
  }

  /**
   *
   *  Unmaximize the surface.
   *
   *  After requesting that the surface should be unmaximized, the compositor
   *  will respond by emitting a configure event without the "maximized"
   *  state. If available, the compositor will include the window geometry
   *  dimensions the window had prior to being maximized in the configure
   *  event. The client must then update its content, drawing it in a
   *  regular state, i.e. potentially with shadow, etc. The client must also
   *  acknowledge the configure when committing the new content (see
   *  ack_configure).
   *
   *  It is up to the compositor to position the surface after it was
   *  unmaximized; usually the position the surface had before maximizing, if
   *  applicable.
   *
   *  If the surface was already not maximized, the compositor will still
   *  emit a configure event without the "maximized" state.
   *
   *  If the surface is in a fullscreen state, this request has no direct
   *  effect. It will alter the state the surface is returned to when
   *  unmaximized if not overridden by the compositor.
   *
   *
   * @param {XdgToplevelResource} resource
   *
   * @since 1
   * @override
   */
  unsetMaximized (resource) {
    if (this._configureState.state.includes(resizing)) {
      return
    }

    if (this._configureState.state.includes(fullscreen) && this._previousGeometry) {
      this._unfullscreenConfigureState = {
        state: [activated],
        width: this._previousGeometry.width,
        height: this._previousGeometry.height
      }
    } else if (this._configureState.state.includes(maximized) && this._previousGeometry) {
      this._emitConfigure(resource, this._previousGeometry.width, this._previousGeometry.height, [activated], none)
    } else {
      this._emitConfigure(resource, 0, 0, [activated], none)
    }
  }

  /**
   *
   *  Make the surface fullscreen.
   *
   *  After requesting that the surface should be fullscreened, the
   *  compositor will respond by emitting a configure event with the
   *  "fullscreen" state and the fullscreen window geometry. The client must
   *  also acknowledge the configure when committing the new content (see
   *  ack_configure).
   *
   *  The output passed by the request indicates the client's preference as
   *  to which display it should be set fullscreen on. If this value is NULL,
   *  it's up to the compositor to choose which display will be used to map
   *  this surface.
   *
   *  If the surface doesn't cover the whole output, the compositor will
   *  position the surface in the center of the output and compensate with
   *  with border fill covering the rest of the output. The content of the
   *  border fill is undefined, but should be assumed to be in some way that
   *  attempts to blend into the surrounding area (e.g. solid black).
   *
   *  If the fullscreened surface is not opaque, the compositor must make
   *  sure that other screen content not part of the same surface tree (made
   *  up of subsurfaces, popups or similarly coupled surfaces) are not
   *  visible below the fullscreened surface.
   *
   *
   * @param {XdgToplevelResource} resource
   * @param {?WlOutput} output undefined
   *
   * @since 1
   * @override
   */
  setFullscreen (resource, output) {
    this._emitConfigure(resource, window.innerWidth, window.innerHeight, [fullscreen, activated], none)
  }

  /**
   *
   *  Make the surface no longer fullscreen.
   *
   *  After requesting that the surface should be unfullscreened, the
   *  compositor will respond by emitting a configure event without the
   *  "fullscreen" state.
   *
   *  Making a surface unfullscreen sets states for the surface based on the following:
   *  * the state(s) it may have had before becoming fullscreen
   *  * any state(s) decided by the compositor
   *  * any state(s) requested by the client while the surface was fullscreen
   *
   *  The compositor may include the previous window geometry dimensions in
   *  the configure event, if applicable.
   *
   *  The client must also acknowledge the configure when committing the new
   *  content (see ack_configure).
   *
   *
   * @param {XdgToplevelResource} resource
   *
   * @since 1
   * @override
   */
  unsetFullscreen (resource) {
    if (this._configureState.state.includes(fullscreen)) {
      if (this._unfullscreenConfigureState) {
        this._emitConfigure(resource, this._unfullscreenConfigureState.width, this._unfullscreenConfigureState.height, this._unfullscreenConfigureState.state, none)
      } else if (this._previousGeometry) {
        this._emitConfigure(resource, this._previousGeometry.width, this._previousGeometry.height, [activated], none)
      } else {
        this._emitConfigure(resource, 0, 0, [activated], none)
      }
    }
  }

  /**
   *
   *  Request that the compositor minimize your surface. There is no
   *  way to know if the surface is currently minimized, nor is there
   *  any way to unset minimization on this surface.
   *
   *  If you are looking to throttle redrawing when minimized, please
   *  instead use the wl_surface.frame event for this, as this will
   *  also work with live previews on windows in Alt-Tab, Expose or
   *  similar compositor features.
   *
   *
   * @param {XdgToplevelResource} resource
   *
   * @since 1
   * @override
   */
  setMinimized (resource) {
    this._userShellSurface.minimize()
  }
}


/***/ }),
/* 120 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgToplevelRequests {

	/**
	 *
	 *	This request destroys the role surface and unmaps the surface;
	 *	see "Unmapping" behavior in interface section for details.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Set the "parent" of this surface. This surface should be stacked
	 *	above the parent surface and all other ancestor surfaces.
	 *
	 *	Parent windows should be set on dialogs, toolboxes, or other
	 *	"auxiliary" surfaces, so that the parent is raised when the dialog
	 *	is raised.
	 *
	 *	Setting a null parent for a child window removes any parent-child
	 *	relationship for the child. Setting a null parent for a window which
	 *	currently has no parent is a no-op.
	 *
	 *	If the parent is unmapped then its children are managed as
	 *	though the parent of the now-unmapped parent has become the
	 *	parent of this surface. If no parent exists for the now-unmapped
	 *	parent then the children are managed as though they have no
	 *	parent surface.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {?*} parent  
	 *
	 * @since 1
	 *
	 */
	setParent(resource, parent) {}

	/**
	 *
	 *	Set a short title for the surface.
	 *
	 *	This string may be used to identify the surface in a task bar,
	 *	window list, or other user interface elements provided by the
	 *	compositor.
	 *
	 *	The string must be encoded in UTF-8.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {string} title  
	 *
	 * @since 1
	 *
	 */
	setTitle(resource, title) {}

	/**
	 *
	 *	Set an application identifier for the surface.
	 *
	 *	The app ID identifies the general class of applications to which
	 *	the surface belongs. The compositor can use this to group multiple
	 *	surfaces together, or to determine how to launch a new application.
	 *
	 *	For D-Bus activatable applications, the app ID is used as the D-Bus
	 *	service name.
	 *
	 *	The compositor shell will try to group application surfaces together
	 *	by their app ID. As a best practice, it is suggested to select app
	 *	ID's that match the basename of the application's .desktop file.
	 *	For example, "org.freedesktop.FooViewer" where the .desktop file is
	 *	"org.freedesktop.FooViewer.desktop".
	 *
	 *	See the desktop-entry specification [0] for more details on
	 *	application identifiers and how they relate to well-known D-Bus
	 *	names and .desktop files.
	 *
	 *	[0] http://standards.freedesktop.org/desktop-entry-spec/
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {string} appId  
	 *
	 * @since 1
	 *
	 */
	setAppId(resource, appId) {}

	/**
	 *
	 *	Clients implementing client-side decorations might want to show
	 *	a context menu when right-clicking on the decorations, giving the
	 *	user a menu that they can use to maximize or minimize the window.
	 *
	 *	This request asks the compositor to pop up such a window menu at
	 *	the given position, relative to the local surface coordinates of
	 *	the parent surface. There are no guarantees as to what menu items
	 *	the window menu contains.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 * @param {number} x the x position to pop up the window menu at 
	 * @param {number} y the y position to pop up the window menu at 
	 *
	 * @since 1
	 *
	 */
	showWindowMenu(resource, seat, serial, x, y) {}

	/**
	 *
	 *	Start an interactive, user-driven move of the surface.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event. The passed
	 *	serial is used to determine the type of interactive move (touch,
	 *	pointer, etc).
	 *
	 *	The server may ignore move requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized), or if the passed serial
	 *	is no longer valid.
	 *
	 *	If triggered, the surface will lose the focus of the device
	 *	(wl_pointer, wl_touch, etc) used for the move. It is up to the
	 *	compositor to visually indicate that the move is taking place, such as
	 *	updating a pointer cursor, during the move. There is no guarantee
	 *	that the device focus will return when the move is completed.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 *
	 * @since 1
	 *
	 */
	move(resource, seat, serial) {}

	/**
	 *
	 *	Start a user-driven, interactive resize of the surface.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event. The passed
	 *	serial is used to determine the type of interactive resize (touch,
	 *	pointer, etc).
	 *
	 *	The server may ignore resize requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *
	 *	If triggered, the client will receive configure events with the
	 *	"resize" state enum value and the expected sizes. See the "resize"
	 *	enum value for more details about what is required. The client
	 *	must also acknowledge configure events using "ack_configure". After
	 *	the resize is completed, the client will receive another "configure"
	 *	event without the resize state.
	 *
	 *	If triggered, the surface also will lose the focus of the device
	 *	(wl_pointer, wl_touch, etc) used for the resize. It is up to the
	 *	compositor to visually indicate that the resize is taking place,
	 *	such as updating a pointer cursor, during the resize. There is no
	 *	guarantee that the device focus will return when the resize is
	 *	completed.
	 *
	 *	The edges parameter specifies how the surface should be resized,
	 *	and is one of the values of the resize_edge enum. The compositor
	 *	may use this information to update the surface position for
	 *	example when dragging the top left corner. The compositor may also
	 *	use this information to adapt its behavior, e.g. choose an
	 *	appropriate cursor image.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 * @param {number} edges which edge or corner is being dragged 
	 *
	 * @since 1
	 *
	 */
	resize(resource, seat, serial, edges) {}

	/**
	 *
	 *	Set a maximum size for the window.
	 *
	 *	The client can specify a maximum size so that the compositor does
	 *	not try to configure the window beyond this size.
	 *
	 *	The width and height arguments are in window geometry coordinates.
	 *	See xdg_surface.set_window_geometry.
	 *
	 *	Values set in this way are double-buffered. They will get applied
	 *	on the next commit.
	 *
	 *	The compositor can use this information to allow or disallow
	 *	different states like maximize or fullscreen and draw accurate
	 *	animations.
	 *
	 *	Similarly, a tiling window manager may use this information to
	 *	place and resize client windows in a more effective way.
	 *
	 *	The client should not rely on the compositor to obey the maximum
	 *	size. The compositor may decide to ignore the values set by the
	 *	client and request a larger size.
	 *
	 *	If never set, or a value of zero in the request, means that the
	 *	client has no expected maximum size in the given dimension.
	 *	As a result, a client wishing to reset the maximum size
	 *	to an unspecified state can use zero for width and height in the
	 *	request.
	 *
	 *	Requesting a maximum size to be smaller than the minimum size of
	 *	a surface is illegal and will result in a protocol error.
	 *
	 *	The width and height must be greater than or equal to zero. Using
	 *	strictly negative values for width and height will result in a
	 *	protocol error.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setMaxSize(resource, width, height) {}

	/**
	 *
	 *	Set a minimum size for the window.
	 *
	 *	The client can specify a minimum size so that the compositor does
	 *	not try to configure the window below this size.
	 *
	 *	The width and height arguments are in window geometry coordinates.
	 *	See xdg_surface.set_window_geometry.
	 *
	 *	Values set in this way are double-buffered. They will get applied
	 *	on the next commit.
	 *
	 *	The compositor can use this information to allow or disallow
	 *	different states like maximize or fullscreen and draw accurate
	 *	animations.
	 *
	 *	Similarly, a tiling window manager may use this information to
	 *	place and resize client windows in a more effective way.
	 *
	 *	The client should not rely on the compositor to obey the minimum
	 *	size. The compositor may decide to ignore the values set by the
	 *	client and request a smaller size.
	 *
	 *	If never set, or a value of zero in the request, means that the
	 *	client has no expected minimum size in the given dimension.
	 *	As a result, a client wishing to reset the minimum size
	 *	to an unspecified state can use zero for width and height in the
	 *	request.
	 *
	 *	Requesting a minimum size to be larger than the maximum size of
	 *	a surface is illegal and will result in a protocol error.
	 *
	 *	The width and height must be greater than or equal to zero. Using
	 *	strictly negative values for width and height will result in a
	 *	protocol error.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setMinSize(resource, width, height) {}

	/**
	 *
	 *	Maximize the surface.
	 *
	 *	After requesting that the surface should be maximized, the compositor
	 *	will respond by emitting a configure event with the "maximized" state
	 *	and the required window geometry. The client should then update its
	 *	content, drawing it in a maximized state, i.e. without shadow or other
	 *	decoration outside of the window geometry. The client must also
	 *	acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	It is up to the compositor to decide how and where to maximize the
	 *	surface, for example which output and what region of the screen should
	 *	be used.
	 *
	 *	If the surface was already maximized, the compositor will still emit
	 *	a configure event with the "maximized" state.
	 *
	 *	If the surface is in a fullscreen state, this request has no direct
	 *	effect. It will alter the state the surface is returned to when
	 *	unmaximized if not overridden by the compositor.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 *
	 * @since 1
	 *
	 */
	setMaximized(resource) {}

	/**
	 *
	 *	Unmaximize the surface.
	 *
	 *	After requesting that the surface should be unmaximized, the compositor
	 *	will respond by emitting a configure event without the "maximized"
	 *	state. If available, the compositor will include the window geometry
	 *	dimensions the window had prior to being maximized in the configure
	 *	event. The client must then update its content, drawing it in a
	 *	regular state, i.e. potentially with shadow, etc. The client must also
	 *	acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	It is up to the compositor to position the surface after it was
	 *	unmaximized; usually the position the surface had before maximizing, if
	 *	applicable.
	 *
	 *	If the surface was already not maximized, the compositor will still
	 *	emit a configure event without the "maximized" state.
	 *
	 *	If the surface is in a fullscreen state, this request has no direct
	 *	effect. It will alter the state the surface is returned to when
	 *	unmaximized if not overridden by the compositor.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 *
	 * @since 1
	 *
	 */
	unsetMaximized(resource) {}

	/**
	 *
	 *	Make the surface fullscreen.
	 *
	 *	After requesting that the surface should be fullscreened, the
	 *	compositor will respond by emitting a configure event with the
	 *	"fullscreen" state and the fullscreen window geometry. The client must
	 *	also acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	The output passed by the request indicates the client's preference as
	 *	to which display it should be set fullscreen on. If this value is NULL,
	 *	it's up to the compositor to choose which display will be used to map
	 *	this surface.
	 *
	 *	If the surface doesn't cover the whole output, the compositor will
	 *	position the surface in the center of the output and compensate with
	 *	with border fill covering the rest of the output. The content of the
	 *	border fill is undefined, but should be assumed to be in some way that
	 *	attempts to blend into the surrounding area (e.g. solid black).
	 *
	 *	If the fullscreened surface is not opaque, the compositor must make
	 *	sure that other screen content not part of the same surface tree (made
	 *	up of subsurfaces, popups or similarly coupled surfaces) are not
	 *	visible below the fullscreened surface.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 * @param {?*} output  
	 *
	 * @since 1
	 *
	 */
	setFullscreen(resource, output) {}

	/**
	 *
	 *	Make the surface no longer fullscreen.
	 *
	 *	After requesting that the surface should be unfullscreened, the
	 *	compositor will respond by emitting a configure event without the
	 *	"fullscreen" state.
	 *
	 *	Making a surface unfullscreen sets states for the surface based on the following:
	 *	* the state(s) it may have had before becoming fullscreen
	 *	* any state(s) decided by the compositor
	 *	* any state(s) requested by the client while the surface was fullscreen
	 *
	 *	The compositor may include the previous window geometry dimensions in
	 *	the configure event, if applicable.
	 *
	 *	The client must also acknowledge the configure when committing the new
	 *	content (see ack_configure).
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 *
	 * @since 1
	 *
	 */
	unsetFullscreen(resource) {}

	/**
	 *
	 *	Request that the compositor minimize your surface. There is no
	 *	way to know if the surface is currently minimized, nor is there
	 *	any way to unset minimization on this surface.
	 *
	 *	If you are looking to throttle redrawing when minimized, please
	 *	instead use the wl_surface.frame event for this, as this will
	 *	also work with live previews on windows in Alt-Tab, Expose or
	 *	similar compositor features.
	 *      
	 *
	 * @param {XdgToplevelResource} resource 
	 *
	 * @since 1
	 *
	 */
	setMinimized(resource) {}
}

module.exports = XdgToplevelRequests


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgPopup; });
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_XdgPopupRequests__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(122);
/* harmony import */ var _protocol_XdgPopupRequests__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPopupRequests__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);
/* harmony import */ var _protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);









const {none, slideX, slideY, flipX, flipY, resizeX, resizeY} = _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_0___default.a.ConstraintAdjustment

const inverseY = {
  /**
   * none
   * @return {number}
   */
  0: 0,
  /**
   * top
   * @return {number}
   */
  1: 2,
  /**
   * bottom
   * @return {number}
   */
  2: 1,
  /**
   * left
   * @return {number}
   */
  3: 3,
  /**
   * right
   * @return {number}
   */
  4: 4,
  /**
   * topLeft
   * @return {number}
   */
  5: 6,
  /**
   * bottomLeft
   * @return {number}
   */
  6: 5,
  /**
   * topRight
   * @return {number}
   */
  7: 8,
  /**
   * bottomRight
   * @return {number}
   */
  8: 7
}

const inverseX = {
  /**
   * none
   * @return {number}
   */
  0: 0,
  /**
   * top
   * @return {number}
   */
  1: 1,
  /**
   * bottom
   * @return {number}
   */
  2: 2,
  /**
   * left
   * @return {number}
   */
  3: 4,
  /**
   * right
   * @return {number}
   */
  4: 3,
  /**
   * topLeft
   * @return {number}
   */
  5: 7,
  /**
   * bottomLeft
   * @return {number}
   */
  6: 8,
  /**
   * topRight
   * @return {number}
   */
  7: 5,
  /**
   * bottomRight
   * @return {number}
   */
  8: 6
}

/**
 *
 *      A popup surface is a short-lived, temporary surface. It can be used to
 *      implement for example menus, popovers, tooltips and other similar user
 *      interface concepts.
 *
 *      A popup can be made to take an explicit grab. See xdg_popup.grab for
 *      details.
 *
 *      When the popup is dismissed, a popup_done event will be sent out, and at
 *      the same time the surface will be unmapped. See the xdg_popup.popup_done
 *      event for details.
 *
 *      Explicitly destroying the xdg_popup object will also dismiss the popup and
 *      unmap the surface. Clients that want to dismiss the popup when another
 *      surface of their own is clicked should dismiss the popup using the destroy
 *      request.
 *
 *      The parent surface must have either the xdg_toplevel or xdg_popup surface
 *      role.
 *
 *      A newly created xdg_popup will be stacked on top of all previously created
 *      xdg_popup surfaces associated with the same xdg_toplevel.
 *
 *      The parent of an xdg_popup must be mapped (see the xdg_surface
 *      description) before the xdg_popup itself.
 *
 *      The x and y arguments passed when creating the popup object specify
 *      where the top left of the popup should be placed, relative to the
 *      local surface coordinates of the parent surface. See
 *      xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 *      partially adjacent to its parent surface.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_popup state to take effect.
 *
 * @implements {SurfaceRole}
 * @implements {XdgPopupRequests}
 */
class XdgPopup extends _protocol_XdgPopupRequests__WEBPACK_IMPORTED_MODULE_1___default.a {
  /**
   * @param {XdgPopupResource}xdgPopupResource
   * @param {XdgSurface}xdgSurface
   * @param {XdgSurfaceResource|null}parent
   * @param {{size: Rect, anchorRect: Rect, anchor: number, gravity: number, constraintAdjustment: number, offset: Point, surfaceSpaceAnchorPoint: (function(XdgSurface): Point), checkScreenConstraints: (function(XdgSurface, View): {topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number})}}positionerState
   * @param {Session}session
   * @param {Seat}seat
   * @return {XdgPopup}
   */
  static create (xdgPopupResource, xdgSurface, parent, positionerState, session, seat) {
    const xdgPopup = new XdgPopup(xdgPopupResource, xdgSurface, parent, positionerState, session, seat)
    xdgPopupResource.implementation = xdgPopup
    const surface = /** @type {Surface} */xdgSurface.wlSurfaceResource.implementation
    surface.role = xdgPopup
    xdgPopup.ensureGeometryConstraints(parent, positionerState)
    xdgSurface.emitConfigureDone()
    return xdgPopup
  }

  /**
   * @param {XdgPopupResource}xdgPopupResource
   * @param {XdgSurface}xdgSurface
   * @param {XdgSurfaceResource|null}parent
   * @param {{size: Rect, anchorRect: Rect, anchor: number, gravity: number, constraintAdjustment: number, offset: Point, surfaceSpaceAnchorPoint: (function(XdgSurface): Point), checkScreenConstraints: (function(XdgSurface, View): {topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number})}}positionerState
   * @param {Session}session
   * @param {Seat}seat
   */
  constructor (xdgPopupResource, xdgSurface, parent, positionerState, session, seat) {
    super()
    /**
     * @type {XdgPopupResource}
     */
    this.resource = xdgPopupResource
    /**
     * @type {XdgSurface}
     */
    this.xdgSurface = xdgSurface
    /**
     * @type {XdgSurfaceResource|null}
     */
    this.parent = parent
    /**
     * @type {{size: Rect, anchorRect: Rect, anchor: number, gravity: number, constraintAdjustment: number, offset: Point, surfaceSpaceAnchorPoint: (function(XdgSurface): Point), checkScreenConstraints: (function(XdgSurface, View): {topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number})}}
     */
    this.positionerState = positionerState
    /**
     * @type {boolean}
     */
    this.mapped = false
    /**
     * @type {boolean}
     */
    this.dismissed = false
    /**
     * @type {Session}
     * @private
     */
    this._session = session
    /**
     * @type {Seat}
     * @private
     */
    this._seat = seat
  }

  /**
   * @return {{windowGeometry: Rect}}
   * @override
   */
  captureRoleState () {
    return {
      windowGeometry: this.xdgSurface.pendingWindowGeometry
    }
  }

  /**
   * @param {{windowGeometry: Rect}}roleState
   * @override
   */
  setRoleState (roleState) {
    this.xdgSurface.updateWindowGeometry(roleState.windowGeometry)
  }

  /**
   * @param {Surface}surface
   * @param {RenderFrame}renderFrame
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @return {Promise<void>}
   * @override
   */
  async onCommit (surface, renderFrame, newState) {
    if (this.dismissed) {
      return
    }

    if (newState.bufferContents) {
      if (!this.mapped) {
        this._map(surface, newState)
      }
    } else if (this.mapped) {
      this._dismiss()
    }

    await surface.render(renderFrame, newState)
    renderFrame.fire()
    await renderFrame
    this._session.flush()
  }

  /**
   * @param {Surface}surface
   * @param {{bufferContents: EncodedFrame|null, bufferDamageRects: Array<Rect>, opaquePixmanRegion: number, inputPixmanRegion: number, dx: number, dy: number, bufferTransform: number, bufferScale: number, frameCallbacks: Array<Callback>, roleState: *}}newState
   * @private
   */
  _map (surface, newState) {
    // TODO check if parent is mapped
    for (const surfaceChild of surface.children) {
      if (surfaceChild !== surface.surfaceChildSelf &&
        surfaceChild.surface.role instanceof XdgPopup) {
        this.resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3___default.a.Error.notTheTopmostPopup, 'Client tried to map a non-topmost popup')
        false && console.log('Protocol error. Client tried to map a non-topmost popup')
        return
      }
    }

    this.mapped = true
    const parentXdgSurface = /** @type {XdgSurface} */this.parent.implementation
    const parentSurface = /** @type {Surface} */parentXdgSurface.wlSurfaceResource.implementation

    // set position based on positioner object
    surface.surfaceChildSelf.position = this.positionerState.surfaceSpaceAnchorPoint(parentXdgSurface).minus(newState.roleState.windowGeometry.position)
    parentSurface.addChild(surface.surfaceChildSelf)
  }

  /**
   * @private
   */
  _dismiss () {
    if (!this.dismissed) {
      this.dismissed = true
      if (this._seat.pointer) {
        const popupGrab = this._seat.pointer.findPopupGrab(this.xdgSurface.wlSurfaceResource)
        if (popupGrab) {
          popupGrab.resolve()
        }
      }
      this.resource.popupDone()
      const parentXdgSurface = /** @type {XdgSurface} */this.parent.implementation
      const parentSurface = /** @type {Surface} */parentXdgSurface.wlSurfaceResource.implementation
      const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
      parentSurface.removeChild(surface.surfaceChildSelf)
      this._seat.keyboard.focusGained(parentSurface)
    }
  }

  /**
   * @private
   */
  _updatePopupKeyboardFocus () {
    this._seat.keyboard.focusGained(/** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation)
    // if the keyboard or focus changes to a different client, we have to dismiss the popup
    this._seat.keyboard.onKeyboardFocusChanged().then(() => {
      if (!this._seat.keyboard.focus || this._seat.keyboard.focus.resource.client !== this.resource.client) {
        this._dismiss()
      }
    })
  }

  /**
   *
   *  This destroys the popup. Explicitly destroying the xdg_popup
   *  object will also dismiss the popup, and unmap the surface.
   *
   *  If this xdg_popup is not the "topmost" popup, a protocol error
   *  will be sent.
   *
   *
   * @param {XdgPopupResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    const surface = /** @type {Surface} */this.xdgSurface.wlSurfaceResource.implementation
    for (const surfaceChild of surface.children) {
      if (surfaceChild !== surface.surfaceChildSelf &&
        surfaceChild.surface.role instanceof XdgPopup) {
        resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3___default.a.Error.notTheTopmostPopup, 'Client tried to destroy a non-topmost popup')
        false && console.log('Protocol error. Client tried to destroy a non-topmost popup')
        return
      }
    }

    this._dismiss()
    resource.destroy()
  }

  /**
   *
   *  This request makes the created popup take an explicit grab. An explicit
   *  grab will be dismissed when the user dismisses the popup, or when the
   *  client destroys the xdg_popup. This can be done by the user clicking
   *  outside the surface, using the keyboard, or even locking the screen
   *  through closing the lid or a timeout.
   *
   *  If the compositor denies the grab, the popup will be immediately
   *  dismissed.
   *
   *  This request must be used in response to some sort of user action like a
   *  button press, key press, or touch down event. The serial number of the
   *  event should be passed as 'serial'.
   *
   *  The parent of a grabbing popup must either be an xdg_toplevel surface or
   *  another xdg_popup with an explicit grab. If the parent is another
   *  xdg_popup it means that the popups are nested, with this popup now being
   *  the topmost popup.
   *
   *  Nested popups must be destroyed in the reverse order they were created
   *  in, e.g. the only popup you are allowed to destroy at all times is the
   *  topmost one.
   *
   *  When compositors choose to dismiss a popup, they may dismiss every
   *  nested grabbing popup as well. When a compositor dismisses popups, it
   *  will follow the same dismissing order as required from the client.
   *
   *  The parent of a grabbing popup must either be another xdg_popup with an
   *  active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
   *  explicit grabs already taken.
   *
   *  If the topmost grabbing popup is destroyed, the grab will be returned to
   *  the parent of the popup, if that parent previously had an explicit grab.
   *
   *  If the parent is a grabbing popup which has already been dismissed, this
   *  popup will be immediately dismissed. If the parent is a popup that did
   *  not take an explicit grab, an error will be raised.
   *
   *  During a popup grab, the client owning the grab will receive pointer
   *  and touch events for all their surfaces as normal (similar to an
   *  "owner-events" grab in X11 parlance), while the top most grabbing popup
   *  will always have keyboard focus.
   *
   *
   * @param {XdgPopupResource} resource
   * @param {WlSeatResource} wlSeatResource the wl_seat of the user event
   * @param {number} serial the serial of the user event
   *
   * @since 1
   * @override
   */
  async grab (resource, wlSeatResource, serial) {
    const seat = /** @type {Seat} */ wlSeatResource.implementation
    const pointer = seat.pointer

    // FIXME we can receive an older serial in case a popup is triggered from an older mouse down + mouse move
    if (serial !== seat.buttonPressSerial) {
      this._dismiss()
      false && console.log('Popup grab input serial mismatch. Ignoring.')
      return
    }

    if (this.mapped) {
      resource.postError(_protocol_XdgPopupResource__WEBPACK_IMPORTED_MODULE_2___default.a.Error.invalidGrab, 'Client tried to grab popup after it being mapped.')
      false && console.log('Protocol error. Client tried to grab popup after it being mapped.')
      return
    }

    const parentXdgSurface = /** @type {XdgSurface} */this.parent.implementation
    const parentWlSurfaceResource = parentXdgSurface.wlSurfaceResource
    const parentSurface = /** type {Surface} */parentWlSurfaceResource.implementation
    const parentRole = parentSurface.role
    if (parentRole instanceof XdgPopup) {
      const parentXdgPopupRole = /** @type {XdgPopup} */parentRole
      if (parentXdgPopupRole.dismissed) {
        this._dismiss()
        return
      } else if (!pointer.findPopupGrab(parentWlSurfaceResource)) {
        resource.postError(_protocol_XdgWmBaseResource__WEBPACK_IMPORTED_MODULE_3___default.a.Error.invalidPopupParent, 'Popup parent is a popup that did not take an explicit grab.')
        false && console.log('Protocol error. Popup parent is a popup that did not take an explicit grab.')
        return
      }
    }

    this._updatePopupKeyboardFocus()
    await pointer.popupGrab(this.xdgSurface.wlSurfaceResource)
    this._dismiss()
  }

  /**
   * @param {number}serial
   */
  ackConfigure (serial) {
    // TODO what to do here?
  }

  /**
   * @param {XdgSurfaceResource|null}parent
   * @param {{size: Rect, anchorRect: Rect, anchor: number, gravity: number, constraintAdjustment: number, offset: Point, surfaceSpaceAnchorPoint: (function(XdgSurface): Point), checkScreenConstraints: (function(XdgSurface, View): {topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number})}}positionerState
   */
  ensureGeometryConstraints (parent, positionerState) {
    // TODO we can probably rewrite & make this method better using libpixman
    if (positionerState.constraintAdjustment === none) {
      // we can't even
      return
    }

    const parentXdgSurface = /** @type {XdgSurface} */parent.implementation
    const parentSurface = /** @type {Surface} */parentXdgSurface.wlSurfaceResource.implementation
    const primaryParentView = parentSurface.views.find(parentView => parentView.primary)

    let violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)

    if (!(violations.topViolation || violations.rightViolation || violations.bottomViolation || violations.leftViolation)) {
      // all fine, no need to reconfigure
      return
    }

    const canFlipX = (positionerState.constraintAdjustment | flipX) !== 0
    const canFlipY = (positionerState.constraintAdjustment | flipY) !== 0
    const canSlideX = (positionerState.constraintAdjustment | slideX) !== 0
    const canSlideY = (positionerState.constraintAdjustment | slideY) !== 0
    const canResizeX = (positionerState.constraintAdjustment | resizeX) !== 0
    const canResizeY = (positionerState.constraintAdjustment | resizeY) !== 0

    // X-Axis:
    // we can't use slide or flip if if the height is greater than the screen height
    if ((violations.leftViolation || violations.rightViolation) &&
      positionerState.size.width < window.document.body.clientWidth) {
      if (canFlipX) {
        // TODO try flipping
        const oldAnchor = positionerState.anchor
        const oldGravity = positionerState.gravity

        positionerState.anchor = inverseX[oldAnchor]
        positionerState.gravity = inverseX[oldGravity]

        violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
        if (violations.leftViolation || violations.rightViolation) {
          // still violating, revert
          positionerState.anchor = oldAnchor
          positionerState.gravity = oldGravity
        }
      }

      // check for violations in case the flip caused the violations to disappear
      violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
      if ((violations.leftViolation || violations.rightViolation) && canSlideX) {
        // try sliding
        const newXDeltaOffset = violations.rightViolation ? -violations.rightViolation : violations.leftViolation
        const oldOffset = positionerState.offset
        positionerState.offset = _math_Point__WEBPACK_IMPORTED_MODULE_4__["default"].create(oldOffset.x + newXDeltaOffset, oldOffset.y)
        // no need to check if there is still a X violation as we already ensured the width < max width
      }
    }

    // check for violations in case the flip or slide caused the violations to disappear
    violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
    if ((violations.leftViolation || violations.rightViolation) && canResizeX) {
      if (violations.leftViolation) {
        const oldOffset = positionerState.offset
        positionerState.offset = _math_Point__WEBPACK_IMPORTED_MODULE_4__["default"].create(oldOffset.x + violations.leftViolation, oldOffset.y)
        positionerState.size.x1 = positionerState.size.x1 - violations.leftViolation
      }

      if (violations.rightViolation) {
        positionerState.size.x1 = positionerState.size.x1 - violations.rightViolation
      }
    }

    // Y-Axis:
    // we can't use slide or flip if if the height is greater than the screen height
    violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
    if ((violations.topViolation || violations.bottomViolation) &&
      positionerState.size.height < window.document.body.clientHeight) {
      if (canFlipY) {
        const oldAnchor = positionerState.anchor
        const oldGravity = positionerState.gravity

        positionerState.anchor = inverseY[oldAnchor]
        positionerState.gravity = inverseY[oldGravity]

        violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
        if (violations.topViolation || violations.bottomViolation) {
          // still violating, revert
          positionerState.anchor = oldAnchor
          positionerState.gravity = oldGravity
        }
      }

      // check for violations in case the flip caused the violations to disappear
      violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
      if ((violations.topViolation || violations.bottomViolation) && canSlideY) {
        // try sliding
        const newYDeltaOffset = violations.bottomViolation ? -violations.bottomViolation : violations.topViolation
        const oldOffset = positionerState.offset
        positionerState.offset = _math_Point__WEBPACK_IMPORTED_MODULE_4__["default"].create(oldOffset.x, oldOffset.y + newYDeltaOffset)
        // no need to check if there is still a Y violation as we already ensured the height < max height
      }
    }

    // check for violations in case the flip or slide caused the violations to disappear
    violations = positionerState.checkScreenConstraints(parentXdgSurface, primaryParentView)
    if ((violations.topViolation || violations.bottomViolation) && canResizeY) {
      if (violations.topViolation) {
        const oldOffset = positionerState.offset
        positionerState.offset = _math_Point__WEBPACK_IMPORTED_MODULE_4__["default"].create(oldOffset.x, oldOffset.y + violations.topViolation)
        positionerState.size.y1 = positionerState.size.y1 - violations.topViolation
      }

      if (violations.bottomViolation) {
        positionerState.size.y1 = positionerState.size.y1 - violations.bottomViolation
      }
    }

    const {x0: x, y0: y, width, height} = positionerState.size
    this.resource.configure(x, y, width, height)
  }
}


/***/ }),
/* 122 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgPopupRequests {

	/**
	 *
	 *	This destroys the popup. Explicitly destroying the xdg_popup
	 *	object will also dismiss the popup, and unmap the surface.
	 *
	 *	If this xdg_popup is not the "topmost" popup, a protocol error
	 *	will be sent.
	 *      
	 *
	 * @param {XdgPopupResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	This request makes the created popup take an explicit grab. An explicit
	 *	grab will be dismissed when the user dismisses the popup, or when the
	 *	client destroys the xdg_popup. This can be done by the user clicking
	 *	outside the surface, using the keyboard, or even locking the screen
	 *	through closing the lid or a timeout.
	 *
	 *	If the compositor denies the grab, the popup will be immediately
	 *	dismissed.
	 *
	 *	This request must be used in response to some sort of user action like a
	 *	button press, key press, or touch down event. The serial number of the
	 *	event should be passed as 'serial'.
	 *
	 *	The parent of a grabbing popup must either be an xdg_toplevel surface or
	 *	another xdg_popup with an explicit grab. If the parent is another
	 *	xdg_popup it means that the popups are nested, with this popup now being
	 *	the topmost popup.
	 *
	 *	Nested popups must be destroyed in the reverse order they were created
	 *	in, e.g. the only popup you are allowed to destroy at all times is the
	 *	topmost one.
	 *
	 *	When compositors choose to dismiss a popup, they may dismiss every
	 *	nested grabbing popup as well. When a compositor dismisses popups, it
	 *	will follow the same dismissing order as required from the client.
	 *
	 *	The parent of a grabbing popup must either be another xdg_popup with an
	 *	active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
	 *	explicit grabs already taken.
	 *
	 *	If the topmost grabbing popup is destroyed, the grab will be returned to
	 *	the parent of the popup, if that parent previously had an explicit grab.
	 *
	 *	If the parent is a grabbing popup which has already been dismissed, this
	 *	popup will be immediately dismissed. If the parent is a popup that did
	 *	not take an explicit grab, an error will be raised.
	 *
	 *	During a popup grab, the client owning the grab will receive pointer
	 *	and touch events for all their surfaces as normal (similar to an
	 *	"owner-events" grab in X11 parlance), while the top most grabbing popup
	 *	will always have keyboard focus.
	 *      
	 *
	 * @param {XdgPopupResource} resource 
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 *
	 * @since 1
	 *
	 */
	grab(resource, seat, serial) {}
}

module.exports = XdgPopupRequests


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgPositioner; });
/* harmony import */ var _protocol_XdgPositionerRequests__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(124);
/* harmony import */ var _protocol_XdgPositionerRequests__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPositionerRequests__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(113);
/* harmony import */ var _protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _math_Point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);








/**
 * @type {{'0': (function(Rect): Point), '1': (function(Rect): Point), '2': (function(Rect): Point), '3': (function(Rect): Point), '4': (function(Rect): Point), '5': (function(Rect): Point), '6': (function(Rect): Point), '7': (function(Rect): Point), '8': (function(Rect): Point)}}
 */
const anchorCalculation = {
  /**
   * none
   * @param {Rect}anchorRect
   * @return {Point}
   */
  0: (anchorRect) => {
    // calculate center
    const x = Math.round((anchorRect.x0 + anchorRect.width) / 2)
    const y = Math.round((anchorRect.y0 + anchorRect.height) / 2)
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * top
   * @param {Rect}anchorRect
   * @return {Point}
   */
  1: (anchorRect) => {
    const x = Math.round((anchorRect.x0 + anchorRect.width) / 2)
    const y = anchorRect.y0
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * bottom
   * @param {Rect}anchorRect
   * @return {Point}
   */
  2: (anchorRect) => {
    const x = Math.round((anchorRect.x0 + anchorRect.width) / 2)
    const y = anchorRect.y1
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * left
   * @param {Rect}anchorRect
   * @return {Point}
   */
  3: (anchorRect) => {
    const x = anchorRect.x0
    const y = Math.round((anchorRect.y0 + anchorRect.height) / 2)
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * right
   * @param {Rect}anchorRect
   * @return {Point}
   */
  4: (anchorRect) => {
    const x = anchorRect.x1
    const y = Math.round((anchorRect.y0 + anchorRect.height) / 2)
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * topLeft
   * @param {Rect}anchorRect
   * @return {Point}
   */
  5: (anchorRect) => {
    const x = anchorRect.x0
    const y = anchorRect.y0
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * bottomLeft
   * @param {Rect}anchorRect
   * @return {Point}
   */
  6: (anchorRect) => {
    const x = anchorRect.x0
    const y = anchorRect.y1
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * topRight
   * @param {Rect}anchorRect
   * @return {Point}
   */
  7: (anchorRect) => {
    const x = anchorRect.x1
    const y = anchorRect.y0
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  },
  /**
   * bottomRight
   * @param {Rect}anchorRect
   * @return {Point}
   */
  8: (anchorRect) => {
    const x = anchorRect.x1
    const y = anchorRect.y1
    return _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  }
}

const offsetCalculation = {
  /**
   * none
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  0: (anchor, offset, windowGeometry) => {
    const x = Math.round(windowGeometry.x0 + (windowGeometry.width) / 2)
    const y = Math.round(windowGeometry.y0 + (windowGeometry.height) / 2)
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y))
  },
  /**
   * top
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  1: (anchor, offset, windowGeometry) => {
    const x = Math.round(windowGeometry.x0 + (windowGeometry.width / 2))
    const y = windowGeometry.y1
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, offset.y))
  },
  /**
   * bottom
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  2: (anchor, offset, windowGeometry) => {
    const x = Math.round(windowGeometry.x0 + (windowGeometry.width / 2))
    const y = windowGeometry.y0
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, offset.y))
  },
  /**
   * left
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  3: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x1
    const y = Math.round(windowGeometry.y0 + (windowGeometry.height) / 2)
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(offset.x, 0))
  },
  /**
   * right
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  4: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x0
    const y = Math.round(windowGeometry.y0 + (windowGeometry.height) / 2)
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(offset.x, 0))
  },
  /**
   * topLeft
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  5: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x1
    const y = windowGeometry.y1
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).minus(offset)
  },
  /**
   * bottomLeft
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  6: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x1
    const y = windowGeometry.y0
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(-offset.x, offset.y))
  },
  /**
   * topRight
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  7: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x0
    const y = windowGeometry.y1
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(offset.x, -offset.y))
  },
  /**
   * bottomRight
   * @param {Point}anchor
   * @param {Point}offset
   * @param {Rect}windowGeometry
   * @return {Point}
   */
  8: (anchor, offset, windowGeometry) => {
    const x = windowGeometry.x0
    const y = windowGeometry.y0
    return anchor.minus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)).plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(offset.x, offset.y))
  }
}

/**
 *
 *      The xdg_positioner provides a collection of rules for the placement of a
 *      child surface relative to a parent surface. Rules can be defined to ensure
 *      the child surface remains within the visible area's borders, and to
 *      specify how the child surface changes its position, such as sliding along
 *      an axis, or flipping around a rectangle. These positioner-created rules are
 *      constrained by the requirement that a child surface must intersect with or
 *      be at least partially adjacent to its parent surface.
 *
 *      See the various requests for details about possible rules.
 *
 *      At the time of the request, the compositor makes a copy of the rules
 *      specified by the xdg_positioner. Thus, after the request is complete the
 *      xdg_positioner object can be destroyed or reused; further changes to the
 *      object will have no effect on previous usages.
 *
 *      For an xdg_positioner object to be considered complete, it must have a
 *      non-zero size set by set_size, and a non-zero anchor rectangle set by
 *      set_anchor_rect. Passing an incomplete xdg_positioner object when
 *      positioning a surface raises an error.
 *
 * @implements XdgPositionerRequests
 */
class XdgPositioner extends _protocol_XdgPositionerRequests__WEBPACK_IMPORTED_MODULE_0___default.a {
  /**
   * @param {XdgPositionerResource}xdgPositionerResource
   * @return {XdgPositioner}
   */
  static create (xdgPositionerResource) {
    const xdgPositioner = new XdgPositioner()
    xdgPositionerResource.implementation = xdgPositioner
    return xdgPositioner
  }

  /**
   * Use XdgPositioner.create(...) instead.
   * @private
   */
  constructor () {
    super()
    /**
     * @type {Rect|null}
     */
    this.size = null
    /**
     * @type {Rect|null}
     */
    this.anchorRect = null
    /**
     * @type {number}
     */
    this.anchor = 0
    /**
     * @type {number}
     */
    this.gravity = 0
    /**
     * @type {number}
     */
    this.constraintAdjustment = 0
    /**
     * @type {Point}
     */
    this.offset = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, 0)
  }

  /**
   *
   *  Notify the compositor that the xdg_positioner will no longer be used.
   *
   *
   * @param {XdgPositionerResource} resource
   *
   * @since 1
   * @override
   */
  destroy (resource) {
    resource.destroy()
  }

  /**
   *
   *  Set the size of the surface that is to be positioned with the positioner
   *  object. The size is in surface-local coordinates and corresponds to the
   *  window geometry. See xdg_surface.set_window_geometry.
   *
   *  If a zero or negative size is set the invalid_input error is raised.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {number} width width of positioned rectangle
   * @param {number} height height of positioned rectangle
   *
   * @since 1
   * @override
   */
  setSize (resource, width, height) {
    if (width <= 0 || height <= 0) {
      resource.postError(_protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.invalidInput, 'Size width or height of positioner can not be negative.')
      false && console.log('Protocol error. Size width or height of positioner can not be negative.')
      return
    }
    this.size = _math_Rect__WEBPACK_IMPORTED_MODULE_2__["default"].create(0, 0, width, height)
  }

  /**
   *
   *  Specify the anchor rectangle within the parent surface that the child
   *  surface will be placed relative to. The rectangle is relative to the
   *  window geometry as defined by xdg_surface.set_window_geometry of the
   *  parent surface.
   *
   *  When the xdg_positioner object is used to position a child surface, the
   *  anchor rectangle may not extend outside the window geometry of the
   *  positioned child's parent surface.
   *
   *  If a negative size is set the invalid_input error is raised.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {number} x x position of anchor rectangle
   * @param {number} y y position of anchor rectangle
   * @param {number} width width of anchor rectangle
   * @param {number} height height of anchor rectangle
   *
   * @since 1
   * @override
   */
  setAnchorRect (resource, x, y, width, height) {
    if (width <= 0 || height <= 0) {
      resource.postError(_protocol_XdgPositionerResource__WEBPACK_IMPORTED_MODULE_1___default.a.Error.invalidInput, 'Anchor rect width or height of positioner can not be negative.')
      false && console.log('Protocol error. Anchor rect width or height of positioner can not be negative.')
      return
    }
    this.anchorRect = _math_Rect__WEBPACK_IMPORTED_MODULE_2__["default"].create(x, y, x + width, y + height)
  }

  /**
   *
   *  Defines the anchor point for the anchor rectangle. The specified anchor
   *  is used derive an anchor point that the child surface will be
   *  positioned relative to. If a corner anchor is set (e.g. 'top_left' or
   *  'bottom_right'), the anchor point will be at the specified corner;
   *  otherwise, the derived anchor point will be centered on the specified
   *  edge, or in the center of the anchor rectangle if no edge is specified.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {Number} anchor anchor
   *
   * @since 1
   * @override
   */
  setAnchor (resource, anchor) {
    this.anchor = anchor
  }

  /**
   *
   *  Defines in what direction a surface should be positioned, relative to
   *  the anchor point of the parent surface. If a corner gravity is
   *  specified (e.g. 'bottom_right' or 'top_left'), then the child surface
   *  will be placed towards the specified gravity; otherwise, the child
   *  surface will be centered over the anchor point on any axis that had no
   *  gravity specified.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {Number} gravity gravity direction
   *
   * @since 1
   * @override
   */
  setGravity (resource, gravity) {
    this.gravity = gravity
  }

  /**
   *
   *  Specify how the window should be positioned if the originally intended
   *  position caused the surface to be constrained, meaning at least
   *  partially outside positioning boundaries set by the compositor. The
   *  adjustment is set by constructing a bitmask describing the adjustment to
   *  be made when the surface is constrained on that axis.
   *
   *  If no bit for one axis is set, the compositor will assume that the child
   *  surface should not change its position on that axis when constrained.
   *
   *  If more than one bit for one axis is set, the order of how adjustments
   *  are applied is specified in the corresponding adjustment descriptions.
   *
   *  The default adjustment is none.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {number} constraintAdjustment bit mask of constraint adjustments
   *
   * @since 1
   * @override
   */
  setConstraintAdjustment (resource, constraintAdjustment) {
    this.constraintAdjustment = constraintAdjustment
  }

  /**
   *
   *  Specify the surface position offset relative to the position of the
   *  anchor on the anchor rectangle and the anchor on the surface. For
   *  example if the anchor of the anchor rectangle is at (x, y), the surface
   *  has the gravity bottom|right, and the offset is (ox, oy), the calculated
   *  surface position will be (x + ox, y + oy). The offset position of the
   *  surface is the one used for constraint testing. See
   *  set_constraint_adjustment.
   *
   *  An example use case is placing a popup menu on top of a user interface
   *  element, while aligning the user interface element of the parent surface
   *  with some user interface element placed somewhere in the popup surface.
   *
   *
   * @param {XdgPositionerResource} resource
   * @param {Number} x surface position x offset
   * @param {Number} y surface position y offset
   *
   * @since 1
   * @override
   */
  setOffset (resource, x, y) {
    this.offset = _math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(x, y)
  }

  /**
   * @return {{size: Rect, anchorRect: Rect, anchor: number, gravity: number, constraintAdjustment: number, offset: Point, surfaceSpaceAnchorPoint: (function(XdgSurface): Point), checkScreenConstraints: (function(XdgSurface, View): {topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number})}}
   */
  createStateCopy () {
    const selfSize = this.size
    const selfAnchorRect = this.anchorRect
    const selfAnchor = this.anchor
    const selfGravity = this.gravity
    const selfConstraintAdjustment = this.constraintAdjustment
    const selfOffset = this.offset
    return {
      size: selfSize,
      /**
       * @type {Rect|null}
       */
      anchorRect: selfAnchorRect,
      /**
       * @type {number}
       */
      anchor: selfAnchor,
      /**
       * @type {number}
       */
      gravity: selfGravity,
      /**
       * @type {number}
       */
      constraintAdjustment: selfConstraintAdjustment,
      /**
       * @type {Point}
       */
      offset: selfOffset,
      /**
       * @param {XdgSurface}parent
       * @return {Point}
       */
      surfaceSpaceAnchorPoint: function (parent) {
        const parentWindowGeometry = parent.windowGeometry
        const surfaceSpaceAnchorRectPosition = parentWindowGeometry.position.plus(this.anchorRect.position)
        const {x, y} = surfaceSpaceAnchorRectPosition
        const surfaceSpaceAnchorRect = _math_Rect__WEBPACK_IMPORTED_MODULE_2__["default"].create(x, y, x + this.anchorRect.width, y + this.anchorRect.height)
        const surfaceSpaceAnchorPoint = anchorCalculation[this.anchor](surfaceSpaceAnchorRect)
        return offsetCalculation[this.gravity](surfaceSpaceAnchorPoint, this.offset, this.size)
      },
      /**
       * @param {XdgSurface}parent
       * @param {View}parentView
       * @return {{topViolation: number, rightViolation: number, bottomViolation: number, leftViolation: number}}
       */
      checkScreenConstraints: function (parent, parentView) {
        const surfaceSpaceAnchorPoint = this.surfaceSpaceAnchorPoint(parent)
        const surfaceSpaceWinGeoMin = surfaceSpaceAnchorPoint.plus(this.size.position)
        const surfaceSpaceWinGeoMax = surfaceSpaceAnchorPoint.plus(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(this.size.x1, this.size.y1))

        const surfaceSpaceMinBound = parentView.toSurfaceSpace(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(0, 0))
        const surfaceSpaceMaxBound = parentView.toSurfaceSpace(_math_Point__WEBPACK_IMPORTED_MODULE_3__["default"].create(window.document.body.clientWidth, window.document.body.clientHeight))

        let topViolation = 0
        let rightViolation = 0
        let bottomViolation = 0
        let leftViolation = 0

        if (surfaceSpaceWinGeoMin.x < surfaceSpaceMinBound.x) {
          leftViolation = Math.abs(surfaceSpaceMinBound.x - surfaceSpaceWinGeoMin.x)
        }
        if (surfaceSpaceWinGeoMin.y < surfaceSpaceMinBound.y) {
          topViolation = Math.abs(surfaceSpaceMinBound.y - surfaceSpaceWinGeoMin.y)
        }

        if (surfaceSpaceWinGeoMax.x > surfaceSpaceMaxBound.x) {
          rightViolation = surfaceSpaceWinGeoMax.x - surfaceSpaceMaxBound.x
        }

        if (surfaceSpaceWinGeoMax.y > surfaceSpaceMaxBound.y) {
          bottomViolation = surfaceSpaceWinGeoMax.y - surfaceSpaceMaxBound.y
        }

        return {
          topViolation: topViolation,
          rightViolation: rightViolation,
          bottomViolation: bottomViolation,
          leftViolation: leftViolation
        }
      }
    }
  }
}


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgPositionerRequests {

	/**
	 *
	 *	Notify the compositor that the xdg_positioner will no longer be used.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 *
	 * @since 1
	 *
	 */
	destroy(resource) {}

	/**
	 *
	 *	Set the size of the surface that is to be positioned with the positioner
	 *	object. The size is in surface-local coordinates and corresponds to the
	 *	window geometry. See xdg_surface.set_window_geometry.
	 *
	 *	If a zero or negative size is set the invalid_input error is raised.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} width width of positioned rectangle 
	 * @param {number} height height of positioned rectangle 
	 *
	 * @since 1
	 *
	 */
	setSize(resource, width, height) {}

	/**
	 *
	 *	Specify the anchor rectangle within the parent surface that the child
	 *	surface will be placed relative to. The rectangle is relative to the
	 *	window geometry as defined by xdg_surface.set_window_geometry of the
	 *	parent surface.
	 *
	 *	When the xdg_positioner object is used to position a child surface, the
	 *	anchor rectangle may not extend outside the window geometry of the
	 *	positioned child's parent surface.
	 *
	 *	If a negative size is set the invalid_input error is raised.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} x x position of anchor rectangle 
	 * @param {number} y y position of anchor rectangle 
	 * @param {number} width width of anchor rectangle 
	 * @param {number} height height of anchor rectangle 
	 *
	 * @since 1
	 *
	 */
	setAnchorRect(resource, x, y, width, height) {}

	/**
	 *
	 *	Defines the anchor point for the anchor rectangle. The specified anchor
	 *	is used derive an anchor point that the child surface will be
	 *	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
	 *	'bottom_right'), the anchor point will be at the specified corner;
	 *	otherwise, the derived anchor point will be centered on the specified
	 *	edge, or in the center of the anchor rectangle if no edge is specified.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} anchor anchor 
	 *
	 * @since 1
	 *
	 */
	setAnchor(resource, anchor) {}

	/**
	 *
	 *	Defines in what direction a surface should be positioned, relative to
	 *	the anchor point of the parent surface. If a corner gravity is
	 *	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
	 *	will be placed towards the specified gravity; otherwise, the child
	 *	surface will be centered over the anchor point on any axis that had no
	 *	gravity specified.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} gravity gravity direction 
	 *
	 * @since 1
	 *
	 */
	setGravity(resource, gravity) {}

	/**
	 *
	 *	Specify how the window should be positioned if the originally intended
	 *	position caused the surface to be constrained, meaning at least
	 *	partially outside positioning boundaries set by the compositor. The
	 *	adjustment is set by constructing a bitmask describing the adjustment to
	 *	be made when the surface is constrained on that axis.
	 *
	 *	If no bit for one axis is set, the compositor will assume that the child
	 *	surface should not change its position on that axis when constrained.
	 *
	 *	If more than one bit for one axis is set, the order of how adjustments
	 *	are applied is specified in the corresponding adjustment descriptions.
	 *
	 *	The default adjustment is none.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} constraintAdjustment bit mask of constraint adjustments 
	 *
	 * @since 1
	 *
	 */
	setConstraintAdjustment(resource, constraintAdjustment) {}

	/**
	 *
	 *	Specify the surface position offset relative to the position of the
	 *	anchor on the anchor rectangle and the anchor on the surface. For
	 *	example if the anchor of the anchor rectangle is at (x, y), the surface
	 *	has the gravity bottom|right, and the offset is (ox, oy), the calculated
	 *	surface position will be (x + ox, y + oy). The offset position of the
	 *	surface is the one used for constraint testing. See
	 *	set_constraint_adjustment.
	 *
	 *	An example use case is placing a popup menu on top of a user interface
	 *	element, while aligning the user interface element of the parent surface
	 *	with some user interface element placed somewhere in the popup surface.
	 *      
	 *
	 * @param {XdgPositionerResource} resource 
	 * @param {number} x surface position x offset 
	 * @param {number} y surface position y offset 
	 *
	 * @since 1
	 *
	 */
	setOffset(resource, x, y) {}
}

module.exports = XdgPositionerRequests


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DesktopUserShell; });
/* harmony import */ var _DesktopUserShellSurface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);
/* harmony import */ var _DesktopShellMenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(128);
/* harmony import */ var _desktopshell_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(129);
/* harmony import */ var _desktopshell_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_desktopshell_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _DesktopShellAppMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(131);








/**
 * @implements UserShell
 */
class DesktopUserShell {
  /**
   * @param {Session}session
   * @param {Seat}seat
   * @return {DesktopUserShell}
   */
  static create (session, seat) {
    const body = document.body
    const workspace = document.getElementById('workspace')
    const panel = /** @type {HTMLDivElement} */document.createElement('div')
    panel.classList.add('hpanel')
    body.insertAdjacentElement('afterbegin', panel)

    const entryContainer = /** @type {HTMLDivElement} */document.createElement('div')
    entryContainer.classList.add('entry-container')
    panel.appendChild(entryContainer)

    const desktopShellAppMenu = _DesktopShellAppMenu__WEBPACK_IMPORTED_MODULE_3__["default"].create(session)
    panel.appendChild(desktopShellAppMenu.divElementAppMenuButton)

    const desktopShellMenu = _DesktopShellMenu__WEBPACK_IMPORTED_MODULE_1__["default"].create()
    panel.appendChild(desktopShellMenu.divElementMenuButton)

    const desktopUserShell = new DesktopUserShell(body, workspace, panel, entryContainer, seat)
    seat.addKeyboardResourceListener((wlKeyboardResoure) => {
      desktopUserShell._keyboardAvailable(wlKeyboardResoure)
    })

    return desktopUserShell
  }

  /**
   * Use DesktopShell.create(..)
   * @param {HTMLElement}body
   * @param {HTMLElement}workspace
   * @param {HTMLDivElement}panel
   * @param {HTMLDivElement}entryContainer
   * @param {Seat}seat
   * @private
   */
  constructor (body, workspace, panel, entryContainer, seat) {
    /**
     * @type{HTMLElement}
     */
    this.body = body
    /**
     * @type{HTMLElement}
     */
    this.workspace = workspace
    /**
     * @type{HTMLDivElement}
     */
    this.panel = panel
    /**
     * @type{HTMLDivElement}
     */
    this.entryContainer = entryContainer
    /**
     * @type {Seat}
     * @private
     */
    this._seat = seat
  }

  /**
   * @param {Surface}surface
   * @return {UserShellSurface}
   * @override
   */
  manage (surface) {
    const desktopShellEntry = _DesktopUserShellSurface__WEBPACK_IMPORTED_MODULE_0__["default"].create(surface, this._seat)
    this.entryContainer.appendChild(desktopShellEntry.divElement)
    return desktopShellEntry
  }

  /**
   * @param {WlKeyboardResource}grKeyboard
   * @private
   */
  _keyboardAvailable (grKeyboard) {
    _DesktopUserShellSurface__WEBPACK_IMPORTED_MODULE_0__["default"].desktopUserShellSurfaces.forEach((desktopUserShellSurface) => {
      if (desktopUserShellSurface.mainView.surface.resource.client === grKeyboard.client) {
        desktopUserShellSurface.wlKeyboardResource = grKeyboard
      }
    })
  }
}


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DesktopUserShellSurface; });
/* harmony import */ var _UserShellSurface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(127);




/**
 * @implements UserShellSurface
 */
class DesktopUserShellSurface extends _UserShellSurface__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Surface}surface
   * @param {Seat}seat
   * @return {DesktopUserShellSurface}
   */
  static create (surface, seat) {
    // create a mainView and attach it to the scene
    const mainView = surface.createView()
    this._fadeOutAndDetachViewOnDestroy(mainView)
    mainView.attachTo(document.body)

    const divElement = document.createElement('div')
    // divElement will become visible once surface is mapped
    divElement.style.display = 'none'
    divElement.classList.add('entry')
    this._fadeOutAndDetachEntryOnDestroy(mainView, divElement)

    const desktopUserShellSurface = new DesktopUserShellSurface(mainView, divElement, seat)
    desktopUserShellSurface._activateOnPointerButton()

    divElement.addEventListener('mousedown', () => {
      desktopUserShellSurface._activeCallback()
    })
    // destroy the mainView if the shell-surface is destroyed
    surface.resource.onDestroy().then(() => {
      desktopUserShellSurface.destroy()
    })

    DesktopUserShellSurface.desktopUserShellSurfaces.push(desktopUserShellSurface)

    return desktopUserShellSurface
  }

  /**
   * @param {View}view
   * @param {HTMLElement}entry
   * @private
   */
  static _fadeOutAndDetachEntryOnDestroy (view, entry) {
    view.onDestroy().then(() => {
      entry.addEventListener('transitionend', () => {
        if (entry.parentElement) {
          entry.parentElement.removeChild(entry)
        }
      })
      entry.classList.add('entry-removed')
    })
  }

  /**
   * @param {View}view
   * @private
   */
  static _fadeOutAndDetachViewOnDestroy (view) {
    // play a nice fade out animation if the view is destroyed
    view.onDestroy().then(() => {
      // after the animation has ended, detach the view from the scene
      view.bufferedCanvas.containerDiv.addEventListener('transitionend', () => {
        view.detach()
      })
      // play the animation
      view.fadeOut()
    })
  }

  /**
   * Use DesktopShellEntry.create(..) instead.
   * @param {View}mainView
   * @param {HTMLDivElement}divElement
   * @param {Seat}seat
   * @private
   */
  constructor (mainView, divElement, seat) {
    super()
    /**
     * @type {View}
     */
    this.mainView = mainView
    /**
     * @type {HTMLDivElement}
     */
    this.divElement = divElement
    /**
     * @type {Function|null}
     * @private
     */
    this._activeCallback = null
    /**
     * @type {function}
     * @private
     */
    this._inactivateCallback = () => {}
    /**
     *
     * @type {WlKeyboardResource|null}
     * @private
     */
    this._wlKeyboardResource = null
    /**
     * @type {boolean}
     */
    this.active = false
    /**
     * @type {Seat}
     * @private
     */
    this._seat = seat
  }

  /**
   * @private
   */
  _activateOnPointerButton () {
    this._seat.pointer.onButtonPress().then(() => {
      if (this.mainView.destroyed) {
        return
      }

      if (!this.active &&
        this._seat.pointer.focus &&
        this._seat.pointer.focus.surface === this.mainView.surface) {
        this._activeCallback()
      }

      this._activateOnPointerButton()
    })
  }

  /**
   * Confirms that the user shell can give the surface input.
   * @override
   */
  activationAck () {
    if (this.mainView.destroyed) {
      return
    }

    if (!this.active) {
      this.active = true

      this.mainView.show()
      this.mainView.raise()
      this.divElement.classList.add('entry-focus')

      if (this._wlKeyboardResource) {
        this._giveKeyboardFocus()
      }

      DesktopUserShellSurface.desktopUserShellSurfaces.forEach((desktopUserShellSurface) => {
        if (desktopUserShellSurface !== this) {
          desktopUserShellSurface._deactivate()
        }
      })
    }
  }

  /**
   * @param {WlKeyboardResource}wlKeyboardResource
   */
  set wlKeyboardResource (wlKeyboardResource) {
    if (this.mainView.destroyed) {
      return
    }

    if (this.active && this._wlKeyboardResource && this._wlKeyboardResource.implementation.focus !== this.mainView.surface) {
      this._giveKeyboardFocus()
    }
    this._wlKeyboardResource = wlKeyboardResource
    this._wlKeyboardResource.onDestroy().then(() => {
      this._wlKeyboardResource = null
    })
  }

  /**
   * @private
   */
  _giveKeyboardFocus () {
    const keyboard = /** @typ{Keyboard} */this._wlKeyboardResource.implementation
    keyboard.focusGained(this.mainView.surface)
  }

  /**
   * @private
   */
  _deactivate () {
    if (this.active) {
      this.active = false
      this.divElement.classList.remove('entry-focus')
      this._inactivateCallback()
    }
  }

  /**
   * Indicates if the surface contents can be displayed on screen.
   * @param {boolean}mapped
   * @override
   */
  set mapped (mapped) {
    // TODO we probably want to use a style class here instead of display = ..
    if (mapped) {
      this.divElement.style.display = 'inline'
      this.divElement.classList.remove('entry-removed')
    } else {
      this.divElement.addEventListener('transitionend', () => {
        this.divElement.style.display = 'none'
      })
      this.divElement.classList.add('entry-removed')
    }
  }

  /**
   * Registers a callback that will be fired when the user shell wants to make a surface active (ie give it input)
   * @param {function}activeCallback
   * @override
   */
  set onActivationRequest (activeCallback) {
    this._activeCallback = activeCallback
    if (!this.active) {
      this._activeCallback()
    }
  }

  /**
   * Registers callback that notifies if a surface is no longer active (ie no longer receives input)
   * @param {function}inactivateCallback
   * @override
   */
  set onInactive (inactivateCallback) {
    this._inactivateCallback = inactivateCallback
  }

  /**
   * The id of the application. Can be used to group surfaces.
   * @param {string}appId
   * @override
   */
  set appId (appId) {
    // TODO implement application surface grouping
  }

  /**
   * The title of the surface
   * @param {string} title
   * @override
   */
  set title (title) {
    this.divElement.textContent = title
  }

  /**
   * Notifies the user shell that the surface should no longer be displayed. If a surface is still mapped then the
   * surface contents can still be displayed ie in a live updating tile.
   * @override
   */
  minimize () {
    if (this.mainView.destroyed) {
      return
    }
    this.mainView.fadeOut()
  }

  /**
   * Notifies the user shell that it should destroy all resources associated with the surface
   * @override
   */
  destroy () {
    const idx = DesktopUserShellSurface.desktopUserShellSurfaces.indexOf(this)
    if (idx > -1) {
      DesktopUserShellSurface.desktopUserShellSurfaces.splice(idx, 1)
    }
  }

  /**
   * Indicates if the application is responding.
   * @param {boolean}unresponsive
   */
  set unresponsive (unresponsive) {
    // TODO
  }
}

/**
 * @type {Array<DesktopUserShellSurface>}
 */
DesktopUserShellSurface.desktopUserShellSurfaces = []


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UserShellSurface; });
/**
 * Implementations are expected to extend this class.
 * @interface
 */
class UserShellSurface {
  /**
   * The title of the surface
   * @param {string} title
   */
  set title (title) {}

  /**
   * The id of the application. Can be used to group surfaces.
   * @param {string}appId
   */
  set appId (appId) {}

  /**
   * Indicates if the surface contents can be displayed on screen.
   * @param {boolean}mapped
   */
  set mapped (mapped) {}

  /**
   * Indicates if the application is responding.
   * @param {boolean}unresponsive
   */
  set unresponsive (unresponsive) {}

  /**
   * Registers a callback that will be fired when the user shell wants to make a surface active (ie give it input)
   * @param {function}activeCallback
   */
  set onActivationRequest (activeCallback) {}

  /**
   * Registers callback that notifies if a surface is no longer active (ie no longer receives input)
   * @param {function}inactivateCallback
   */
  set onInactive (inactivateCallback) {}

  /**
   * Confirms that the user shell can give the surface input.
   */
  activationAck () {}

  /**
   * Notifies the user shell that it should destroy all resources associated with the surface
   */
  destroy () {}

  /**
   * Notifies the user shell that the surface should no longer be displayed. If the surface is still mapped then the
   * surface contents can still be displayed ie in a live updating tile.
   */
  minimize () {}
}


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DesktopShellMenu; });


class DesktopShellMenu {
  /**
   * @return {DesktopShellMenu}
   */
  static create () {
    const divElementMenuButton = this._createDivElementMenuButton()
    const divElementMenuContainer = this._createDivElementMenuContainer()
    const divElementMenu = this._createDivElementMenu()
    divElementMenuContainer.appendChild(divElementMenu)
    const searchBar = this._createSearchBar(divElementMenuContainer)
    divElementMenu.appendChild(searchBar.divElementSearchContainer)

    const desktopShellMenu = new DesktopShellMenu(divElementMenuButton, divElementMenuContainer, divElementMenu, searchBar)

    // event listeners
    this._addEventListeners(desktopShellMenu)

    return desktopShellMenu
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementMenuButton () {
    const divElementMenuButton = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuButton.classList.add('menu-button')
    divElementMenuButton.classList.add('config')
    return divElementMenuButton
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementMenuContainer () {
    const divElementMenuContainer = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuContainer.classList.add('menu-container')
    divElementMenuContainer.classList.add('config')
    window.document.body.appendChild(divElementMenuContainer)

    const divElementMenuTriangleUp = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuTriangleUp.classList.add('menu-triangle-up')
    divElementMenuTriangleUp.classList.add('config')
    divElementMenuContainer.appendChild(divElementMenuTriangleUp)

    return divElementMenuContainer
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementMenu () {
    const divElementMenu = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenu.classList.add('menu')
    divElementMenu.classList.add('config')
    return divElementMenu
  }

  /**
   * @param {HTMLDivElement}divElementMenuContainer
   * @return {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}
   * @private
   */
  static _createSearchBar (divElementMenuContainer) {
    const divElementSearchContainer = /** @type {HTMLDivElement} */document.createElement('div')
    const divElementSearchIcon = /** @type {HTMLDivElement} */document.createElement('div')
    const inputElementSearchInput = /** @type {HTMLInputElement} */document.createElement('input')

    inputElementSearchInput.setAttribute('type', 'text')
    inputElementSearchInput.setAttribute('name', 'search')
    inputElementSearchInput.setAttribute('placeholder', '...')

    divElementSearchContainer.appendChild(divElementSearchIcon)
    divElementSearchContainer.appendChild(inputElementSearchInput)

    divElementSearchContainer.classList.add('search-container')
    divElementSearchIcon.classList.add('search-icon')
    inputElementSearchInput.classList.add('search-input')

    return {
      divElementSearchContainer: divElementSearchContainer,
      divElementSearchIcon: divElementSearchIcon,
      inputElementSearchInput: inputElementSearchInput
    }
  }

  /**
   * @param {DesktopShellMenu}desktopShellMenu
   * @private
   */
  static _addEventListeners (desktopShellMenu) {
    desktopShellMenu.divElementMenuButton.addEventListener('mousedown', () => {
      desktopShellMenu.showMenu()
    })
    window.document.addEventListener('mousedown', (event) => {
      if (event.target !== desktopShellMenu.divElementMenu && event.target !== desktopShellMenu.divElementMenuButton) {
        desktopShellMenu.hideMenu()
      }
    })
    desktopShellMenu.searchBar.inputElementSearchInput.addEventListener('input', (inputEvent) => {
      const searchText = inputEvent.data
      // TODO scroll matching menu item into view
    })
  }

  /**
   * @param {HTMLDivElement}divElementMenuButton
   * @param {HTMLDivElement}divElementMenuContainer
   * @param {HTMLDivElement}divElementMenu
   * @param {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}searchBar
   */
  constructor (divElementMenuButton, divElementMenuContainer, divElementMenu, searchBar) {
    /**
     * @type {HTMLDivElement}
     */
    this.divElementMenuButton = divElementMenuButton
    /**
     * @type {HTMLDivElement}
     */
    this.divElementMenuContainer = divElementMenuContainer
    /**
     * @type {HTMLDivElement}
     */
    this.divElementMenu = divElementMenu
    /**
     * @type {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}
     */
    this.searchBar = searchBar
  }

  showMenu () {
    this.divElementMenuContainer.addEventListener('transitionend', () => {
      this.searchBar.inputElementSearchInput.classList.add('enable-default')
      this.searchBar.inputElementSearchInput.focus()
    })

    this.divElementMenuContainer.style.visibility = 'visible'
    this.divElementMenu.classList.add('menu-active')
    this.divElementMenuButton.classList.add('menu-button-active')
  }

  hideMenu () {
    this.searchBar.inputElementSearchInput.blur()
    this.searchBar.inputElementSearchInput.classList.remove('enable-default')
    this.searchBar.inputElementSearchInput.value = ''

    this.divElementMenuContainer.style.visibility = 'hidden'
    this.divElementMenu.classList.remove('menu-active')
    this.divElementMenuButton.classList.remove('menu-button-active')
  }
}


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(130);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(108)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(107)(false);
// imports


// module
exports.push([module.i, "body {\n    display: flex;\n    flex-direction: column;\n}\n\n#workspace {\n    flex-grow: 1;\n    display: inline;\n    background-image: url(/assets/pattern_light.png);\n    background-size: auto;\n}\n\n.hpanel {\n    z-index: 0;\n    background-color: rgb(200, 200, 200);\n\n    display: flex;\n    flex-wrap: nowrap;\n    flex-direction: row;\n\n    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.75);\n}\n\n.entry-container {\n    flex-grow: 1;\n    display: flex;\n    flex-wrap: wrap;\n    flex-direction: row;\n    align-items: center;\n}\n\n.entry {\n    flex-grow: 1;\n    min-width: 100px;\n    max-width: 20vw;\n    height: 3.6vh;\n\n    background: rgb(150, 150, 150);\n\n    font-family: sans-serif;\n    font-size: medium;\n    text-align: left;\n    padding-left: 1vh;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    vertical-align: middle;\n    line-height: 4vh;\n    color: black;\n\n    box-shadow: inset 0 0.6vh 0.1vh -0.3vh rgba(252, 104, 42, 0.20);\n\n    transition: all 200ms ease-in-out;\n}\n\n.entry-removed {\n    opacity: 0;\n}\n\n.entry-focus {\n    box-shadow: inset 0 0.6vh 0.1vh -0.3vh rgba(42, 190, 252, 1);\n    background: rgb(230, 230, 230);\n}\n\n.entry:hover:not(.entry-focus) {\n    box-shadow: inset 0 0.6vh 0.1vh -0.3vh rgba(252, 104, 42, 0.60);\n    background: rgb(210, 210, 210);\n    transition: all 150ms linear;\n}\n\n.menu-button {\n    min-height: 3vh;\n    height: 3vh;\n    min-width: 3vh;\n    width: 3vh;\n    margin: 0.3vh;\n    transition: all 200ms ease-in-out;\n    position: relative;\n}\n\n.menu-button.config {\n    background: url(/assets/menu.svg) no-repeat center;\n    background-size: 0.5vh 3.1vh;\n}\n\n.menu-button.apps {\n    background: url(/assets/menu-apps.svg) no-repeat center;\n    background-size: 1.3vh 1.3vh;\n}\n\n.menu-button:hover {\n    border-radius: 0.5vh;\n    background-color: rgb(215, 215, 215);\n    box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.75);\n}\n\n.menu-button-active {\n    border-radius: 0.5vh;\n    box-shadow: 0 0 1px 0 rgba(0, 0, 0, 0.75);\n}\n\n.menu-button-active.config {\n    background: rgb(220, 220, 220) url(/assets/menu-active.svg) no-repeat center;\n    background-size: 2.5vh 3vh;\n}\n\n.menu-button-active.apps {\n    background: rgb(220, 220, 220) url(/assets/menu-apps-active.svg) no-repeat center;\n    background-size: 2.4vh 2.4vh;\n}\n\n.menu {\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    right: 0.5vh;\n    top: 4.5vh;\n\n    border-radius: 0.5vh;\n    opacity: 0;\n    background: rgb(210, 210, 210);\n    box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75);\n\n    transition: all 200ms ease-in-out;\n\n    pointer-events: auto;\n}\n\n.menu.config {\n    width: 42vh;\n    height: calc(100% - 6vh);\n}\n\n.menu.apps {\n    width: 42vh;\n    height: 41vh;\n}\n\n.menu-active {\n    opacity: 1;\n    transition: all 200ms ease-in-out;\n}\n\n.menu-container {\n    position: fixed;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 65534;\n    visibility: hidden;\n    pointer-events: none;\n}\n\n.menu-triangle-up {\n    position: absolute;\n    top: 3.1vh;\n    width: 0;\n    height: 0;\n    z-index: 65535;\n    border-left: 1vh solid transparent;\n    border-right: 1vh solid transparent;\n\n    border-bottom: 1.4vh solid rgb(210, 210, 210);\n}\n\n.menu-triangle-up.config {\n    right: 0.7vh;\n}\n\n.menu-triangle-up.apps {\n    right: 4.5vh;\n}\n\n.search-container {\n    margin: 2vh;\n    display: flex;\n\n    border-radius: 2vh;\n    background: rgb(150, 150, 150);\n}\n\n.search-icon {\n    margin: 0.25vh;\n    min-height: 2vh;\n    height: 2vh;\n    min-width: 2vh;\n    width: 2vh;\n\n    background: url(/assets/search.svg) no-repeat center;\n    background-size: 2vh 2vh;\n}\n\n.search-input {\n    background: transparent;\n    width: 100%;\n    outline-style: none;\n    box-shadow: none;\n    border-color: transparent;\n    font-family: sans-serif;\n    color: white;\n}\n\ninput::placeholder {\n    color: white;\n    opacity: 1;\n}\n\n.app-menu-item {\n    display: flex;\n    flex-direction: column;\n\n    width: 9vh;\n    margin: 1vh;\n    padding: 1vh;\n}\n\n.app-menu-item:hover, .app-menu-item.search-match {\n    border-radius: 0.5vh;\n    box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.75);\n    background: rgb(220, 220, 220);\n    transition: all 200ms ease-in-out;\n}\n\n.app-menu-item img {\n    width: 9vh;\n    height: 9vh;\n}\n\n.app-menu-item .name {\n    text-align: center;\n\n    font-family: sans-serif;\n    vertical-align: middle;\n    line-height: 2vh;\n    color: black;\n}\n\n.app-menu-item-container {\n    display: flex;\n    flex-wrap: wrap;\n    overflow-y: auto;\n    scroll-behavior: smooth;\n}\n\n", ""]);

// exports


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DesktopShellAppMenu; });
/* harmony import */ var _DesktopShellAppMenuItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);




class DesktopShellAppMenu {
  /**
   * @param {Session}session
   * @return {DesktopShellAppMenu}
   */
  static create (session) {
    const divElementAppMenuButton = this._createDivElementAppMenuButton()
    const divElementAppMenuContainer = this._createDivElementAppMenuContainer()
    const divElementAppMenu = this._createDivElementAppMenu()
    const divElementAppMenuAppsContainer = this._createDivElementAppMenuAppsContainer()

    divElementAppMenuContainer.appendChild(divElementAppMenu)
    const searchBar = this._createSearchBar(divElementAppMenuContainer)
    divElementAppMenu.appendChild(searchBar.divElementSearchContainer)
    divElementAppMenu.appendChild(divElementAppMenuAppsContainer)

    const desktopShellAppMenu = new DesktopShellAppMenu(divElementAppMenuButton, divElementAppMenuContainer, divElementAppMenu, searchBar, divElementAppMenuAppsContainer, session)

    // event listeners
    this._addEventListeners(desktopShellAppMenu)
    desktopShellAppMenu._setupWebsocketConnection(session)

    return desktopShellAppMenu
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementAppMenuButton () {
    const divElementMenuButton = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuButton.classList.add('menu-button')
    divElementMenuButton.classList.add('apps')
    return divElementMenuButton
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementAppMenuContainer () {
    const divElementMenuContainer = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuContainer.classList.add('menu-container')
    divElementMenuContainer.classList.add('apps')
    window.document.body.appendChild(divElementMenuContainer)

    const divElementMenuTriangleUp = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenuTriangleUp.classList.add('menu-triangle-up')
    divElementMenuTriangleUp.classList.add('apps')
    divElementMenuContainer.appendChild(divElementMenuTriangleUp)

    return divElementMenuContainer
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementAppMenu () {
    const divElementMenu = /** @type {HTMLDivElement} */document.createElement('div')
    divElementMenu.classList.add('menu')
    divElementMenu.classList.add('apps')
    return divElementMenu
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementAppMenuAppsContainer () {
    const divElementAppsContainer = /** @type {HTMLDivElement} */document.createElement('div')
    divElementAppsContainer.classList.add('app-menu-item-container')
    return divElementAppsContainer
  }

  /**
   * @param {HTMLDivElement}divElementAppMenuContainer
   * @return {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}
   * @private
   */
  static _createSearchBar (divElementAppMenuContainer) {
    const divElementSearchContainer = /** @type {HTMLDivElement} */document.createElement('div')
    const divElementSearchIcon = /** @type {HTMLDivElement} */ document.createElement('div')
    const inputElementSearchInput = /** @type {HTMLDivElement} */document.createElement('input')

    inputElementSearchInput.setAttribute('type', 'text')
    inputElementSearchInput.setAttribute('name', 'search')
    inputElementSearchInput.setAttribute('placeholder', '...')

    divElementSearchContainer.appendChild(divElementSearchIcon)
    divElementSearchContainer.appendChild(inputElementSearchInput)

    divElementSearchContainer.classList.add('search-container')
    divElementSearchIcon.classList.add('search-icon')
    inputElementSearchInput.classList.add('search-input')

    return {
      divElementSearchContainer: divElementSearchContainer,
      divElementSearchIcon: divElementSearchIcon,
      inputElementSearchInput: inputElementSearchInput
    }
  }

  /**
   * @param {DesktopShellAppMenu}desktopShellAppMenu
   * @private
   */
  static _addEventListeners (desktopShellAppMenu) {
    desktopShellAppMenu.divElementAppMenuButton.addEventListener('mousedown', () => {
      desktopShellAppMenu.showMenu()
    })
    window.document.addEventListener('mousedown', (event) => {
      // FIXME Find a better way.
      if (event.target !== desktopShellAppMenu.divElementAppMenu &&
        event.target !== desktopShellAppMenu.divElementAppMenuButton &&
        event.target !== desktopShellAppMenu.searchBar.inputElementSearchInput &&
        event.target !== desktopShellAppMenu.searchBar.divElementSearchContainer &&
        event.target !== desktopShellAppMenu.searchBar.divElementSearchIcon) {
        desktopShellAppMenu.hideMenu()
      }
    })
    desktopShellAppMenu.searchBar.inputElementSearchInput.addEventListener('input', () => {
      const searchText = desktopShellAppMenu.searchBar.inputElementSearchInput.value
      desktopShellAppMenu._desktopShellAppMenuItems.forEach((desktopShellAppMenuItem) => {
        desktopShellAppMenuItem.divElementItem.classList.remove('search-match')
      })
      if (searchText) {
        for (const desktopShellAppMenuItem of desktopShellAppMenu._desktopShellAppMenuItems) {
          const candidateString = `${desktopShellAppMenuItem.name}`
          if (candidateString.toLowerCase().includes(searchText.toLowerCase())) {
            desktopShellAppMenuItem.divElementItem.classList.add('search-match')
            desktopShellAppMenuItem.divElementItem.scrollIntoView({block: 'end', behavior: 'smooth'})
            break
          }
        }
      }
      // TODO let enter launch found application
      // TODO let escape close the menu
    })
  }

  /**
   * @param {HTMLDivElement}divElementAppMenuButton
   * @param {HTMLDivElement}divElementAppMenuContainer
   * @param {HTMLDivElement}divElementAppMenu
   * @param {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}searchBar
   * @param {HTMLDivElement}divElementAppMenuAppsContainer
   * @param {Session}session
   */
  constructor (divElementAppMenuButton, divElementAppMenuContainer, divElementAppMenu, searchBar, divElementAppMenuAppsContainer, session) {
    /**
     * @type {HTMLDivElement}
     */
    this.divElementAppMenuButton = divElementAppMenuButton
    /**
     * @type {HTMLDivElement}
     */
    this.divElementAppMenuContainer = divElementAppMenuContainer
    /**
     * @type {HTMLDivElement}
     */
    this.divElementAppMenu = divElementAppMenu
    /**
     * @type {{divElementSearchContainer: HTMLDivElement, divElementSearchIcon: HTMLDivElement, inputElementSearchInput: HTMLInputElement}}
     */
    this.searchBar = searchBar
    /**
     * @type {HTMLDivElement}
     */
    this.divElementAppMenuAppsContainer = divElementAppMenuAppsContainer
    /**
     * @type {Session}
     * @private
     */
    this._session = session
    /**
     * @type {WebSocket}
     * @private
     */
    this._ws = null
    /**
     * @type {DesktopShellAppMenuItem[]}
     * @private
     */
    this._desktopShellAppMenuItems = []
  }

  /**
   * @param {Session}session
   * @private
   */
  _setupWebsocketConnection (session) {
    const sessionId = session.compositorSessionId
    const websocketProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws'
    const url = `${websocketProtocol}://${window.location.host}/${sessionId}/apps`

    const ws = new WebSocket(url)
    ws.onerror = () => {
      console.error(`Apps web socket is in error.`)
    }

    ws.onclose = (event) => {
      false && console.log(`Apps web socket is closed: ${event.code}: ${event.reason}`)
    }

    ws.onopen = () => {
      false && console.log('Apps web socket is open.')
      this._setupWebsocket(ws)
      ws.send(JSON.stringify({
        action: '_query',
        data: ''
      }))
    }
    this._ws = ws
  }

  _setupWebsocket (ws) {
    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data)
        const action = message.action
        this[action](message.data)
      } catch (error) {
        console.trace(`Apps web socket failed to handle incoming message: $${JSON.stringify(event)}\n${event.message}\n${error.stack}`)
        ws.close(4007, 'Apps web socket received an illegal message')
      }
    }
  }

  /**
   * Dynamically called by ws.onmessage, as specified by the action property in the received message.
   * @param {{ executable:string, name: string, description: string, icon: string }[]}appsList
   * @private
   */
  _query (appsList) {
    this._desktopShellAppMenuItems.forEach((desktopShellAppMenuItem) => {
      if (desktopShellAppMenuItem.divElementItem.parentElement) {
        desktopShellAppMenuItem.divElementItem.parentElement.removeChild(desktopShellAppMenuItem.divElementItem)
      }
    })
    this._desktopShellAppMenuItems = []
    appsList.forEach((appDescription) => {
      const executable = appDescription.executable
      const name = appDescription.name
      const description = appDescription.description
      const iconPath = appDescription.icon
      const iconUrl = `${window.location.protocol}/${iconPath}`

      const desktopShellAppMenuItem = _DesktopShellAppMenuItem__WEBPACK_IMPORTED_MODULE_0__["default"].create(this._ws, executable, iconUrl, name, description)
      this._desktopShellAppMenuItems.push(desktopShellAppMenuItem)
      this.divElementAppMenuAppsContainer.appendChild(desktopShellAppMenuItem.divElementItem)
    })
  }

  showMenu () {
    this.divElementAppMenuContainer.addEventListener('transitionend', () => {
      this.searchBar.inputElementSearchInput.classList.add('enable-default')
      this.searchBar.inputElementSearchInput.focus()
    })

    this.divElementAppMenuContainer.style.visibility = 'visible'
    this.divElementAppMenu.classList.add('menu-active')
    this.divElementAppMenuButton.classList.add('menu-button-active')
  }

  hideMenu () {
    this.searchBar.inputElementSearchInput.blur()
    this.searchBar.inputElementSearchInput.classList.remove('enable-default')
    this.searchBar.inputElementSearchInput.value = ''

    this.divElementAppMenuContainer.style.visibility = 'hidden'
    this.divElementAppMenu.classList.remove('menu-active')
    this.divElementAppMenuButton.classList.remove('menu-button-active')
  }
}


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DesktopShellAppMenuItem; });


class DesktopShellAppMenuItem {
  /**
   * @param {WebSocket}ws
   * @param {string}executable
   * @param {string}iconUrl
   * @param {string}name
   * @param {string}description
   * @return {DesktopShellAppMenuItem}
   */
  static create (ws, executable, iconUrl, name, description) {
    const divElementItem = this._createDivElementItem(description)
    const imageElementIcon = this._createImageElementIcon(iconUrl)
    const divElementName = this._createDivElementName(name)
    divElementItem.appendChild(imageElementIcon)
    divElementItem.appendChild(divElementName)

    this._setupEventHandlers(ws, divElementItem, executable)
    return new DesktopShellAppMenuItem(divElementItem, name)
  }

  /**
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementItem (description) {
    const divElementItem = /** @type {HTMLDivElement} */document.createElement('div')
    divElementItem.setAttribute('title', description)
    divElementItem.classList.add('app-menu-item')

    return divElementItem
  }

  /**
   * @param {string}iconUrl
   * @return {HTMLImageElement}
   * @private
   */
  static _createImageElementIcon (iconUrl) {
    const imageElementIcon = new Image()
    imageElementIcon.src = iconUrl

    return imageElementIcon
  }

  /**
   * @param {string}name
   * @return {HTMLDivElement}
   * @private
   */
  static _createDivElementName (name) {
    const divElementName = /** @type {HTMLDivElement} */document.createElement('div')
    divElementName.classList.add('name')
    divElementName.textContent = name

    return divElementName
  }

  /**
   * @param {WebSocket}ws
   * @param {HTMLDivElement}itemDiv
   * @param {string}executable
   * @private
   */
  static _setupEventHandlers (ws, itemDiv, executable) {
    itemDiv.addEventListener('mousedown', () => {
      ws.send(JSON.stringify({
        action: '_launch',
        data: executable
      }))
    })
  }

  /**
   * @param {HTMLDivElement}divElementItem
   * @param {string}name
   */
  constructor (divElementItem, name) {
    /**
     * @type {HTMLDivElement}
     */
    this.divElementItem = divElementItem
    /**
     * @type {string}
     */
    this.name = name
  }
}


/***/ })
/******/ ]);