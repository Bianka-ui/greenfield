
var Module = (function () {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined
  return (
    function (Module) {
      Module = Module || {}

      var Module = typeof Module !== 'undefined' ? Module : {}; if (!Module.expectedDataFileDownloads) { Module.expectedDataFileDownloads = 0; Module.finishedDataFileDownloads = 0 }Module.expectedDataFileDownloads++; (function () { var loadPackage = function (metadata) { var PACKAGE_PATH; if (typeof window === 'object') { PACKAGE_PATH = window.encodeURIComponent(window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/') } else if (typeof location !== 'undefined') { PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/') } else { throw 'using preloaded data can only be done on a web page or in a web worker' } var PACKAGE_NAME = '../libxkbcommon.data'; var REMOTE_PACKAGE_BASE = 'libxkbcommon.data'; if (typeof Module.locateFilePackage === 'function' && !Module.locateFile) { Module.locateFile = Module.locateFilePackage; err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)') } var REMOTE_PACKAGE_NAME = Module.locateFile ? Module.locateFile(REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE; var REMOTE_PACKAGE_SIZE = metadata.remote_package_size; var PACKAGE_UUID = metadata.package_uuid; function fetchRemotePackage (packageName, packageSize, callback, errback) { var xhr = new XMLHttpRequest(); xhr.open('GET', packageName, true); xhr.responseType = 'arraybuffer'; xhr.onprogress = function (event) { var url = packageName; var size = packageSize; if (event.total)size = event.total; if (event.loaded) { if (!xhr.addedTotal) { xhr.addedTotal = true; if (!Module.dataFileDownloads)Module.dataFileDownloads = {}; Module.dataFileDownloads[url] = { loaded: event.loaded, total: size } } else { Module.dataFileDownloads[url].loaded = event.loaded } var total = 0; var loaded = 0; var num = 0; for (var download in Module.dataFileDownloads) { var data = Module.dataFileDownloads[download]; total += data.total; loaded += data.loaded; num++ }total = Math.ceil(total * Module.expectedDataFileDownloads / num); if (Module.setStatus)Module.setStatus('Downloading data... (' + loaded + '/' + total + ')') } else if (!Module.dataFileDownloads) { if (Module.setStatus)Module.setStatus('Downloading data...') } }; xhr.onerror = function (event) { throw new Error('NetworkError for: ' + packageName) }; xhr.onload = function (event) { if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) { var packageData = xhr.response; callback(packageData) } else { throw new Error(xhr.statusText + ' : ' + xhr.responseURL) } }; xhr.send(null) } function handleError (error) { console.error('package error:', error) } var fetchedCallback = null; var fetched = Module.getPreloadedPackage ? Module.getPreloadedPackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null; if (!fetched)fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function (data) { if (fetchedCallback) { fetchedCallback(data); fetchedCallback = null } else { fetched = data } }, handleError); function runWithFS () { function assert (check, msg) { if (!check) throw msg + (new Error()).stack }Module.FS_createPath('/', 'usr', true, true); Module.FS_createPath('/usr', 'local', true, true); Module.FS_createPath('/usr/local', 'share', true, true); Module.FS_createPath('/usr/local/share', 'X11', true, true); Module.FS_createPath('/usr/local/share/X11', 'xkb', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'keycodes', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/keycodes', 'sgi_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/keycodes', 'digital_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'symbols', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'sgi_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'sony_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'macintosh_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'hp_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'digital_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'xfree68_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'fujitsu_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'sharp_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'nokia_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'sun_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'nec_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/symbols', 'jolla_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'compat', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'rules', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'types', true, true); Module.FS_createPath('/usr/local/share/X11/xkb', 'geometry', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/geometry', 'sgi_vndr', true, true); Module.FS_createPath('/usr/local/share/X11/xkb/geometry', 'digital_vndr', true, true); function DataRequest (start, end, audio) { this.start = start; this.end = end; this.audio = audio }DataRequest.prototype = { requests: {}, open: function (mode, name) { this.name = name; this.requests[name] = this; Module.addRunDependency('fp ' + this.name) }, send: function () {}, onload: function () { var byteArray = this.byteArray.subarray(this.start, this.end); this.finish(byteArray) }, finish: function (byteArray) { var that = this; Module.FS_createDataFile(this.name, null, byteArray, true, true, true); Module.removeRunDependency('fp ' + that.name); this.requests[this.name] = null } }; var files = metadata.files; for (var i = 0; i < files.length; ++i) { new DataRequest(files[i].start, files[i].end, files[i].audio).open('GET', files[i].filename) } function processPackageData (arrayBuffer) { Module.finishedDataFileDownloads++; assert(arrayBuffer, 'Loading data file failed.'); assert(arrayBuffer instanceof ArrayBuffer, 'bad input to processPackageData'); var byteArray = new Uint8Array(arrayBuffer); var ptr = Module.getMemory(byteArray.length); Module.HEAPU8.set(byteArray, ptr); DataRequest.prototype.byteArray = Module.HEAPU8.subarray(ptr, ptr + byteArray.length); var files = metadata.files; for (var i = 0; i < files.length; ++i) { DataRequest.prototype.requests[files[i].filename].onload() }Module.removeRunDependency('datafile_../libxkbcommon.data') }Module.addRunDependency('datafile_../libxkbcommon.data'); if (!Module.preloadResults)Module.preloadResults = {}; Module.preloadResults[PACKAGE_NAME] = { fromCache: false }; if (fetched) { processPackageData(fetched); fetched = null } else { fetchedCallback = processPackageData } } if (Module.calledRun) { runWithFS() } else { if (!Module.preRun)Module.preRun = []; Module.preRun.push(runWithFS) } }; loadPackage({ files: [{ start: 0, audio: 0, end: 283, filename: '/usr/local/share/X11/xkb/keycodes/jolla' }, { start: 283, audio: 0, end: 3998, filename: '/usr/local/share/X11/xkb/keycodes/fujitsu' }, { start: 3998, audio: 0, end: 9074, filename: '/usr/local/share/X11/xkb/keycodes/sun' }, { start: 9074, audio: 0, end: 12220, filename: '/usr/local/share/X11/xkb/keycodes/ibm' }, { start: 12220, audio: 0, end: 16686, filename: '/usr/local/share/X11/xkb/keycodes/macintosh' }, { start: 16686, audio: 0, end: 21657, filename: '/usr/local/share/X11/xkb/keycodes/hp' }, { start: 21657, audio: 0, end: 30291, filename: '/usr/local/share/X11/xkb/keycodes/xfree86' }, { start: 30291, audio: 0, end: 30359, filename: '/usr/local/share/X11/xkb/keycodes/empty' }, { start: 30359, audio: 0, end: 32198, filename: '/usr/local/share/X11/xkb/keycodes/ataritt' }, { start: 32198, audio: 0, end: 35599, filename: '/usr/local/share/X11/xkb/keycodes/amiga' }, { start: 35599, audio: 0, end: 36361, filename: '/usr/local/share/X11/xkb/keycodes/olpc' }, { start: 36361, audio: 0, end: 38537, filename: '/usr/local/share/X11/xkb/keycodes/aliases' }, { start: 38537, audio: 0, end: 38953, filename: '/usr/local/share/X11/xkb/keycodes/README' }, { start: 38953, audio: 0, end: 42157, filename: '/usr/local/share/X11/xkb/keycodes/xfree98' }, { start: 42157, audio: 0, end: 51090, filename: '/usr/local/share/X11/xkb/keycodes/evdev' }, { start: 51090, audio: 0, end: 54044, filename: '/usr/local/share/X11/xkb/keycodes/sony' }, { start: 54044, audio: 0, end: 57727, filename: '/usr/local/share/X11/xkb/keycodes/sgi_vndr/indy' }, { start: 57727, audio: 0, end: 60038, filename: '/usr/local/share/X11/xkb/keycodes/sgi_vndr/indigo' }, { start: 60038, audio: 0, end: 60298, filename: '/usr/local/share/X11/xkb/keycodes/sgi_vndr/iris' }, { start: 60298, audio: 0, end: 66431, filename: '/usr/local/share/X11/xkb/keycodes/digital_vndr/lk' }, { start: 66431, audio: 0, end: 72533, filename: '/usr/local/share/X11/xkb/keycodes/digital_vndr/pc' }, { start: 72533, audio: 0, end: 84514, filename: '/usr/local/share/X11/xkb/symbols/group' }, { start: 84514, audio: 0, end: 92146, filename: '/usr/local/share/X11/xkb/symbols/epo' }, { start: 92146, audio: 0, end: 140453, filename: '/usr/local/share/X11/xkb/symbols/apl' }, { start: 140453, audio: 0, end: 145569, filename: '/usr/local/share/X11/xkb/symbols/md' }, { start: 145569, audio: 0, end: 147316, filename: '/usr/local/share/X11/xkb/symbols/me' }, { start: 147316, audio: 0, end: 147447, filename: '/usr/local/share/X11/xkb/symbols/rupeesign' }, { start: 147447, audio: 0, end: 155668, filename: '/usr/local/share/X11/xkb/symbols/lk' }, { start: 155668, audio: 0, end: 161748, filename: '/usr/local/share/X11/xkb/symbols/kg' }, { start: 161748, audio: 0, end: 163079, filename: '/usr/local/share/X11/xkb/symbols/tm' }, { start: 163079, audio: 0, end: 167677, filename: '/usr/local/share/X11/xkb/symbols/bt' }, { start: 167677, audio: 0, end: 171953, filename: '/usr/local/share/X11/xkb/symbols/typo' }, { start: 171953, audio: 0, end: 174256, filename: '/usr/local/share/X11/xkb/symbols/compose' }, { start: 174256, audio: 0, end: 207874, filename: '/usr/local/share/X11/xkb/symbols/ara' }, { start: 207874, audio: 0, end: 208503, filename: '/usr/local/share/X11/xkb/symbols/eurosign' }, { start: 208503, audio: 0, end: 209484, filename: '/usr/local/share/X11/xkb/symbols/bw' }, { start: 209484, audio: 0, end: 211995, filename: '/usr/local/share/X11/xkb/symbols/brai' }, { start: 211995, audio: 0, end: 224429, filename: '/usr/local/share/X11/xkb/symbols/ir' }, { start: 224429, audio: 0, end: 226429, filename: '/usr/local/share/X11/xkb/symbols/capslock' }, { start: 226429, audio: 0, end: 236817, filename: '/usr/local/share/X11/xkb/symbols/tj' }, { start: 236817, audio: 0, end: 274125, filename: '/usr/local/share/X11/xkb/symbols/cn' }, { start: 274125, audio: 0, end: 280934, filename: '/usr/local/share/X11/xkb/symbols/np' }, { start: 280934, audio: 0, end: 285081, filename: '/usr/local/share/X11/xkb/symbols/ee' }, { start: 285081, audio: 0, end: 306601, filename: '/usr/local/share/X11/xkb/symbols/ca' }, { start: 306601, audio: 0, end: 314892, filename: '/usr/local/share/X11/xkb/symbols/ch' }, { start: 314892, audio: 0, end: 409756, filename: '/usr/local/share/X11/xkb/symbols/in' }, { start: 409756, audio: 0, end: 420104, filename: '/usr/local/share/X11/xkb/symbols/am' }, { start: 420104, audio: 0, end: 422213, filename: '/usr/local/share/X11/xkb/symbols/za' }, { start: 422213, audio: 0, end: 425886, filename: '/usr/local/share/X11/xkb/symbols/ctrl' }, { start: 425886, audio: 0, end: 440224, filename: '/usr/local/share/X11/xkb/symbols/gr' }, { start: 440224, audio: 0, end: 446409, filename: '/usr/local/share/X11/xkb/symbols/al' }, { start: 446409, audio: 0, end: 450700, filename: '/usr/local/share/X11/xkb/symbols/bd' }, { start: 450700, audio: 0, end: 470977, filename: '/usr/local/share/X11/xkb/symbols/ie' }, { start: 470977, audio: 0, end: 475974, filename: '/usr/local/share/X11/xkb/symbols/kh' }, { start: 475974, audio: 0, end: 493835, filename: '/usr/local/share/X11/xkb/symbols/it' }, { start: 493835, audio: 0, end: 506345, filename: '/usr/local/share/X11/xkb/symbols/ma' }, { start: 506345, audio: 0, end: 506939, filename: '/usr/local/share/X11/xkb/symbols/mao' }, { start: 506939, audio: 0, end: 510073, filename: '/usr/local/share/X11/xkb/symbols/et' }, { start: 510073, audio: 0, end: 515661, filename: '/usr/local/share/X11/xkb/symbols/la' }, { start: 515661, audio: 0, end: 534674, filename: '/usr/local/share/X11/xkb/symbols/lv' }, { start: 534674, audio: 0, end: 539979, filename: '/usr/local/share/X11/xkb/symbols/eu' }, { start: 539979, audio: 0, end: 542219, filename: '/usr/local/share/X11/xkb/symbols/shift' }, { start: 542219, audio: 0, end: 542398, filename: '/usr/local/share/X11/xkb/symbols/au' }, { start: 542398, audio: 0, end: 544618, filename: '/usr/local/share/X11/xkb/symbols/sn' }, { start: 544618, audio: 0, end: 556394, filename: '/usr/local/share/X11/xkb/symbols/no' }, { start: 556394, audio: 0, end: 557562, filename: '/usr/local/share/X11/xkb/symbols/kr' }, { start: 557562, audio: 0, end: 563597, filename: '/usr/local/share/X11/xkb/symbols/vn' }, { start: 563597, audio: 0, end: 577826, filename: '/usr/local/share/X11/xkb/symbols/latam' }, { start: 577826, audio: 0, end: 602013, filename: '/usr/local/share/X11/xkb/symbols/cz' }, { start: 602013, audio: 0, end: 602402, filename: '/usr/local/share/X11/xkb/symbols/parens' }, { start: 602402, audio: 0, end: 619327, filename: '/usr/local/share/X11/xkb/symbols/lt' }, { start: 619327, audio: 0, end: 633964, filename: '/usr/local/share/X11/xkb/symbols/latin' }, { start: 633964, audio: 0, end: 637293, filename: '/usr/local/share/X11/xkb/symbols/ml' }, { start: 637293, audio: 0, end: 655455, filename: '/usr/local/share/X11/xkb/symbols/bg' }, { start: 655455, audio: 0, end: 671711, filename: '/usr/local/share/X11/xkb/symbols/il' }, { start: 671711, audio: 0, end: 680173, filename: '/usr/local/share/X11/xkb/symbols/jp' }, { start: 680173, audio: 0, end: 696573, filename: '/usr/local/share/X11/xkb/symbols/kz' }, { start: 696573, audio: 0, end: 700358, filename: '/usr/local/share/X11/xkb/symbols/az' }, { start: 700358, audio: 0, end: 702715, filename: '/usr/local/share/X11/xkb/symbols/gn' }, { start: 702715, audio: 0, end: 718803, filename: '/usr/local/share/X11/xkb/symbols/ua' }, { start: 718803, audio: 0, end: 735623, filename: '/usr/local/share/X11/xkb/symbols/br' }, { start: 735623, audio: 0, end: 748415, filename: '/usr/local/share/X11/xkb/symbols/be' }, { start: 748415, audio: 0, end: 815380, filename: '/usr/local/share/X11/xkb/symbols/ru' }, { start: 815380, audio: 0, end: 826150, filename: '/usr/local/share/X11/xkb/symbols/dz' }, { start: 826150, audio: 0, end: 849908, filename: '/usr/local/share/X11/xkb/symbols/keypad' }, { start: 849908, audio: 0, end: 937960, filename: '/usr/local/share/X11/xkb/symbols/de' }, { start: 937960, audio: 0, end: 958018, filename: '/usr/local/share/X11/xkb/symbols/hu' }, { start: 958018, audio: 0, end: 962842, filename: '/usr/local/share/X11/xkb/symbols/tg' }, { start: 962842, audio: 0, end: 965231, filename: '/usr/local/share/X11/xkb/symbols/pc' }, { start: 965231, audio: 0, end: 968660, filename: '/usr/local/share/X11/xkb/symbols/tz' }, { start: 968660, audio: 0, end: 969224, filename: '/usr/local/share/X11/xkb/symbols/at' }, { start: 969224, audio: 0, end: 979620, filename: '/usr/local/share/X11/xkb/symbols/th' }, { start: 979620, audio: 0, end: 1055600, filename: '/usr/local/share/X11/xkb/symbols/ph' }, { start: 1055600, audio: 0, end: 1154408, filename: '/usr/local/share/X11/xkb/symbols/fr' }, { start: 1154408, audio: 0, end: 1154509, filename: '/usr/local/share/X11/xkb/symbols/empty' }, { start: 1154509, audio: 0, end: 1165772, filename: '/usr/local/share/X11/xkb/symbols/ro' }, { start: 1165772, audio: 0, end: 1167945, filename: '/usr/local/share/X11/xkb/symbols/ke' }, { start: 1167945, audio: 0, end: 1171042, filename: '/usr/local/share/X11/xkb/symbols/mk' }, { start: 1171042, audio: 0, end: 1255131, filename: '/usr/local/share/X11/xkb/symbols/us' }, { start: 1255131, audio: 0, end: 1259537, filename: '/usr/local/share/X11/xkb/symbols/nbsp' }, { start: 1259537, audio: 0, end: 1262935, filename: '/usr/local/share/X11/xkb/symbols/kpdl' }, { start: 1262935, audio: 0, end: 1275916, filename: '/usr/local/share/X11/xkb/symbols/ge' }, { start: 1275916, audio: 0, end: 1278409, filename: '/usr/local/share/X11/xkb/symbols/hr' }, { start: 1278409, audio: 0, end: 1287544, filename: '/usr/local/share/X11/xkb/symbols/gb' }, { start: 1287544, audio: 0, end: 1297791, filename: '/usr/local/share/X11/xkb/symbols/es' }, { start: 1297791, audio: 0, end: 1310613, filename: '/usr/local/share/X11/xkb/symbols/pt' }, { start: 1310613, audio: 0, end: 1317501, filename: '/usr/local/share/X11/xkb/symbols/nl' }, { start: 1317501, audio: 0, end: 1334526, filename: '/usr/local/share/X11/xkb/symbols/tr' }, { start: 1334526, audio: 0, end: 1335168, filename: '/usr/local/share/X11/xkb/symbols/iq' }, { start: 1335168, audio: 0, end: 1338560, filename: '/usr/local/share/X11/xkb/symbols/mv' }, { start: 1338560, audio: 0, end: 1339490, filename: '/usr/local/share/X11/xkb/symbols/olpc' }, { start: 1339490, audio: 0, end: 1403836, filename: '/usr/local/share/X11/xkb/symbols/inet' }, { start: 1403836, audio: 0, end: 1406167, filename: '/usr/local/share/X11/xkb/symbols/srvr_ctrl' }, { start: 1406167, audio: 0, end: 1406782, filename: '/usr/local/share/X11/xkb/symbols/si' }, { start: 1406782, audio: 0, end: 1413490, filename: '/usr/local/share/X11/xkb/symbols/id' }, { start: 1413490, audio: 0, end: 1439050, filename: '/usr/local/share/X11/xkb/symbols/pl' }, { start: 1439050, audio: 0, end: 1439730, filename: '/usr/local/share/X11/xkb/symbols/ba' }, { start: 1439730, audio: 0, end: 1445058, filename: '/usr/local/share/X11/xkb/symbols/sk' }, { start: 1445058, audio: 0, end: 1468443, filename: '/usr/local/share/X11/xkb/symbols/af' }, { start: 1468443, audio: 0, end: 1483090, filename: '/usr/local/share/X11/xkb/symbols/is' }, { start: 1483090, audio: 0, end: 1500177, filename: '/usr/local/share/X11/xkb/symbols/se' }, { start: 1500177, audio: 0, end: 1504916, filename: '/usr/local/share/X11/xkb/symbols/level5' }, { start: 1504916, audio: 0, end: 1508402, filename: '/usr/local/share/X11/xkb/symbols/altwin' }, { start: 1508402, audio: 0, end: 1510392, filename: '/usr/local/share/X11/xkb/symbols/fo' }, { start: 1510392, audio: 0, end: 1517383, filename: '/usr/local/share/X11/xkb/symbols/my' }, { start: 1517383, audio: 0, end: 1523949, filename: '/usr/local/share/X11/xkb/symbols/gh' }, { start: 1523949, audio: 0, end: 1530219, filename: '/usr/local/share/X11/xkb/symbols/ng' }, { start: 1530219, audio: 0, end: 1532278, filename: '/usr/local/share/X11/xkb/symbols/by' }, { start: 1532278, audio: 0, end: 1536552, filename: '/usr/local/share/X11/xkb/symbols/mn' }, { start: 1536552, audio: 0, end: 1557213, filename: '/usr/local/share/X11/xkb/symbols/pk' }, { start: 1557213, audio: 0, end: 1563769, filename: '/usr/local/share/X11/xkb/symbols/level3' }, { start: 1563769, audio: 0, end: 1588168, filename: '/usr/local/share/X11/xkb/symbols/fi' }, { start: 1588168, audio: 0, end: 1595245, filename: '/usr/local/share/X11/xkb/symbols/sy' }, { start: 1595245, audio: 0, end: 1597768, filename: '/usr/local/share/X11/xkb/symbols/dk' }, { start: 1597768, audio: 0, end: 1613130, filename: '/usr/local/share/X11/xkb/symbols/rs' }, { start: 1613130, audio: 0, end: 1613330, filename: '/usr/local/share/X11/xkb/symbols/terminate' }, { start: 1613330, audio: 0, end: 1617456, filename: '/usr/local/share/X11/xkb/symbols/uz' }, { start: 1617456, audio: 0, end: 1621576, filename: '/usr/local/share/X11/xkb/symbols/cd' }, { start: 1621576, audio: 0, end: 1627543, filename: '/usr/local/share/X11/xkb/symbols/mm' }, { start: 1627543, audio: 0, end: 1630849, filename: '/usr/local/share/X11/xkb/symbols/tw' }, { start: 1630849, audio: 0, end: 1646900, filename: '/usr/local/share/X11/xkb/symbols/trans' }, { start: 1646900, audio: 0, end: 1656030, filename: '/usr/local/share/X11/xkb/symbols/mt' }, { start: 1656030, audio: 0, end: 1689824, filename: '/usr/local/share/X11/xkb/symbols/cm' }, { start: 1689824, audio: 0, end: 1691914, filename: '/usr/local/share/X11/xkb/symbols/sgi_vndr/jp' }, { start: 1691914, audio: 0, end: 1694806, filename: '/usr/local/share/X11/xkb/symbols/sony_vndr/us' }, { start: 1694806, audio: 0, end: 1698635, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/ch' }, { start: 1698635, audio: 0, end: 1701377, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/it' }, { start: 1701377, audio: 0, end: 1703495, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/no' }, { start: 1703495, audio: 0, end: 1705408, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/latam' }, { start: 1705408, audio: 0, end: 1706429, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/jp' }, { start: 1706429, audio: 0, end: 1710265, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/de' }, { start: 1710265, audio: 0, end: 1715831, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/fr' }, { start: 1715831, audio: 0, end: 1720051, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/us' }, { start: 1720051, audio: 0, end: 1720608, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/gb' }, { start: 1720608, audio: 0, end: 1723193, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/pt' }, { start: 1723193, audio: 0, end: 1723349, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/nl' }, { start: 1723349, audio: 0, end: 1728454, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/apple' }, { start: 1728454, audio: 0, end: 1734168, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/is' }, { start: 1734168, audio: 0, end: 1736253, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/se' }, { start: 1736253, audio: 0, end: 1736583, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/fi' }, { start: 1736583, audio: 0, end: 1740091, filename: '/usr/local/share/X11/xkb/symbols/macintosh_vndr/dk' }, { start: 1740091, audio: 0, end: 1743412, filename: '/usr/local/share/X11/xkb/symbols/hp_vndr/us' }, { start: 1743412, audio: 0, end: 1747773, filename: '/usr/local/share/X11/xkb/symbols/digital_vndr/lk' }, { start: 1747773, audio: 0, end: 1753235, filename: '/usr/local/share/X11/xkb/symbols/digital_vndr/vt' }, { start: 1753235, audio: 0, end: 1759434, filename: '/usr/local/share/X11/xkb/symbols/digital_vndr/pc' }, { start: 1759434, audio: 0, end: 1767393, filename: '/usr/local/share/X11/xkb/symbols/digital_vndr/us' }, { start: 1767393, audio: 0, end: 1772065, filename: '/usr/local/share/X11/xkb/symbols/xfree68_vndr/ataritt' }, { start: 1772065, audio: 0, end: 1775964, filename: '/usr/local/share/X11/xkb/symbols/xfree68_vndr/amiga' }, { start: 1775964, audio: 0, end: 1780077, filename: '/usr/local/share/X11/xkb/symbols/fujitsu_vndr/jp' }, { start: 1780077, audio: 0, end: 1784468, filename: '/usr/local/share/X11/xkb/symbols/fujitsu_vndr/us' }, { start: 1784468, audio: 0, end: 1786541, filename: '/usr/local/share/X11/xkb/symbols/sharp_vndr/ws011sh' }, { start: 1786541, audio: 0, end: 1788467, filename: '/usr/local/share/X11/xkb/symbols/sharp_vndr/ws007sh' }, { start: 1788467, audio: 0, end: 1790316, filename: '/usr/local/share/X11/xkb/symbols/sharp_vndr/ws020sh' }, { start: 1790316, audio: 0, end: 1792372, filename: '/usr/local/share/X11/xkb/symbols/sharp_vndr/sl-c3x00' }, { start: 1792372, audio: 0, end: 1794298, filename: '/usr/local/share/X11/xkb/symbols/sharp_vndr/ws003sh' }, { start: 1794298, audio: 0, end: 1822215, filename: '/usr/local/share/X11/xkb/symbols/nokia_vndr/su-8w' }, { start: 1822215, audio: 0, end: 1894309, filename: '/usr/local/share/X11/xkb/symbols/nokia_vndr/rx-51' }, { start: 1894309, audio: 0, end: 1909474, filename: '/usr/local/share/X11/xkb/symbols/nokia_vndr/rx-44' }, { start: 1909474, audio: 0, end: 1915735, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ara' }, { start: 1915735, audio: 0, end: 1921554, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ee' }, { start: 1921554, audio: 0, end: 1926605, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ca' }, { start: 1926605, audio: 0, end: 1933232, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ch' }, { start: 1933232, audio: 0, end: 1938508, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/gr' }, { start: 1938508, audio: 0, end: 1942669, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/it' }, { start: 1942669, audio: 0, end: 1949392, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/lv' }, { start: 1949392, audio: 0, end: 1953430, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/no' }, { start: 1953430, audio: 0, end: 1956095, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/kr' }, { start: 1956095, audio: 0, end: 1960777, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/cz' }, { start: 1960777, audio: 0, end: 1966482, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/lt' }, { start: 1966482, audio: 0, end: 1970786, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/solaris' }, { start: 1970786, audio: 0, end: 1977392, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/jp' }, { start: 1977392, audio: 0, end: 1983016, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ua' }, { start: 1983016, audio: 0, end: 1988350, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/br' }, { start: 1988350, audio: 0, end: 1993221, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/be' }, { start: 1993221, audio: 0, end: 1999614, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ru' }, { start: 1999614, audio: 0, end: 2005124, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/de' }, { start: 2005124, audio: 0, end: 2010562, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/fr' }, { start: 2010562, audio: 0, end: 2016619, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/ro' }, { start: 2016619, audio: 0, end: 2021142, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/us' }, { start: 2021142, audio: 0, end: 2023942, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/gb' }, { start: 2023942, audio: 0, end: 2028229, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/es' }, { start: 2028229, audio: 0, end: 2032497, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/pt' }, { start: 2032497, audio: 0, end: 2036720, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/nl' }, { start: 2036720, audio: 0, end: 2040932, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/tr' }, { start: 2040932, audio: 0, end: 2045131, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/pl' }, { start: 2045131, audio: 0, end: 2050325, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/sk' }, { start: 2050325, audio: 0, end: 2054406, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/se' }, { start: 2054406, audio: 0, end: 2058640, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/fi' }, { start: 2058640, audio: 0, end: 2062437, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/dk' }, { start: 2062437, audio: 0, end: 2064623, filename: '/usr/local/share/X11/xkb/symbols/sun_vndr/tw' }, { start: 2064623, audio: 0, end: 2070699, filename: '/usr/local/share/X11/xkb/symbols/nec_vndr/jp' }, { start: 2070699, audio: 0, end: 2072842, filename: '/usr/local/share/X11/xkb/symbols/jolla_vndr/sbj' }, { start: 2072842, audio: 0, end: 2073070, filename: '/usr/local/share/X11/xkb/compat/complete' }, { start: 2073070, audio: 0, end: 2073536, filename: '/usr/local/share/X11/xkb/compat/lednum' }, { start: 2073536, audio: 0, end: 2074005, filename: '/usr/local/share/X11/xkb/compat/ledcaps' }, { start: 2074005, audio: 0, end: 2075126, filename: '/usr/local/share/X11/xkb/compat/accessx' }, { start: 2075126, audio: 0, end: 2075612, filename: '/usr/local/share/X11/xkb/compat/ledscroll' }, { start: 2075612, audio: 0, end: 2075917, filename: '/usr/local/share/X11/xkb/compat/ledcompose' }, { start: 2075917, audio: 0, end: 2077374, filename: '/usr/local/share/X11/xkb/compat/xtest' }, { start: 2077374, audio: 0, end: 2080098, filename: '/usr/local/share/X11/xkb/compat/misc' }, { start: 2080098, audio: 0, end: 2080438, filename: '/usr/local/share/X11/xkb/compat/pc' }, { start: 2080438, audio: 0, end: 2082280, filename: '/usr/local/share/X11/xkb/compat/xfree86' }, { start: 2082280, audio: 0, end: 2082787, filename: '/usr/local/share/X11/xkb/compat/caps' }, { start: 2082787, audio: 0, end: 2087391, filename: '/usr/local/share/X11/xkb/compat/mousekeys' }, { start: 2087391, audio: 0, end: 2088377, filename: '/usr/local/share/X11/xkb/compat/japan' }, { start: 2088377, audio: 0, end: 2089603, filename: '/usr/local/share/X11/xkb/compat/pc98' }, { start: 2089603, audio: 0, end: 2090736, filename: '/usr/local/share/X11/xkb/compat/olpc' }, { start: 2090736, audio: 0, end: 2091790, filename: '/usr/local/share/X11/xkb/compat/basic' }, { start: 2091790, audio: 0, end: 2093502, filename: '/usr/local/share/X11/xkb/compat/README' }, { start: 2093502, audio: 0, end: 2094898, filename: '/usr/local/share/X11/xkb/compat/level5' }, { start: 2094898, audio: 0, end: 2096542, filename: '/usr/local/share/X11/xkb/compat/iso9995' }, { start: 2096542, audio: 0, end: 2144995, filename: '/usr/local/share/X11/xkb/rules/base' }, { start: 2144995, audio: 0, end: 2377465, filename: '/usr/local/share/X11/xkb/rules/base.xml' }, { start: 2377465, audio: 0, end: 2378591, filename: '/usr/local/share/X11/xkb/rules/xkb.dtd' }, { start: 2378591, audio: 0, end: 2424015, filename: '/usr/local/share/X11/xkb/rules/evdev.lst' }, { start: 2424015, audio: 0, end: 2462671, filename: '/usr/local/share/X11/xkb/rules/base.extras.xml' }, { start: 2462671, audio: 0, end: 2695141, filename: '/usr/local/share/X11/xkb/rules/evdev.xml' }, { start: 2695141, audio: 0, end: 2695232, filename: '/usr/local/share/X11/xkb/rules/README' }, { start: 2695232, audio: 0, end: 2695536, filename: '/usr/local/share/X11/xkb/rules/xkb.its' }, { start: 2695536, audio: 0, end: 2696325, filename: '/usr/local/share/X11/xkb/rules/xfree98' }, { start: 2696325, audio: 0, end: 2739806, filename: '/usr/local/share/X11/xkb/rules/evdev' }, { start: 2739806, audio: 0, end: 2785230, filename: '/usr/local/share/X11/xkb/rules/base.lst' }, { start: 2785230, audio: 0, end: 2823886, filename: '/usr/local/share/X11/xkb/rules/evdev.extras.xml' }, { start: 2823886, audio: 0, end: 2824065, filename: '/usr/local/share/X11/xkb/types/complete' }, { start: 2824065, audio: 0, end: 2829502, filename: '/usr/local/share/X11/xkb/types/extra' }, { start: 2829502, audio: 0, end: 2829804, filename: '/usr/local/share/X11/xkb/types/nokia' }, { start: 2829804, audio: 0, end: 2830035, filename: '/usr/local/share/X11/xkb/types/cancel' }, { start: 2830035, audio: 0, end: 2830213, filename: '/usr/local/share/X11/xkb/types/default' }, { start: 2830213, audio: 0, end: 2833566, filename: '/usr/local/share/X11/xkb/types/pc' }, { start: 2833566, audio: 0, end: 2835521, filename: '/usr/local/share/X11/xkb/types/numpad' }, { start: 2835521, audio: 0, end: 2840043, filename: '/usr/local/share/X11/xkb/types/caps' }, { start: 2840043, audio: 0, end: 2840257, filename: '/usr/local/share/X11/xkb/types/mousekeys' }, { start: 2840257, audio: 0, end: 2840864, filename: '/usr/local/share/X11/xkb/types/basic' }, { start: 2840864, audio: 0, end: 2841110, filename: '/usr/local/share/X11/xkb/types/README' }, { start: 2841110, audio: 0, end: 2849329, filename: '/usr/local/share/X11/xkb/types/level5' }, { start: 2849329, audio: 0, end: 2849758, filename: '/usr/local/share/X11/xkb/types/iso9995' }, { start: 2849758, audio: 0, end: 2859486, filename: '/usr/local/share/X11/xkb/geometry/teck' }, { start: 2859486, audio: 0, end: 2863325, filename: '/usr/local/share/X11/xkb/geometry/everex' }, { start: 2863325, audio: 0, end: 2866091, filename: '/usr/local/share/X11/xkb/geometry/winbook' }, { start: 2866091, audio: 0, end: 2886336, filename: '/usr/local/share/X11/xkb/geometry/dell' }, { start: 2886336, audio: 0, end: 2890372, filename: '/usr/local/share/X11/xkb/geometry/kinesis' }, { start: 2890372, audio: 0, end: 2898153, filename: '/usr/local/share/X11/xkb/geometry/fujitsu' }, { start: 2898153, audio: 0, end: 2902305, filename: '/usr/local/share/X11/xkb/geometry/nec' }, { start: 2902305, audio: 0, end: 2903569, filename: '/usr/local/share/X11/xkb/geometry/nokia' }, { start: 2903569, audio: 0, end: 2923392, filename: '/usr/local/share/X11/xkb/geometry/sun' }, { start: 2923392, audio: 0, end: 2944580, filename: '/usr/local/share/X11/xkb/geometry/typematrix' }, { start: 2944580, audio: 0, end: 2985635, filename: '/usr/local/share/X11/xkb/geometry/macintosh' }, { start: 2985635, audio: 0, end: 3002988, filename: '/usr/local/share/X11/xkb/geometry/hp' }, { start: 3002988, audio: 0, end: 3043548, filename: '/usr/local/share/X11/xkb/geometry/pc' }, { start: 3043548, audio: 0, end: 3047565, filename: '/usr/local/share/X11/xkb/geometry/northgate' }, { start: 3047565, audio: 0, end: 3053340, filename: '/usr/local/share/X11/xkb/geometry/ataritt' }, { start: 3053340, audio: 0, end: 3059568, filename: '/usr/local/share/X11/xkb/geometry/amiga' }, { start: 3059568, audio: 0, end: 3064108, filename: '/usr/local/share/X11/xkb/geometry/chicony' }, { start: 3064108, audio: 0, end: 3070608, filename: '/usr/local/share/X11/xkb/geometry/keytronic' }, { start: 3070608, audio: 0, end: 3076065, filename: '/usr/local/share/X11/xkb/geometry/hhk' }, { start: 3076065, audio: 0, end: 3081943, filename: '/usr/local/share/X11/xkb/geometry/sanwa' }, { start: 3081943, audio: 0, end: 3094078, filename: '/usr/local/share/X11/xkb/geometry/thinkpad' }, { start: 3094078, audio: 0, end: 3094539, filename: '/usr/local/share/X11/xkb/geometry/README' }, { start: 3094539, audio: 0, end: 3099500, filename: '/usr/local/share/X11/xkb/geometry/sony' }, { start: 3099500, audio: 0, end: 3107782, filename: '/usr/local/share/X11/xkb/geometry/steelseries' }, { start: 3107782, audio: 0, end: 3120389, filename: '/usr/local/share/X11/xkb/geometry/microsoft' }, { start: 3120389, audio: 0, end: 3135365, filename: '/usr/local/share/X11/xkb/geometry/sgi_vndr/indy' }, { start: 3135365, audio: 0, end: 3145766, filename: '/usr/local/share/X11/xkb/geometry/sgi_vndr/indigo' }, { start: 3145766, audio: 0, end: 3161089, filename: '/usr/local/share/X11/xkb/geometry/sgi_vndr/O2' }, { start: 3161089, audio: 0, end: 3181725, filename: '/usr/local/share/X11/xkb/geometry/digital_vndr/lk' }, { start: 3181725, audio: 0, end: 3192589, filename: '/usr/local/share/X11/xkb/geometry/digital_vndr/pc' }, { start: 3192589, audio: 0, end: 3199758, filename: '/usr/local/share/X11/xkb/geometry/digital_vndr/unix' }], remote_package_size: 3199758, package_uuid: 'f98413b9-8447-4c22-a29f-44b8e64f7d09' }) })(); var moduleOverrides = {}; var key; for (key in Module) { if (Module.hasOwnProperty(key)) { moduleOverrides[key] = Module[key] } }Module.arguments = []; Module.thisProgram = './this.program'; Module.quit = function (status, toThrow) { throw toThrow }; Module.preRun = []; Module.postRun = []; var ENVIRONMENT_IS_WEB = true; var ENVIRONMENT_IS_WORKER = false; var scriptDirectory = ''; function locateFile (path) { if (Module.locateFile) { return Module.locateFile(path, scriptDirectory) } else { return scriptDirectory + path } } if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (document.currentScript) { scriptDirectory = document.currentScript.src } if (_scriptDir) { scriptDirectory = _scriptDir } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1) } else { scriptDirectory = '' }Module.read = function shell_read (url) { var xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { Module.readBinary = function readBinary (url) { var xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response) } }Module.readAsync = function readAsync (url, onload, onerror) { var xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function xhr_onload () { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return }onerror() }; xhr.onerror = onerror; xhr.send(null) }; Module.setWindowTitle = function (title) { document.title = title } } else {} var out = Module.print || (typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null); var err = Module.printErr || (typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn.bind(console) || out); for (key in moduleOverrides) { if (moduleOverrides.hasOwnProperty(key)) { Module[key] = moduleOverrides[key] } }moduleOverrides = undefined; function dynamicAlloc (size) { var ret = HEAP32[DYNAMICTOP_PTR >> 2]; var end = ret + size + 15 & -16; if (end > _emscripten_get_heap_size()) { abort() }HEAP32[DYNAMICTOP_PTR >> 2] = end; return ret } function getNativeTypeSize (type) { switch (type) { case 'i1':case 'i8':return 1; case 'i16':return 2; case 'i32':return 4; case 'i64':return 8; case 'float':return 4; case 'double':return 8; default: { if (type[type.length - 1] === '*') { return 4 } else if (type[0] === 'i') { var bits = parseInt(type.substr(1)); assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type); return bits / 8 } else { return 0 } } } } var asm2wasmImports = { 'f64-rem': function (x, y) { return x % y }, debugger: function () { debugger } }; var functionPointers = new Array(0); if (typeof WebAssembly !== 'object') { err('no native wasm support detected') } function setValue (ptr, value, type, noSafe) { type = type || 'i8'; if (type.charAt(type.length - 1) === '*')type = 'i32'; switch (type) { case 'i1':HEAP8[ptr >> 0] = value; break; case 'i8':HEAP8[ptr >> 0] = value; break; case 'i16':HEAP16[ptr >> 1] = value; break; case 'i32':HEAP32[ptr >> 2] = value; break; case 'i64':tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1]; break; case 'float':HEAPF32[ptr >> 2] = value; break; case 'double':HEAPF64[ptr >> 3] = value; break; default:abort('invalid type for setValue: ' + type) } } var wasmMemory; var wasmTable; var ABORT = false; var EXITSTATUS = 0; function assert (condition, text) { if (!condition) { abort('Assertion failed: ' + text) } } var ALLOC_NONE = 3; function allocate (slab, types, allocator, ptr) { var zeroinit, size; if (typeof slab === 'number') { zeroinit = true; size = slab } else { zeroinit = false; size = slab.length } var singleType = typeof types === 'string' ? types : null; var ret; if (allocator == ALLOC_NONE) { ret = ptr } else { ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length)) } if (zeroinit) { var stop; ptr = ret; assert((ret & 3) == 0); stop = ret + (size & ~3); for (;ptr < stop; ptr += 4) { HEAP32[ptr >> 2] = 0 }stop = ret + size; while (ptr < stop) { HEAP8[ptr++ >> 0] = 0 } return ret } if (singleType === 'i8') { if (slab.subarray || slab.slice) { HEAPU8.set(slab, ret) } else { HEAPU8.set(new Uint8Array(slab), ret) } return ret } var i = 0; var type; var typeSize; var previousType; while (i < size) { var curr = slab[i]; type = singleType || types[i]; if (type === 0) { i++; continue } if (type == 'i64')type = 'i32'; setValue(ret + i, curr, type); if (previousType !== type) { typeSize = getNativeTypeSize(type); previousType = type }i += typeSize } return ret } function getMemory (size) { if (!runtimeInitialized) return dynamicAlloc(size); return _malloc(size) } var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined; function UTF8ArrayToString (u8Array, idx, maxBytesToRead) { var endIdx = idx + maxBytesToRead; var endPtr = idx; while (u8Array[endPtr] && !(endPtr >= endIdx))++endPtr; if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) { return UTF8Decoder.decode(u8Array.subarray(idx, endPtr)) } else { var str = ''; while (idx < endPtr) { var u0 = u8Array[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } var u1 = u8Array[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } var u2 = u8Array[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } return str } function UTF8ToString (ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '' } function stringToUTF8Array (str, outU8Array, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; var startIdx = outIdx; var endIdx = outIdx + maxBytesToWrite - 1; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { var u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; outU8Array[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; outU8Array[outIdx++] = 192 | u >> 6; outU8Array[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; outU8Array[outIdx++] = 224 | u >> 12; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; outU8Array[outIdx++] = 240 | u >> 18; outU8Array[outIdx++] = 128 | u >> 12 & 63; outU8Array[outIdx++] = 128 | u >> 6 & 63; outU8Array[outIdx++] = 128 | u & 63 } }outU8Array[outIdx] = 0; return outIdx - startIdx } function stringToUTF8 (str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8 (str) { var len = 0; for (var i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343)u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127)++len; else if (u <= 2047)len += 2; else if (u <= 65535)len += 3; else len += 4 } return len } var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined; function allocateUTF8 (str) { var size = lengthBytesUTF8(str) + 1; var ret = _malloc(size); if (ret)stringToUTF8Array(str, HEAP8, ret, size); return ret } function writeAsciiToMemory (str, buffer, dontAddNull) { for (var i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull)HEAP8[buffer >> 0] = 0 } function demangle (func) { return func } function demangleAll (text) { var regex = /__Z[\w\d_]+/g; return text.replace(regex, function (x) { var y = demangle(x); return x === y ? x : y + ' [' + x + ']' }) } function jsStackTrace () { var err = new Error(); if (!err.stack) { try { throw new Error(0) } catch (e) { err = e } if (!err.stack) { return '(no stack trace available)' } } return err.stack.toString() } function stackTrace () { var js = jsStackTrace(); if (Module.extraStackTrace)js += '\n' + Module.extraStackTrace(); return demangleAll(js) } var PAGE_SIZE = 16384; var WASM_PAGE_SIZE = 65536; var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBufferViews () { Module.HEAP8 = HEAP8 = new Int8Array(buffer); Module.HEAP16 = HEAP16 = new Int16Array(buffer); Module.HEAP32 = HEAP32 = new Int32Array(buffer); Module.HEAPU8 = HEAPU8 = new Uint8Array(buffer); Module.HEAPU16 = HEAPU16 = new Uint16Array(buffer); Module.HEAPU32 = HEAPU32 = new Uint32Array(buffer); Module.HEAPF32 = HEAPF32 = new Float32Array(buffer); Module.HEAPF64 = HEAPF64 = new Float64Array(buffer) } var DYNAMIC_BASE = 5346192; var DYNAMICTOP_PTR = 103280; var TOTAL_STACK = 5242880; var INITIAL_TOTAL_MEMORY = Module.TOTAL_MEMORY || 16777216; if (INITIAL_TOTAL_MEMORY < TOTAL_STACK)err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); if (Module.buffer) { buffer = Module.buffer } else { if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') { wasmMemory = new WebAssembly.Memory({ initial: INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE, maximum: INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE }); buffer = wasmMemory.buffer } else { buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY) } }updateGlobalBufferViews(); HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; function callRuntimeCallbacks (callbacks) { while (callbacks.length > 0) { var callback = callbacks.shift(); if (typeof callback === 'function') { callback(); continue } var func = callback.func; if (typeof func === 'number') { if (callback.arg === undefined) { Module.dynCall_v(func) } else { Module.dynCall_vi(func, callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } var __ATPRERUN__ = []; var __ATINIT__ = []; var __ATMAIN__ = []; var __ATPOSTRUN__ = []; var runtimeInitialized = false; function preRun () { if (Module.preRun) { if (typeof Module.preRun === 'function')Module.preRun = [Module.preRun]; while (Module.preRun.length) { addOnPreRun(Module.preRun.shift()) } }callRuntimeCallbacks(__ATPRERUN__) } function initRuntime () { runtimeInitialized = true; if (!Module.noFSInit && !FS.init.initialized)FS.init(); TTY.init(); callRuntimeCallbacks(__ATINIT__) } function preMain () { FS.ignorePermissions = false; callRuntimeCallbacks(__ATMAIN__) } function postRun () { if (Module.postRun) { if (typeof Module.postRun === 'function')Module.postRun = [Module.postRun]; while (Module.postRun.length) { addOnPostRun(Module.postRun.shift()) } }callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun (cb) { __ATPRERUN__.unshift(cb) } function addOnPostRun (cb) { __ATPOSTRUN__.unshift(cb) } var Math_abs = Math.abs; var Math_ceil = Math.ceil; var Math_floor = Math.floor; var Math_min = Math.min; var runDependencies = 0; var runDependencyWatcher = null; var dependenciesFulfilled = null; function getUniqueRunDependency (id) { return id } function addRunDependency (id) { runDependencies++; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } } function removeRunDependency (id) { runDependencies--; if (Module.monitorRunDependencies) { Module.monitorRunDependencies(runDependencies) } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { var callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } }Module.preloadedImages = {}; Module.preloadedAudios = {}; var dataURIPrefix = 'data:application/octet-stream;base64,'; function isDataURI (filename) { return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0 } var wasmBinaryFile = 'libxkbcommon.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinary () { try { if (Module.wasmBinary) { return new Uint8Array(Module.wasmBinary) } if (Module.readBinary) { return Module.readBinary(wasmBinaryFile) } else { throw 'both async and sync fetching of the wasm failed' } } catch (err) { abort(err) } } function getBinaryPromise () { if (!Module.wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { if (!response.ok) { throw "failed to load wasm binary file at '" + wasmBinaryFile + "'" } return response.arrayBuffer() }).catch(function () { return getBinary() }) } return new Promise(function (resolve, reject) { resolve(getBinary()) }) } function createWasm (env) { var info = { env: env, global: { NaN: NaN, Infinity: Infinity }, 'global.Math': Math, asm2wasm: asm2wasmImports }; function receiveInstance (instance, module) { var exports = instance.exports; Module.asm = exports; removeRunDependency('wasm-instantiate') }addRunDependency('wasm-instantiate'); function receiveInstantiatedSource (output) { receiveInstance(output.instance) } function instantiateArrayBuffer (receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info) }).then(receiver, function (reason) { err('failed to asynchronously prepare wasm: ' + reason); abort(reason) }) } function instantiateAsync () { if (!Module.wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') { fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { return WebAssembly.instantiateStreaming(response, info).then(receiveInstantiatedSource, function (reason) { err('wasm streaming compile failed: ' + reason); err('falling back to ArrayBuffer instantiation'); instantiateArrayBuffer(receiveInstantiatedSource) }) }) } else { return instantiateArrayBuffer(receiveInstantiatedSource) } } if (Module.instantiateWasm) { try { return Module.instantiateWasm(info, receiveInstance) } catch (e) { err('Module.instantiateWasm callback failed with error: ' + e); return false } }instantiateAsync(); return {} }Module.asm = function (global, env, providedBuffer) { env.memory = wasmMemory; env.table = wasmTable = new WebAssembly.Table({ initial: 60, maximum: 60, element: 'anyfunc' }); env.__memory_base = 1024; env.__table_base = 0; var exports = createWasm(env); return exports }; __ATINIT__.push({ func: function () { ___emscripten_environ_constructor() } }); function ___assert_fail (condition, filename, line, func) { abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']) } var ENV = {}; function ___buildEnvironment (environ) { var MAX_ENV_VALUES = 64; var TOTAL_ENV_SIZE = 1024; var poolPtr; var envPtr; if (!___buildEnvironment.called) { ___buildEnvironment.called = true; ENV.USER = ENV.LOGNAME = 'web_user'; ENV.PATH = '/'; ENV.PWD = '/'; ENV.HOME = '/home/web_user'; ENV.LANG = 'C.UTF-8'; ENV.LANG = (typeof navigator === 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8'; ENV._ = Module.thisProgram; poolPtr = getMemory(TOTAL_ENV_SIZE); envPtr = getMemory(MAX_ENV_VALUES * 4); HEAP32[envPtr >> 2] = poolPtr; HEAP32[environ >> 2] = envPtr } else { envPtr = HEAP32[environ >> 2]; poolPtr = HEAP32[envPtr >> 2] } var strings = []; var totalSize = 0; for (var key in ENV) { if (typeof ENV[key] === 'string') { var line = key + '=' + ENV[key]; strings.push(line); totalSize += line.length } } if (totalSize > TOTAL_ENV_SIZE) { throw new Error('Environment size exceeded TOTAL_ENV_SIZE!') } var ptrSize = 4; for (var i = 0; i < strings.length; i++) { var line = strings[i]; writeAsciiToMemory(line, poolPtr); HEAP32[envPtr + i * ptrSize >> 2] = poolPtr; poolPtr += line.length + 1 }HEAP32[envPtr + strings.length * ptrSize >> 2] = 0 } function ___lock () {} var PATH = { splitPath: function (filename) { var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1) }, normalizeArray: function (parts, allowAboveRoot) { var up = 0; for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === '.') { parts.splice(i, 1) } else if (last === '..') { parts.splice(i, 1); up++ } else if (up) { parts.splice(i, 1); up-- } } if (allowAboveRoot) { for (;up; up--) { parts.unshift('..') } } return parts }, normalize: function (path) { var isAbsolute = path.charAt(0) === '/'; var trailingSlash = path.substr(-1) === '/'; path = PATH.normalizeArray(path.split('/').filter(function (p) { return !!p }), !isAbsolute).join('/'); if (!path && !isAbsolute) { path = '.' } if (path && trailingSlash) { path += '/' } return (isAbsolute ? '/' : '') + path }, dirname: function (path) { var result = PATH.splitPath(path); var root = result[0]; var dir = result[1]; if (!root && !dir) { return '.' } if (dir) { dir = dir.substr(0, dir.length - 1) } return root + dir }, basename: function (path) { if (path === '/') return '/'; var lastSlash = path.lastIndexOf('/'); if (lastSlash === -1) return path; return path.substr(lastSlash + 1) }, extname: function (path) { return PATH.splitPath(path)[3] }, join: function () { var paths = Array.prototype.slice.call(arguments, 0); return PATH.normalize(paths.join('/')) }, join2: function (l, r) { return PATH.normalize(l + '/' + r) } }; function ___setErrNo (value) { if (Module.___errno_location)HEAP32[Module.___errno_location() >> 2] = value; return value } var PATH_FS = { resolve: function () { var resolvedPath = ''; var resolvedAbsolute = false; for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? arguments[i] : FS.cwd(); if (typeof path !== 'string') { throw new TypeError('Arguments to path.resolve must be strings') } else if (!path) { return '' }resolvedPath = path + '/' + resolvedPath; resolvedAbsolute = path.charAt(0) === '/' }resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p }), !resolvedAbsolute).join('/'); return (resolvedAbsolute ? '/' : '') + resolvedPath || '.' }, relative: function (from, to) { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim (arr) { var start = 0; for (;start < arr.length; start++) { if (arr[start] !== '') break } var end = arr.length - 1; for (;end >= 0; end--) { if (arr[end] !== '') break } if (start > end) return []; return arr.slice(start, end - start + 1) } var fromParts = trim(from.split('/')); var toParts = trim(to.split('/')); var length = Math.min(fromParts.length, toParts.length); var samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } } var outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push('..') }outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join('/') } }; var TTY = { ttys: [], init: function () {}, shutdown: function () {}, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }; FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open: function (stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) { throw new FS.ErrnoError(19) }stream.tty = tty; stream.seekable = false }, close: function (stream) { stream.tty.ops.flush(stream.tty) }, flush: function (stream) { stream.tty.ops.flush(stream.tty) }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) { throw new FS.ErrnoError(6) } var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(5) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(11) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) { throw new FS.ErrnoError(6) } try { for (var i = 0; i < length; i++) { stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } } catch (e) { throw new FS.ErrnoError(5) } if (length) { stream.node.timestamp = Date.now() } return i } }, default_tty_ops: { get_char: function (tty) { if (!tty.input.length) { var result = null; if (typeof window !== 'undefined' && typeof window.prompt === 'function') { result = window.prompt('Input: '); if (result !== null) { result += '\n' } } else if (typeof readline === 'function') { result = readline(); if (result !== null) { result += '\n' } } if (!result) { return null }tty.input = intArrayFromString(result, true) } return tty.input.shift() }, put_char: function (tty, val) { if (val === null || val === 10) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0)tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } }, default_tty1_ops: { put_char: function (tty, val) { if (val === null || val === 10) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0)tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } } }; var MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, '/', 16384 | 511, 0) }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) { throw new FS.ErrnoError(1) } if (!MEMFS.ops_table) { MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } } } var node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) { node.node_ops = MEMFS.ops_table.dir.node; node.stream_ops = MEMFS.ops_table.dir.stream; node.contents = {} } else if (FS.isFile(node.mode)) { node.node_ops = MEMFS.ops_table.file.node; node.stream_ops = MEMFS.ops_table.file.stream; node.usedBytes = 0; node.contents = null } else if (FS.isLink(node.mode)) { node.node_ops = MEMFS.ops_table.link.node; node.stream_ops = MEMFS.ops_table.link.stream } else if (FS.isChrdev(node.mode)) { node.node_ops = MEMFS.ops_table.chrdev.node; node.stream_ops = MEMFS.ops_table.chrdev.stream }node.timestamp = Date.now(); if (parent) { parent.contents[name] = node } return node }, getFileDataAsRegularArray: function (node) { if (node.contents && node.contents.subarray) { var arr = []; for (var i = 0; i < node.usedBytes; ++i)arr.push(node.contents[i]); return arr } return node.contents }, getFileDataAsTypedArray: function (node) { if (!node.contents) return new Uint8Array(); if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents) }, expandFileStorage: function (node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity) return; var CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) | 0); if (prevCapacity != 0)newCapacity = Math.max(newCapacity, 256); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0)node.contents.set(oldContents.subarray(0, node.usedBytes), 0) }, resizeFileStorage: function (node, newSize) { if (node.usedBytes == newSize) return; if (newSize == 0) { node.contents = null; node.usedBytes = 0; return } if (!node.contents || node.contents.subarray) { var oldContents = node.contents; node.contents = new Uint8Array(new ArrayBuffer(newSize)); if (oldContents) { node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))) }node.usedBytes = newSize; return } if (!node.contents)node.contents = []; if (node.contents.length > newSize)node.contents.length = newSize; else while (node.contents.length < newSize)node.contents.push(0); node.usedBytes = newSize }, node_ops: { getattr: function (node) { var attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) { attr.size = 4096 } else if (FS.isFile(node.mode)) { attr.size = node.usedBytes } else if (FS.isLink(node.mode)) { attr.size = node.link.length } else { attr.size = 0 }attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr }, setattr: function (node, attr) { if (attr.mode !== undefined) { node.mode = attr.mode } if (attr.timestamp !== undefined) { node.timestamp = attr.timestamp } if (attr.size !== undefined) { MEMFS.resizeFileStorage(node, attr.size) } }, lookup: function (parent, name) { throw FS.genericErrors[2] }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) { var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) {} if (new_node) { for (var i in new_node.contents) { throw new FS.ErrnoError(39) } } } delete old_node.parent.contents[old_node.name]; old_node.name = new_name; new_dir.contents[new_name] = old_node; old_node.parent = new_dir }, unlink: function (parent, name) { delete parent.contents[name] }, rmdir: function (parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) { throw new FS.ErrnoError(39) } delete parent.contents[name] }, readdir: function (node) { var entries = ['.', '..']; for (var key in node.contents) { if (!node.contents.hasOwnProperty(key)) { continue }entries.push(key) } return entries }, symlink: function (parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node }, readlink: function (node) { if (!FS.isLink(node.mode)) { throw new FS.ErrnoError(22) } return node.link } }, stream_ops: { read: function (stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) { buffer.set(contents.subarray(position, position + size), offset) } else { for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i] } return size }, write: function (stream, buffer, offset, length, position, canOwn) { if (!length) return 0; var node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) { if (canOwn) { node.contents = buffer.subarray(offset, offset + length); node.usedBytes = length; return length } else if (node.usedBytes === 0 && position === 0) { node.contents = new Uint8Array(buffer.subarray(offset, offset + length)); node.usedBytes = length; return length } else if (position + length <= node.usedBytes) { node.contents.set(buffer.subarray(offset, offset + length), position); return length } }MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray)node.contents.set(buffer.subarray(offset, offset + length), position); else { for (var i = 0; i < length; i++) { node.contents[position + i] = buffer[offset + i] } }node.usedBytes = Math.max(node.usedBytes, position + length); return length }, llseek: function (stream, offset, whence) { var position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.usedBytes } } if (position < 0) { throw new FS.ErrnoError(22) } return position }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(19) } var ptr; var allocated; var contents = stream.node.contents; if (!(flags & 2) && (contents.buffer === buffer || contents.buffer === buffer.buffer)) { allocated = false; ptr = contents.byteOffset } else { if (position > 0 || position + length < stream.node.usedBytes) { if (contents.subarray) { contents = contents.subarray(position, position + length) } else { contents = Array.prototype.slice.call(contents, position, position + length) } }allocated = true; ptr = _malloc(length); if (!ptr) { throw new FS.ErrnoError(12) }buffer.set(contents, ptr) } return { ptr: ptr, allocated: allocated } }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(19) } if (mmapFlags & 2) { return 0 } var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0 } } }; var IDBFS = { dbs: {}, indexedDB: function () { if (typeof indexedDB !== 'undefined') return indexedDB; var ret = null; if (typeof window === 'object')ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB; assert(ret, 'IDBFS used, but indexedDB not supported'); return ret }, DB_VERSION: 21, DB_STORE_NAME: 'FILE_DATA', mount: function (mount) { return MEMFS.mount.apply(null, arguments) }, syncfs: function (mount, populate, callback) { IDBFS.getLocalSet(mount, function (err, local) { if (err) return callback(err); IDBFS.getRemoteSet(mount, function (err, remote) { if (err) return callback(err); var src = populate ? remote : local; var dst = populate ? local : remote; IDBFS.reconcile(src, dst, callback) }) }) }, getDB: function (name, callback) { var db = IDBFS.dbs[name]; if (db) { return callback(null, db) } var req; try { req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION) } catch (e) { return callback(e) } if (!req) { return callback('Unable to connect to IndexedDB') }req.onupgradeneeded = function (e) { var db = e.target.result; var transaction = e.target.transaction; var fileStore; if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) { fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME) } else { fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME) } if (!fileStore.indexNames.contains('timestamp')) { fileStore.createIndex('timestamp', 'timestamp', { unique: false }) } }; req.onsuccess = function () { db = req.result; IDBFS.dbs[name] = db; callback(null, db) }; req.onerror = function (e) { callback(this.error); e.preventDefault() } }, getLocalSet: function (mount, callback) { var entries = {}; function isRealDir (p) { return p !== '.' && p !== '..' } function toAbsolute (root) { return function (p) { return PATH.join2(root, p) } } var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint)); while (check.length) { var path = check.pop(); var stat; try { stat = FS.stat(path) } catch (e) { return callback(e) } if (FS.isDir(stat.mode)) { check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path))) }entries[path] = { timestamp: stat.mtime } } return callback(null, { type: 'local', entries: entries }) }, getRemoteSet: function (mount, callback) { var entries = {}; IDBFS.getDB(mount.mountpoint, function (err, db) { if (err) return callback(err); try { var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly'); transaction.onerror = function (e) { callback(this.error); e.preventDefault() }; var store = transaction.objectStore(IDBFS.DB_STORE_NAME); var index = store.index('timestamp'); index.openKeyCursor().onsuccess = function (event) { var cursor = event.target.result; if (!cursor) { return callback(null, { type: 'remote', db: db, entries: entries }) }entries[cursor.primaryKey] = { timestamp: cursor.key }; cursor.continue() } } catch (e) { return callback(e) } }) }, loadLocalEntry: function (path, callback) { var stat, node; try { var lookup = FS.lookupPath(path); node = lookup.node; stat = FS.stat(path) } catch (e) { return callback(e) } if (FS.isDir(stat.mode)) { return callback(null, { timestamp: stat.mtime, mode: stat.mode }) } else if (FS.isFile(stat.mode)) { node.contents = MEMFS.getFileDataAsTypedArray(node); return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents }) } else { return callback(new Error('node type not supported')) } }, storeLocalEntry: function (path, entry, callback) { try { if (FS.isDir(entry.mode)) { FS.mkdir(path, entry.mode) } else if (FS.isFile(entry.mode)) { FS.writeFile(path, entry.contents, { canOwn: true }) } else { return callback(new Error('node type not supported')) }FS.chmod(path, entry.mode); FS.utime(path, entry.timestamp, entry.timestamp) } catch (e) { return callback(e) }callback(null) }, removeLocalEntry: function (path, callback) { try { var lookup = FS.lookupPath(path); var stat = FS.stat(path); if (FS.isDir(stat.mode)) { FS.rmdir(path) } else if (FS.isFile(stat.mode)) { FS.unlink(path) } } catch (e) { return callback(e) }callback(null) }, loadRemoteEntry: function (store, path, callback) { var req = store.get(path); req.onsuccess = function (event) { callback(null, event.target.result) }; req.onerror = function (e) { callback(this.error); e.preventDefault() } }, storeRemoteEntry: function (store, path, entry, callback) { var req = store.put(entry, path); req.onsuccess = function () { callback(null) }; req.onerror = function (e) { callback(this.error); e.preventDefault() } }, removeRemoteEntry: function (store, path, callback) { var req = store.delete(path); req.onsuccess = function () { callback(null) }; req.onerror = function (e) { callback(this.error); e.preventDefault() } }, reconcile: function (src, dst, callback) { var total = 0; var create = []; Object.keys(src.entries).forEach(function (key) { var e = src.entries[key]; var e2 = dst.entries[key]; if (!e2 || e.timestamp > e2.timestamp) { create.push(key); total++ } }); var remove = []; Object.keys(dst.entries).forEach(function (key) { var e = dst.entries[key]; var e2 = src.entries[key]; if (!e2) { remove.push(key); total++ } }); if (!total) { return callback(null) } var errored = false; var completed = 0; var db = src.type === 'remote' ? src.db : dst.db; var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite'); var store = transaction.objectStore(IDBFS.DB_STORE_NAME); function done (err) { if (err) { if (!done.errored) { done.errored = true; return callback(err) } return } if (++completed >= total) { return callback(null) } }transaction.onerror = function (e) { done(this.error); e.preventDefault() }; create.sort().forEach(function (path) { if (dst.type === 'local') { IDBFS.loadRemoteEntry(store, path, function (err, entry) { if (err) return done(err); IDBFS.storeLocalEntry(path, entry, done) }) } else { IDBFS.loadLocalEntry(path, function (err, entry) { if (err) return done(err); IDBFS.storeRemoteEntry(store, path, entry, done) }) } }); remove.sort().reverse().forEach(function (path) { if (dst.type === 'local') { IDBFS.removeLocalEntry(path, done) } else { IDBFS.removeRemoteEntry(store, path, done) } }) } }; var WORKERFS = { DIR_MODE: 16895, FILE_MODE: 33279, reader: null, mount: function (mount) { assert(ENVIRONMENT_IS_WORKER); if (!WORKERFS.reader)WORKERFS.reader = new FileReaderSync(); var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0); var createdParents = {}; function ensureParent (path) { var parts = path.split('/'); var parent = root; for (var i = 0; i < parts.length - 1; i++) { var curr = parts.slice(0, i + 1).join('/'); if (!createdParents[curr]) { createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0) }parent = createdParents[curr] } return parent } function base (path) { var parts = path.split('/'); return parts[parts.length - 1] }Array.prototype.forEach.call(mount.opts.files || [], function (file) { WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate) }); (mount.opts.blobs || []).forEach(function (obj) { WORKERFS.createNode(ensureParent(obj.name), base(obj.name), WORKERFS.FILE_MODE, 0, obj.data) }); (mount.opts.packages || []).forEach(function (pack) { pack.metadata.files.forEach(function (file) { var name = file.filename.substr(1); WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack.blob.slice(file.start, file.end)) }) }); return root }, createNode: function (parent, name, mode, dev, contents, mtime) { var node = FS.createNode(parent, name, mode); node.mode = mode; node.node_ops = WORKERFS.node_ops; node.stream_ops = WORKERFS.stream_ops; node.timestamp = (mtime || new Date()).getTime(); assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE); if (mode === WORKERFS.FILE_MODE) { node.size = contents.size; node.contents = contents } else { node.size = 4096; node.contents = {} } if (parent) { parent.contents[name] = node } return node }, node_ops: { getattr: function (node) { return { dev: 1, ino: undefined, mode: node.mode, nlink: 1, uid: 0, gid: 0, rdev: undefined, size: node.size, atime: new Date(node.timestamp), mtime: new Date(node.timestamp), ctime: new Date(node.timestamp), blksize: 4096, blocks: Math.ceil(node.size / 4096) } }, setattr: function (node, attr) { if (attr.mode !== undefined) { node.mode = attr.mode } if (attr.timestamp !== undefined) { node.timestamp = attr.timestamp } }, lookup: function (parent, name) { throw new FS.ErrnoError(2) }, mknod: function (parent, name, mode, dev) { throw new FS.ErrnoError(1) }, rename: function (oldNode, newDir, newName) { throw new FS.ErrnoError(1) }, unlink: function (parent, name) { throw new FS.ErrnoError(1) }, rmdir: function (parent, name) { throw new FS.ErrnoError(1) }, readdir: function (node) { var entries = ['.', '..']; for (var key in node.contents) { if (!node.contents.hasOwnProperty(key)) { continue }entries.push(key) } return entries }, symlink: function (parent, newName, oldPath) { throw new FS.ErrnoError(1) }, readlink: function (node) { throw new FS.ErrnoError(1) } }, stream_ops: { read: function (stream, buffer, offset, length, position) { if (position >= stream.node.size) return 0; var chunk = stream.node.contents.slice(position, position + length); var ab = WORKERFS.reader.readAsArrayBuffer(chunk); buffer.set(new Uint8Array(ab), offset); return chunk.size }, write: function (stream, buffer, offset, length, position) { throw new FS.ErrnoError(5) }, llseek: function (stream, offset, whence) { var position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.size } } if (position < 0) { throw new FS.ErrnoError(22) } return position } } }; var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: '/', initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function (e) { if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace(); return ___setErrNo(e.errno) }, lookupPath: function (path, opts) { path = PATH_FS.resolve(FS.cwd(), path); opts = opts || {}; if (!path) return { path: '', node: null }; var defaults = { follow_mount: true, recurse_count: 0 }; for (var key in defaults) { if (opts[key] === undefined) { opts[key] = defaults[key] } } if (opts.recurse_count > 8) { throw new FS.ErrnoError(40) } var parts = PATH.normalizeArray(path.split('/').filter(function (p) { return !!p }), false); var current = FS.root; var current_path = '/'; for (var i = 0; i < parts.length; i++) { var islast = i === parts.length - 1; if (islast && opts.parent) { break }current = FS.lookupNode(current, parts[i]); current_path = PATH.join2(current_path, parts[i]); if (FS.isMountpoint(current)) { if (!islast || islast && opts.follow_mount) { current = current.mounted.root } } if (!islast || opts.follow) { var count = 0; while (FS.isLink(current.mode)) { var link = FS.readlink(current_path); current_path = PATH_FS.resolve(PATH.dirname(current_path), link); var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count }); current = lookup.node; if (count++ > 40) { throw new FS.ErrnoError(40) } } } } return { path: current_path, node: current } }, getPath: function (node) { var path; while (true) { if (FS.isRoot(node)) { var mount = node.mount.mountpoint; if (!path) return mount; return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path }path = path ? node.name + '/' + path : node.name; node = node.parent } }, hashName: function (parentid, name) { var hash = 0; for (var i = 0; i < name.length; i++) { hash = (hash << 5) - hash + name.charCodeAt(i) | 0 } return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node }, hashRemoveNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) { FS.nameTable[hash] = node.name_next } else { var current = FS.nameTable[hash]; while (current) { if (current.name_next === node) { current.name_next = node.name_next; break }current = current.name_next } } }, lookupNode: function (parent, name) { var err = FS.mayLookup(parent); if (err) { throw new FS.ErrnoError(err, parent) } var hash = FS.hashName(parent.id, name); for (var node = FS.nameTable[hash]; node; node = node.name_next) { var nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) { return node } } return FS.lookup(parent, name) }, createNode: function (parent, name, mode, rdev) { if (!FS.FSNode) { FS.FSNode = function (parent, name, mode, rdev) { if (!parent) { parent = this } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev }; FS.FSNode.prototype = {}; var readMode = 292 | 73; var writeMode = 146; Object.defineProperties(FS.FSNode.prototype, { read: { get: function () { return (this.mode & readMode) === readMode }, set: function (val) { val ? this.mode |= readMode : this.mode &= ~readMode } }, write: { get: function () { return (this.mode & writeMode) === writeMode }, set: function (val) { val ? this.mode |= writeMode : this.mode &= ~writeMode } }, isFolder: { get: function () { return FS.isDir(this.mode) } }, isDevice: { get: function () { return FS.isChrdev(this.mode) } } }) } var node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node }, destroyNode: function (node) { FS.hashRemoveNode(node) }, isRoot: function (node) { return node === node.parent }, isMountpoint: function (node) { return !!node.mounted }, isFile: function (mode) { return (mode & 61440) === 32768 }, isDir: function (mode) { return (mode & 61440) === 16384 }, isLink: function (mode) { return (mode & 61440) === 40960 }, isChrdev: function (mode) { return (mode & 61440) === 8192 }, isBlkdev: function (mode) { return (mode & 61440) === 24576 }, isFIFO: function (mode) { return (mode & 61440) === 4096 }, isSocket: function (mode) { return (mode & 49152) === 49152 }, flagModes: { r: 0, rs: 1052672, 'r+': 2, w: 577, wx: 705, xw: 705, 'w+': 578, 'wx+': 706, 'xw+': 706, a: 1089, ax: 1217, xa: 1217, 'a+': 1090, 'ax+': 1218, 'xa+': 1218 }, modeStringToFlags: function (str) { var flags = FS.flagModes[str]; if (typeof flags === 'undefined') { throw new Error('Unknown file open mode: ' + str) } return flags }, flagsToPermissionString: function (flag) { var perms = ['r', 'w', 'rw'][flag & 3]; if (flag & 512) { perms += 'w' } return perms }, nodePermissions: function (node, perms) { if (FS.ignorePermissions) { return 0 } if (perms.indexOf('r') !== -1 && !(node.mode & 292)) { return 13 } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) { return 13 } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) { return 13 } return 0 }, mayLookup: function (dir) { var err = FS.nodePermissions(dir, 'x'); if (err) return err; if (!dir.node_ops.lookup) return 13; return 0 }, mayCreate: function (dir, name) { try { var node = FS.lookupNode(dir, name); return 17 } catch (e) {} return FS.nodePermissions(dir, 'wx') }, mayDelete: function (dir, name, isdir) { var node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } var err = FS.nodePermissions(dir, 'wx'); if (err) { return err } if (isdir) { if (!FS.isDir(node.mode)) { return 20 } if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) { return 16 } } else { if (FS.isDir(node.mode)) { return 21 } } return 0 }, mayOpen: function (node, flags) { if (!node) { return 2 } if (FS.isLink(node.mode)) { return 40 } else if (FS.isDir(node.mode)) { if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) { return 21 } } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)) }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) { fd_start = fd_start || 0; fd_end = fd_end || FS.MAX_OPEN_FDS; for (var fd = fd_start; fd <= fd_end; fd++) { if (!FS.streams[fd]) { return fd } } throw new FS.ErrnoError(24) }, getStream: function (fd) { return FS.streams[fd] }, createStream: function (stream, fd_start, fd_end) { if (!FS.FSStream) { FS.FSStream = function () {}; FS.FSStream.prototype = {}; Object.defineProperties(FS.FSStream.prototype, { object: { get: function () { return this.node }, set: function (val) { this.node = val } }, isRead: { get: function () { return (this.flags & 2097155) !== 1 } }, isWrite: { get: function () { return (this.flags & 2097155) !== 0 } }, isAppend: { get: function () { return this.flags & 1024 } } }) } var newStream = new FS.FSStream(); for (var p in stream) { newStream[p] = stream[p] }stream = newStream; var fd = FS.nextfd(fd_start, fd_end); stream.fd = fd; FS.streams[fd] = stream; return stream }, closeStream: function (fd) { FS.streams[fd] = null }, chrdev_stream_ops: { open: function (stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; if (stream.stream_ops.open) { stream.stream_ops.open(stream) } }, llseek: function () { throw new FS.ErrnoError(29) } }, major: function (dev) { return dev >> 8 }, minor: function (dev) { return dev & 255 }, makedev: function (ma, mi) { return ma << 8 | mi }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: function (dev) { return FS.devices[dev] }, getMounts: function (mount) { var mounts = []; var check = [mount]; while (check.length) { var m = check.pop(); mounts.push(m); check.push.apply(check, m.mounts) } return mounts }, syncfs: function (populate, callback) { if (typeof populate === 'function') { callback = populate; populate = false }FS.syncFSRequests++; if (FS.syncFSRequests > 1) { console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work') } var mounts = FS.getMounts(FS.root.mount); var completed = 0; function doCallback (err) { FS.syncFSRequests--; return callback(err) } function done (err) { if (err) { if (!done.errored) { done.errored = true; return doCallback(err) } return } if (++completed >= mounts.length) { doCallback(null) } }mounts.forEach(function (mount) { if (!mount.type.syncfs) { return done(null) }mount.type.syncfs(mount, populate, done) }) }, mount: function (type, opts, mountpoint) { var root = mountpoint === '/'; var pseudo = !mountpoint; var node; if (root && FS.root) { throw new FS.ErrnoError(16) } else if (!root && !pseudo) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); mountpoint = lookup.path; node = lookup.node; if (FS.isMountpoint(node)) { throw new FS.ErrnoError(16) } if (!FS.isDir(node.mode)) { throw new FS.ErrnoError(20) } } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }; var mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) { FS.root = mountRoot } else if (node) { node.mounted = mount; if (node.mount) { node.mount.mounts.push(mount) } } return mountRoot }, unmount: function (mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) { throw new FS.ErrnoError(22) } var node = lookup.node; var mount = node.mounted; var mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach(function (hash) { var current = FS.nameTable[hash]; while (current) { var next = current.name_next; if (mounts.indexOf(current.mount) !== -1) { FS.destroyNode(current) }current = next } }); node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1) }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name) }, mknod: function (path, mode, dev) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); if (!name || name === '.' || name === '..') { throw new FS.ErrnoError(22) } var err = FS.mayCreate(parent, name); if (err) { throw new FS.ErrnoError(err) } if (!parent.node_ops.mknod) { throw new FS.ErrnoError(1) } return parent.node_ops.mknod(parent, name, mode, dev) }, create: function (path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0) }, mkdir: function (path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0) }, mkdirTree: function (path, mode) { var dirs = path.split('/'); var d = ''; for (var i = 0; i < dirs.length; ++i) { if (!dirs[i]) continue; d += '/' + dirs[i]; try { FS.mkdir(d, mode) } catch (e) { if (e.errno != 17) throw e } } }, mkdev: function (path, mode, dev) { if (typeof dev === 'undefined') { dev = mode; mode = 438 }mode |= 8192; return FS.mknod(path, mode, dev) }, symlink: function (oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) { throw new FS.ErrnoError(2) } var lookup = FS.lookupPath(newpath, { parent: true }); var parent = lookup.node; if (!parent) { throw new FS.ErrnoError(2) } var newname = PATH.basename(newpath); var err = FS.mayCreate(parent, newname); if (err) { throw new FS.ErrnoError(err) } if (!parent.node_ops.symlink) { throw new FS.ErrnoError(1) } return parent.node_ops.symlink(parent, newname, oldpath) }, rename: function (old_path, new_path) { var old_dirname = PATH.dirname(old_path); var new_dirname = PATH.dirname(new_path); var old_name = PATH.basename(old_path); var new_name = PATH.basename(new_path); var lookup, old_dir, new_dir; try { lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node } catch (e) { throw new FS.ErrnoError(16) } if (!old_dir || !new_dir) throw new FS.ErrnoError(2); if (old_dir.mount !== new_dir.mount) { throw new FS.ErrnoError(18) } var old_node = FS.lookupNode(old_dir, old_name); var relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== '.') { throw new FS.ErrnoError(22) }relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== '.') { throw new FS.ErrnoError(39) } var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) {} if (old_node === new_node) { return } var isdir = FS.isDir(old_node.mode); var err = FS.mayDelete(old_dir, old_name, isdir); if (err) { throw new FS.ErrnoError(err) }err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (err) { throw new FS.ErrnoError(err) } if (!old_dir.node_ops.rename) { throw new FS.ErrnoError(1) } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) { throw new FS.ErrnoError(16) } if (new_dir !== old_dir) { err = FS.nodePermissions(old_dir, 'w'); if (err) { throw new FS.ErrnoError(err) } } try { if (FS.trackingDelegate.willMovePath) { FS.trackingDelegate.willMovePath(old_path, new_path) } } catch (e) { console.log("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message) }FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name) } catch (e) { throw e } finally { FS.hashAddNode(old_node) } try { if (FS.trackingDelegate.onMovePath)FS.trackingDelegate.onMovePath(old_path, new_path) } catch (e) { console.log("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message) } }, rmdir: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var err = FS.mayDelete(parent, name, true); if (err) { throw new FS.ErrnoError(err) } if (!parent.node_ops.rmdir) { throw new FS.ErrnoError(1) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(16) } try { if (FS.trackingDelegate.willDeletePath) { FS.trackingDelegate.willDeletePath(path) } } catch (e) { console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message) }parent.node_ops.rmdir(parent, name); FS.destroyNode(node); try { if (FS.trackingDelegate.onDeletePath)FS.trackingDelegate.onDeletePath(path) } catch (e) { console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message) } }, readdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; if (!node.node_ops.readdir) { throw new FS.ErrnoError(20) } return node.node_ops.readdir(node) }, unlink: function (path) { var lookup = FS.lookupPath(path, { parent: true }); var parent = lookup.node; var name = PATH.basename(path); var node = FS.lookupNode(parent, name); var err = FS.mayDelete(parent, name, false); if (err) { throw new FS.ErrnoError(err) } if (!parent.node_ops.unlink) { throw new FS.ErrnoError(1) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(16) } try { if (FS.trackingDelegate.willDeletePath) { FS.trackingDelegate.willDeletePath(path) } } catch (e) { console.log("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message) }parent.node_ops.unlink(parent, name); FS.destroyNode(node); try { if (FS.trackingDelegate.onDeletePath)FS.trackingDelegate.onDeletePath(path) } catch (e) { console.log("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message) } }, readlink: function (path) { var lookup = FS.lookupPath(path); var link = lookup.node; if (!link) { throw new FS.ErrnoError(2) } if (!link.node_ops.readlink) { throw new FS.ErrnoError(22) } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)) }, stat: function (path, dontFollow) { var lookup = FS.lookupPath(path, { follow: !dontFollow }); var node = lookup.node; if (!node) { throw new FS.ErrnoError(2) } if (!node.node_ops.getattr) { throw new FS.ErrnoError(1) } return node.node_ops.getattr(node) }, lstat: function (path) { return FS.stat(path, true) }, chmod: function (path, mode, dontFollow) { var node; if (typeof path === 'string') { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(1) }node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }) }, lchmod: function (path, mode) { FS.chmod(path, mode, true) }, fchmod: function (fd, mode) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(9) }FS.chmod(stream.node, mode) }, chown: function (path, uid, gid, dontFollow) { var node; if (typeof path === 'string') { var lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(1) }node.node_ops.setattr(node, { timestamp: Date.now() }) }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, true) }, fchown: function (fd, uid, gid) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(9) }FS.chown(stream.node, uid, gid) }, truncate: function (path, len) { if (len < 0) { throw new FS.ErrnoError(22) } var node; if (typeof path === 'string') { var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(1) } if (FS.isDir(node.mode)) { throw new FS.ErrnoError(21) } if (!FS.isFile(node.mode)) { throw new FS.ErrnoError(22) } var err = FS.nodePermissions(node, 'w'); if (err) { throw new FS.ErrnoError(err) }node.node_ops.setattr(node, { size: len, timestamp: Date.now() }) }, ftruncate: function (fd, len) { var stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(9) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(22) }FS.truncate(stream.node, len) }, utime: function (path, atime, mtime) { var lookup = FS.lookupPath(path, { follow: true }); var node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }) }, open: function (path, flags, mode, fd_start, fd_end) { if (path === '') { throw new FS.ErrnoError(2) }flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags; mode = typeof mode === 'undefined' ? 438 : mode; if (flags & 64) { mode = mode & 4095 | 32768 } else { mode = 0 } var node; if (typeof path === 'object') { node = path } else { path = PATH.normalize(path); try { var lookup = FS.lookupPath(path, { follow: !(flags & 131072) }); node = lookup.node } catch (e) {} } var created = false; if (flags & 64) { if (node) { if (flags & 128) { throw new FS.ErrnoError(17) } } else { node = FS.mknod(path, mode, 0); created = true } } if (!node) { throw new FS.ErrnoError(2) } if (FS.isChrdev(node.mode)) { flags &= ~512 } if (flags & 65536 && !FS.isDir(node.mode)) { throw new FS.ErrnoError(20) } if (!created) { var err = FS.mayOpen(node, flags); if (err) { throw new FS.ErrnoError(err) } } if (flags & 512) { FS.truncate(node, 0) }flags &= ~(128 | 512); var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end); if (stream.stream_ops.open) { stream.stream_ops.open(stream) } if (Module.logReadFiles && !(flags & 1)) { if (!FS.readFiles)FS.readFiles = {}; if (!(path in FS.readFiles)) { FS.readFiles[path] = 1; console.log('FS.trackingDelegate error on read file: ' + path) } } try { if (FS.trackingDelegate.onOpenFile) { var trackingFlags = 0; if ((flags & 2097155) !== 1) { trackingFlags |= FS.tracking.openFlags.READ } if ((flags & 2097155) !== 0) { trackingFlags |= FS.tracking.openFlags.WRITE }FS.trackingDelegate.onOpenFile(path, trackingFlags) } } catch (e) { console.log("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message) } return stream }, close: function (stream) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(9) } if (stream.getdents)stream.getdents = null; try { if (stream.stream_ops.close) { stream.stream_ops.close(stream) } } catch (e) { throw e } finally { FS.closeStream(stream.fd) }stream.fd = null }, isClosed: function (stream) { return stream.fd === null }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(9) } if (!stream.seekable || !stream.stream_ops.llseek) { throw new FS.ErrnoError(29) } if (whence != 0 && whence != 1 && whence != 2) { throw new FS.ErrnoError(22) }stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) { throw new FS.ErrnoError(22) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(9) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(9) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(21) } if (!stream.stream_ops.read) { throw new FS.ErrnoError(22) } var seeking = typeof position !== 'undefined'; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(29) } var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking)stream.position += bytesRead; return bytesRead }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) { throw new FS.ErrnoError(22) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(9) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(9) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(21) } if (!stream.stream_ops.write) { throw new FS.ErrnoError(22) } if (stream.flags & 1024) { FS.llseek(stream, 0, 2) } var seeking = typeof position !== 'undefined'; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(29) } var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking)stream.position += bytesWritten; try { if (stream.path && FS.trackingDelegate.onWriteToFile)FS.trackingDelegate.onWriteToFile(stream.path) } catch (e) { console.log("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message) } return bytesWritten }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(9) } if (offset < 0 || length <= 0) { throw new FS.ErrnoError(22) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(9) } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(19) } if (!stream.stream_ops.allocate) { throw new FS.ErrnoError(95) }stream.stream_ops.allocate(stream, offset, length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) { throw new FS.ErrnoError(13) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(13) } if (!stream.stream_ops.mmap) { throw new FS.ErrnoError(19) } return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags) }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!stream || !stream.stream_ops.msync) { return 0 } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) }, munmap: function (stream) { return 0 }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) { throw new FS.ErrnoError(25) } return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile: function (path, opts) { opts = opts || {}; opts.flags = opts.flags || 'r'; opts.encoding = opts.encoding || 'binary'; if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') { throw new Error('Invalid encoding type "' + opts.encoding + '"') } var ret; var stream = FS.open(path, opts.flags); var stat = FS.stat(path); var length = stat.size; var buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === 'utf8') { ret = UTF8ArrayToString(buf, 0) } else if (opts.encoding === 'binary') { ret = buf }FS.close(stream); return ret }, writeFile: function (path, data, opts) { opts = opts || {}; opts.flags = opts.flags || 'w'; var stream = FS.open(path, opts.flags, opts.mode); if (typeof data === 'string') { var buf = new Uint8Array(lengthBytesUTF8(data) + 1); var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length); FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn) } else if (ArrayBuffer.isView(data)) { FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn) } else { throw new Error('Unsupported data type') }FS.close(stream) }, cwd: function () { return FS.currentPath }, chdir: function (path) { var lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) { throw new FS.ErrnoError(2) } if (!FS.isDir(lookup.node.mode)) { throw new FS.ErrnoError(20) } var err = FS.nodePermissions(lookup.node, 'x'); if (err) { throw new FS.ErrnoError(err) }FS.currentPath = lookup.path }, createDefaultDirectories: function () { FS.mkdir('/tmp'); FS.mkdir('/home'); FS.mkdir('/home/web_user') }, createDefaultDevices: function () { FS.mkdir('/dev'); FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0 }, write: function (stream, buffer, offset, length, pos) { return length } }); FS.mkdev('/dev/null', FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev('/dev/tty', FS.makedev(5, 0)); FS.mkdev('/dev/tty1', FS.makedev(6, 0)); var random_device; if (typeof crypto === 'object' && typeof crypto.getRandomValues === 'function') { var randomBuffer = new Uint8Array(1); random_device = function () { crypto.getRandomValues(randomBuffer); return randomBuffer[0] } } else {} if (!random_device) { random_device = function () { abort('random_device') } }FS.createDevice('/dev', 'random', random_device); FS.createDevice('/dev', 'urandom', random_device); FS.mkdir('/dev/shm'); FS.mkdir('/dev/shm/tmp') }, createSpecialDirectories: function () { FS.mkdir('/proc'); FS.mkdir('/proc/self'); FS.mkdir('/proc/self/fd'); FS.mount({ mount: function () { var node = FS.createNode('/proc/self', 'fd', 16384 | 511, 73); node.node_ops = { lookup: function (parent, name) { var fd = +name; var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(9); var ret = { parent: null, mount: { mountpoint: 'fake' }, node_ops: { readlink: function () { return stream.path } } }; ret.parent = ret; return ret } }; return node } }, {}, '/proc/self/fd') }, createStandardStreams: function () { if (Module.stdin) { FS.createDevice('/dev', 'stdin', Module.stdin) } else { FS.symlink('/dev/tty', '/dev/stdin') } if (Module.stdout) { FS.createDevice('/dev', 'stdout', null, Module.stdout) } else { FS.symlink('/dev/tty', '/dev/stdout') } if (Module.stderr) { FS.createDevice('/dev', 'stderr', null, Module.stderr) } else { FS.symlink('/dev/tty1', '/dev/stderr') } var stdin = FS.open('/dev/stdin', 'r'); var stdout = FS.open('/dev/stdout', 'w'); var stderr = FS.open('/dev/stderr', 'w') }, ensureErrnoError: function () { if (FS.ErrnoError) return; FS.ErrnoError = function ErrnoError (errno, node) { this.node = node; this.setErrno = function (errno) { this.errno = errno }; this.setErrno(errno); this.message = 'FS error'; if (this.stack)Object.defineProperty(this, 'stack', { value: (new Error()).stack, writable: true }) }; FS.ErrnoError.prototype = new Error(); FS.ErrnoError.prototype.constructor = FS.ErrnoError; [2].forEach(function (code) { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = '<generic error, no stack>' }) }, staticInit: function () { FS.ensureErrnoError(); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, '/'); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { MEMFS: MEMFS, IDBFS: IDBFS, WORKERFS: WORKERFS } }, init: function (input, output, error) { FS.init.initialized = true; FS.ensureErrnoError(); Module.stdin = input || Module.stdin; Module.stdout = output || Module.stdout; Module.stderr = error || Module.stderr; FS.createStandardStreams() }, quit: function () { FS.init.initialized = false; var fflush = Module._fflush; if (fflush)fflush(0); for (var i = 0; i < FS.streams.length; i++) { var stream = FS.streams[i]; if (!stream) { continue }FS.close(stream) } }, getMode: function (canRead, canWrite) { var mode = 0; if (canRead)mode |= 292 | 73; if (canWrite)mode |= 146; return mode }, joinPath: function (parts, forceRelative) { var path = PATH.join.apply(null, parts); if (forceRelative && path[0] == '/')path = path.substr(1); return path }, absolutePath: function (relative, base) { return PATH_FS.resolve(base, relative) }, standardizePath: function (path) { return PATH.normalize(path) }, findObject: function (path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); if (ret.exists) { return ret.object } else { ___setErrNo(ret.error); return null } }, analyzePath: function (path, dontResolveLastLink) { try { var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); path = lookup.path } catch (e) {} var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: true }); ret.parentExists = true; ret.parentPath = lookup.path; ret.parentObject = lookup.node; ret.name = PATH.basename(path); lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); ret.exists = true; ret.path = lookup.path; ret.object = lookup.node; ret.name = lookup.node.name; ret.isRoot = lookup.path === '/' } catch (e) { ret.error = e.errno } return ret }, createFolder: function (parent, name, canRead, canWrite) { var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); var mode = FS.getMode(canRead, canWrite); return FS.mkdir(path, mode) }, createPath: function (parent, path, canRead, canWrite) { parent = typeof parent === 'string' ? parent : FS.getPath(parent); var parts = path.split('/').reverse(); while (parts.length) { var part = parts.pop(); if (!part) continue; var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) {}parent = current } return current }, createFile: function (parent, name, properties, canRead, canWrite) { var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); var mode = FS.getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent; var mode = FS.getMode(canRead, canWrite); var node = FS.create(path, mode); if (data) { if (typeof data === 'string') { var arr = new Array(data.length); for (var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr }FS.chmod(node, mode | 146); var stream = FS.open(node, 'w'); FS.write(stream, data, 0, data.length, 0, canOwn); FS.close(stream); FS.chmod(node, mode) } return node }, createDevice: function (parent, name, input, output) { var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); var mode = FS.getMode(!!input, !!output); if (!FS.createDevice.major)FS.createDevice.major = 64; var dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open: function (stream) { stream.seekable = false }, close: function (stream) { if (output && output.buffer && output.buffer.length) { output(10) } }, read: function (stream, buffer, offset, length, pos) { var bytesRead = 0; for (var i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(5) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(11) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) { try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(5) } } if (length) { stream.node.timestamp = Date.now() } return i } }); return FS.mkdev(path, mode, dev) }, createLink: function (parent, name, target, canRead, canWrite) { var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); return FS.symlink(target, path) }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true; var success = true; if (typeof XMLHttpRequest !== 'undefined') { throw new Error('Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.') } else if (Module.read) { try { obj.contents = intArrayFromString(Module.read(obj.url), true); obj.usedBytes = obj.contents.length } catch (e) { success = false } } else { throw new Error('Cannot load without read() or XMLHttpRequest.') } if (!success)___setErrNo(5); return success }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array () { this.lengthKnown = false; this.chunks = [] }LazyUint8Array.prototype.get = function LazyUint8Array_get (idx) { if (idx > this.length - 1 || idx < 0) { return undefined } var chunkOffset = idx % this.chunkSize; var chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] }; LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter (getter) { this.getter = getter }; LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength () { var xhr = new XMLHttpRequest(); xhr.open('HEAD', url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + '. Status: ' + xhr.status); var datalength = Number(xhr.getResponseHeader('Content-length')); var header; var hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes'; var usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip'; var chunkSize = 1024 * 1024; if (!hasByteServing)chunkSize = datalength; var doXHR = function (from, to) { if (from > to) throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!'); if (to > datalength - 1) throw new Error('only ' + datalength + ' bytes available! programmer error!'); var xhr = new XMLHttpRequest(); xhr.open('GET', url, false); if (datalength !== chunkSize)xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to); if (typeof Uint8Array !== 'undefined')xhr.responseType = 'arraybuffer'; if (xhr.overrideMimeType) { xhr.overrideMimeType('text/plain; charset=x-user-defined') }xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + '. Status: ' + xhr.status); if (xhr.response !== undefined) { return new Uint8Array(xhr.response || []) } else { return intArrayFromString(xhr.responseText || '', true) } }; var lazyArray = this; lazyArray.setDataGetter(function (chunkNum) { var start = chunkNum * chunkSize; var end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] === 'undefined') { lazyArray.chunks[chunkNum] = doXHR(start, end) } if (typeof lazyArray.chunks[chunkNum] === 'undefined') throw new Error('doXHR failed!'); return lazyArray.chunks[chunkNum] }); if (usesGzip || !datalength) { chunkSize = datalength = 1; datalength = this.getter(0).length; chunkSize = datalength; console.log('LazyFiles on gzip forces download of the whole file when length is accessed') } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true }; if (typeof XMLHttpRequest !== 'undefined') { if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc'; var lazyArray = new LazyUint8Array(); Object.defineProperties(lazyArray, { length: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._length } }, chunkSize: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._chunkSize } } }); var properties = { isDevice: false, contents: lazyArray } } else { var properties = { isDevice: false, url: url } } var node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) { node.contents = properties.contents } else if (properties.url) { node.contents = null; node.url = properties.url }Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); var stream_ops = {}; var keys = Object.keys(node.stream_ops); keys.forEach(function (key) { var fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile () { if (!FS.forceLoadFile(node)) { throw new FS.ErrnoError(5) } return fn.apply(null, arguments) } }); stream_ops.read = function stream_ops_read (stream, buffer, offset, length, position) { if (!FS.forceLoadFile(node)) { throw new FS.ErrnoError(5) } var contents = stream.node.contents; if (position >= contents.length) return 0; var size = Math.min(contents.length - position, length); if (contents.slice) { for (var i = 0; i < size; i++) { buffer[offset + i] = contents[position + i] } } else { for (var i = 0; i < size; i++) { buffer[offset + i] = contents.get(position + i) } } return size }; node.stream_ops = stream_ops; return node }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { Browser.init(); var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; var dep = getUniqueRunDependency('cp ' + fullname); function processData (byteArray) { function finish (byteArray) { if (preFinish)preFinish(); if (!dontCreateFile) { FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn) } if (onload)onload(); removeRunDependency(dep) } var handled = false; Module.preloadPlugins.forEach(function (plugin) { if (handled) return; if (plugin.canHandle(fullname)) { plugin.handle(byteArray, fullname, finish, function () { if (onerror)onerror(); removeRunDependency(dep) }); handled = true } }); if (!handled)finish(byteArray) }addRunDependency(dep); if (typeof url === 'string') { Browser.asyncLoad(url, function (byteArray) { processData(byteArray) }, onerror) } else { processData(url) } }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return 'EM_FS_' + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: 'FILE_DATA', saveFilesToDB: function (paths, onload, onerror) { onload = onload || function () {}; onerror = onerror || function () {}; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) }openRequest.onupgradeneeded = function openRequest_onupgradeneeded () { console.log('creating db'); var db = openRequest.result; db.createObjectStore(FS.DB_STORE_NAME) }; openRequest.onsuccess = function openRequest_onsuccess () { var db = openRequest.result; var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite'); var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0; var fail = 0; var total = paths.length; function finish () { if (fail == 0)onload(); else onerror() }paths.forEach(function (path) { var putRequest = files.put(FS.analyzePath(path).object.contents, path); putRequest.onsuccess = function putRequest_onsuccess () { ok++; if (ok + fail == total)finish() }; putRequest.onerror = function putRequest_onerror () { fail++; if (ok + fail == total)finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror }, loadFilesFromDB: function (paths, onload, onerror) { onload = onload || function () {}; onerror = onerror || function () {}; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) }openRequest.onupgradeneeded = onerror; openRequest.onsuccess = function openRequest_onsuccess () { var db = openRequest.result; try { var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly') } catch (e) { onerror(e); return } var files = transaction.objectStore(FS.DB_STORE_NAME); var ok = 0; var fail = 0; var total = paths.length; function finish () { if (fail == 0)onload(); else onerror() }paths.forEach(function (path) { var getRequest = files.get(path); getRequest.onsuccess = function getRequest_onsuccess () { if (FS.analyzePath(path).exists) { FS.unlink(path) }FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true); ok++; if (ok + fail == total)finish() }; getRequest.onerror = function getRequest_onerror () { fail++; if (ok + fail == total)finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror } }; var SYSCALLS = { DEFAULT_POLLMASK: 5, mappings: {}, umask: 511, calculateAt: function (dirfd, path) { if (path[0] !== '/') { var dir; if (dirfd === -100) { dir = FS.cwd() } else { var dirstream = FS.getStream(dirfd); if (!dirstream) throw new FS.ErrnoError(9); dir = dirstream.path }path = PATH.join2(dir, path) } return path }, doStat: function (func, path, buf) { try { var stat = func(path) } catch (e) { if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) { return -20 } throw e }HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = 0; HEAP32[buf + 8 >> 2] = stat.ino; HEAP32[buf + 12 >> 2] = stat.mode; HEAP32[buf + 16 >> 2] = stat.nlink; HEAP32[buf + 20 >> 2] = stat.uid; HEAP32[buf + 24 >> 2] = stat.gid; HEAP32[buf + 28 >> 2] = stat.rdev; HEAP32[buf + 32 >> 2] = 0; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAP32[buf + 48 >> 2] = 4096; HEAP32[buf + 52 >> 2] = stat.blocks; HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0; HEAP32[buf + 60 >> 2] = 0; HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0; HEAP32[buf + 68 >> 2] = 0; HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0; HEAP32[buf + 76 >> 2] = 0; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1]; return 0 }, doMsync: function (addr, stream, len, flags) { var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len)); FS.msync(stream, buffer, 0, len, flags) }, doMkdir: function (path, mode) { path = PATH.normalize(path); if (path[path.length - 1] === '/')path = path.substr(0, path.length - 1); FS.mkdir(path, mode, 0); return 0 }, doMknod: function (path, mode, dev) { switch (mode & 61440) { case 32768:case 8192:case 24576:case 4096:case 49152:break; default:return -22 }FS.mknod(path, mode, dev); return 0 }, doReadlink: function (path, buf, bufsize) { if (bufsize <= 0) return -22; var ret = FS.readlink(path); var len = Math.min(bufsize, lengthBytesUTF8(ret)); var endChar = HEAP8[buf + len]; stringToUTF8(ret, buf, bufsize + 1); HEAP8[buf + len] = endChar; return len }, doAccess: function (path, amode) { if (amode & ~7) { return -22 } var node; var lookup = FS.lookupPath(path, { follow: true }); node = lookup.node; var perms = ''; if (amode & 4)perms += 'r'; if (amode & 2)perms += 'w'; if (amode & 1)perms += 'x'; if (perms && FS.nodePermissions(node, perms)) { return -13 } return 0 }, doDup: function (path, flags, suggestFD) { var suggest = FS.getStream(suggestFD); if (suggest)FS.close(suggest); return FS.open(path, flags, 0, suggestFD, suggestFD).fd }, doReadv: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + i * 8 >> 2]; var len = HEAP32[iov + (i * 8 + 4) >> 2]; var curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) break } return ret }, doWritev: function (stream, iov, iovcnt, offset) { var ret = 0; for (var i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + i * 8 >> 2]; var len = HEAP32[iov + (i * 8 + 4) >> 2]; var curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr } return ret }, varargs: 0, get: function (varargs) { SYSCALLS.varargs += 4; var ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }, getStr: function () { var ret = UTF8ToString(SYSCALLS.get()); return ret }, getStreamFromFD: function () { var stream = FS.getStream(SYSCALLS.get()); if (!stream) throw new FS.ErrnoError(9); return stream }, get64: function () { var low = SYSCALLS.get(); var high = SYSCALLS.get(); return low }, getZero: function () { SYSCALLS.get() } }; function ___syscall140 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var offset_high = SYSCALLS.get(); var offset_low = SYSCALLS.get(); var result = SYSCALLS.get(); var whence = SYSCALLS.get(); var HIGH_OFFSET = 4294967296; var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0); var DOUBLE_LIMIT = 9007199254740992; if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) { return -75 }FS.llseek(stream, offset, whence); tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[result >> 2] = tempI64[0], HEAP32[result + 4 >> 2] = tempI64[1]; if (stream.getdents && offset === 0 && whence === 0)stream.getdents = null; return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall145 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var iov = SYSCALLS.get(); var iovcnt = SYSCALLS.get(); return SYSCALLS.doReadv(stream, iov, iovcnt) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall146 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var iov = SYSCALLS.get(); var iovcnt = SYSCALLS.get(); return SYSCALLS.doWritev(stream, iov, iovcnt) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall192 (which, varargs) { SYSCALLS.varargs = varargs; try { var addr = SYSCALLS.get(); var len = SYSCALLS.get(); var prot = SYSCALLS.get(); var flags = SYSCALLS.get(); var fd = SYSCALLS.get(); var off = SYSCALLS.get(); off <<= 12; var ptr; var allocated = false; if ((flags & 16) !== 0 && addr % PAGE_SIZE !== 0) { return -22 } if ((flags & 32) !== 0) { ptr = _memalign(PAGE_SIZE, len); if (!ptr) return -12; _memset(ptr, 0, len); allocated = true } else { var info = FS.getStream(fd); if (!info) return -9; var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags); ptr = res.ptr; allocated = res.allocated }SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, flags: flags }; return ptr } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall195 (which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(); var buf = SYSCALLS.get(); return SYSCALLS.doStat(FS.stat, path, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall197 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var buf = SYSCALLS.get(); return SYSCALLS.doStat(FS.stat, stream.path, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall221 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var cmd = SYSCALLS.get(); switch (cmd) { case 0: { var arg = SYSCALLS.get(); if (arg < 0) { return -22 } var newStream; newStream = FS.open(stream.path, stream.flags, 0, arg); return newStream.fd } case 1:case 2:return 0; case 3:return stream.flags; case 4: { var arg = SYSCALLS.get(); stream.flags |= arg; return 0 } case 12: { var arg = SYSCALLS.get(); var offset = 0; HEAP16[arg + offset >> 1] = 2; return 0 } case 13:case 14:return 0; case 16:case 8:return -22; case 9:___setErrNo(22); return -1; default: { return -22 } } } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall5 (which, varargs) { SYSCALLS.varargs = varargs; try { var pathname = SYSCALLS.getStr(); var flags = SYSCALLS.get(); var mode = SYSCALLS.get(); var stream = FS.open(pathname, flags, mode); return stream.fd } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall54 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); var op = SYSCALLS.get(); switch (op) { case 21509:case 21505: { if (!stream.tty) return -25; return 0 } case 21510:case 21511:case 21512:case 21506:case 21507:case 21508: { if (!stream.tty) return -25; return 0 } case 21519: { if (!stream.tty) return -25; var argp = SYSCALLS.get(); HEAP32[argp >> 2] = 0; return 0 } case 21520: { if (!stream.tty) return -25; return -22 } case 21531: { var argp = SYSCALLS.get(); return FS.ioctl(stream, op, argp) } case 21523: { if (!stream.tty) return -25; return 0 } case 21524: { if (!stream.tty) return -25; return 0 } default:abort('bad ioctl syscall ' + op) } } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall6 (which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); FS.close(stream); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall91 (which, varargs) { SYSCALLS.varargs = varargs; try { var addr = SYSCALLS.get(); var len = SYSCALLS.get(); if (addr == -1 || len == 0) { return -22 } var info = SYSCALLS.mappings[addr]; if (!info) return 0; if (len === info.len) { var stream = FS.getStream(info.fd); SYSCALLS.doMsync(addr, stream, len, info.flags); FS.munmap(stream); SYSCALLS.mappings[addr] = null; if (info.allocated) { _free(info.malloc) } } return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___unlock () {} function _emscripten_get_heap_size () { return HEAP8.length } function _getenv (name) { if (name === 0) return 0; name = UTF8ToString(name); if (!ENV.hasOwnProperty(name)) return 0; if (_getenv.ret)_free(_getenv.ret); _getenv.ret = allocateUTF8(ENV[name]); return _getenv.ret } function _emscripten_memcpy_big (dest, src, num) { HEAPU8.set(HEAPU8.subarray(src, src + num), dest) } function abortOnCannotGrowMemory (requestedSize) { abort('OOM') } function _emscripten_resize_heap (requestedSize) { abortOnCannotGrowMemory(requestedSize) }FS.staticInit(); Module.FS_createFolder = FS.createFolder; Module.FS_createPath = FS.createPath; Module.FS_createDataFile = FS.createDataFile; Module.FS_createPreloadedFile = FS.createPreloadedFile; Module.FS_createLazyFile = FS.createLazyFile; Module.FS_createLink = FS.createLink; Module.FS_createDevice = FS.createDevice; Module.FS_unlink = FS.unlink; function intArrayFromString (stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; var u8array = new Array(len); var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)u8array.length = numBytesWritten; return u8array } var asmGlobalArg = {}; var asmLibraryArg = { c: abort, d: ___assert_fail, q: ___buildEnvironment, e: ___lock, j: ___setErrNo, o: ___syscall140, n: ___syscall145, i: ___syscall146, m: ___syscall192, h: ___syscall195, w: ___syscall197, g: ___syscall221, v: ___syscall5, l: ___syscall54, k: ___syscall6, u: ___syscall91, f: ___unlock, t: _emscripten_get_heap_size, s: _emscripten_memcpy_big, r: _emscripten_resize_heap, b: _getenv, p: abortOnCannotGrowMemory, a: DYNAMICTOP_PTR }; var asm = Module.asm(asmGlobalArg, asmLibraryArg, buffer); Module.asm = asm; var ___emscripten_environ_constructor = Module.___emscripten_environ_constructor = function () { return Module.asm.x.apply(null, arguments) }; var ___errno_location = Module.___errno_location = function () { return Module.asm.y.apply(null, arguments) }; var _free = Module._free = function () { return Module.asm.z.apply(null, arguments) }; var _malloc = Module._malloc = function () { return Module.asm.A.apply(null, arguments) }; var _memalign = Module._memalign = function () { return Module.asm.B.apply(null, arguments) }; var _memset = Module._memset = function () { return Module.asm.C.apply(null, arguments) }; var _xkb_context_include_path_append = Module._xkb_context_include_path_append = function () { return Module.asm.D.apply(null, arguments) }; var _xkb_context_new = Module._xkb_context_new = function () { return Module.asm.E.apply(null, arguments) }; var _xkb_keymap_get_as_string = Module._xkb_keymap_get_as_string = function () { return Module.asm.F.apply(null, arguments) }; var _xkb_keymap_new_from_names = Module._xkb_keymap_new_from_names = function () { return Module.asm.G.apply(null, arguments) }; var _xkb_keymap_new_from_string = Module._xkb_keymap_new_from_string = function () { return Module.asm.H.apply(null, arguments) }; var _xkb_state_new = Module._xkb_state_new = function () { return Module.asm.I.apply(null, arguments) }; var _xkb_state_serialize_layout = Module._xkb_state_serialize_layout = function () { return Module.asm.J.apply(null, arguments) }; var _xkb_state_serialize_mods = Module._xkb_state_serialize_mods = function () { return Module.asm.K.apply(null, arguments) }; var _xkb_state_update_key = Module._xkb_state_update_key = function () { return Module.asm.L.apply(null, arguments) }; var stackAlloc = Module.stackAlloc = function () { return Module.asm.M.apply(null, arguments) }; Module.asm = asm; Module.getMemory = getMemory; Module.UTF8ToString = UTF8ToString; Module.stringToUTF8 = stringToUTF8; Module.lengthBytesUTF8 = lengthBytesUTF8; Module.addRunDependency = addRunDependency; Module.removeRunDependency = removeRunDependency; Module.FS = FS; Module.FS_createFolder = FS.createFolder; Module.FS_createPath = FS.createPath; Module.FS_createDataFile = FS.createDataFile; Module.FS_createPreloadedFile = FS.createPreloadedFile; Module.FS_createLazyFile = FS.createLazyFile; Module.FS_createLink = FS.createLink; Module.FS_createDevice = FS.createDevice; Module.FS_unlink = FS.unlink; Module.then = function (func) { if (Module.calledRun) { func(Module) } else { var old = Module.onRuntimeInitialized; Module.onRuntimeInitialized = function () { if (old)old(); func(Module) } } return Module }; function ExitStatus (status) { this.name = 'ExitStatus'; this.message = 'Program terminated with exit(' + status + ')'; this.status = status }ExitStatus.prototype = new Error(); ExitStatus.prototype.constructor = ExitStatus; dependenciesFulfilled = function runCaller () { if (!Module.calledRun)run(); if (!Module.calledRun)dependenciesFulfilled = runCaller }; function run (args) { args = args || Module.arguments; if (runDependencies > 0) { return }preRun(); if (runDependencies > 0) return; if (Module.calledRun) return; function doRun () { if (Module.calledRun) return; Module.calledRun = true; if (ABORT) return; initRuntime(); preMain(); if (Module.onRuntimeInitialized)Module.onRuntimeInitialized(); postRun() } if (Module.setStatus) { Module.setStatus('Running...'); setTimeout(function () { setTimeout(function () { Module.setStatus('') }, 1); doRun() }, 1) } else { doRun() } }Module.run = run; function abort (what) { if (Module.onAbort) { Module.onAbort(what) } if (what !== undefined) { out(what); err(what); what = '"' + what + '"' } else { what = '' }ABORT = true; EXITSTATUS = 1; throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.' }Module.abort = abort; if (Module.preInit) { if (typeof Module.preInit === 'function')Module.preInit = [Module.preInit]; while (Module.preInit.length > 0) { Module.preInit.pop()() } }Module.noExitRuntime = true; run()

      return Module
    }
  )
})()
if (typeof exports === 'object' && typeof module === 'object') { module.exports = Module } else if (typeof define === 'function' && define.amd) { define([], function () { return Module }) } else if (typeof exports === 'object') { exports.Module = Module }
